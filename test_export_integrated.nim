# Generated by tStorie Nim Export (Runtime-Integrated)
# Source: untitled.md
# This program uses tStorie's terminal and rendering system
#
# IMPORTANT: Place this file in the tStorie project root directory to compile
# Or compile with: nim c --path:. <this file>

import times, os
import std/[strutils, tables]  # For join and getOrDefault
import src/types
import src/layers
import src/appstate
import src/input  # Input parsing and polling
import src/simple_event  # Simplified event API
when not defined(emscripten):
  import src/platform/terminal

# Global state
var gState: AppState
var gDefaultLayer: Layer  # Single default layer (layer 0)
var gRunning {.global.} = true
var gInputParser: TerminalInputParser  # For input event parsing
when not defined(emscripten):
  var gTerminalState: TerminalState

# Simplified event API (compatible with nimini runtime)
type
  SimpleEvent* = object
    eventType*: string  # "key", "mouse", "mouse_move", "text"
    x*, y*: int         # Mouse position
    keyCode*: int       # Key code or character
    button*: string     # "left", "right", "middle", "scroll_up", "scroll_down"
    action*: string     # "press", "release", "repeat"
    text*: string       # Text input
    mods*: seq[string]  # ["shift", "alt", "ctrl", "super"]

proc toSimpleEvent(event: InputEvent): SimpleEvent =
  ## Convert native InputEvent to simplified event object
  case event.kind
  of KeyEvent:
    result.eventType = "key"
    result.keyCode = event.keyCode
    result.action = case event.keyAction
      of Press: "press"
      of Release: "release"
      of Repeat: "repeat"
    if ModShift in event.keyMods: result.mods.add("shift")
    if ModAlt in event.keyMods: result.mods.add("alt")
    if ModCtrl in event.keyMods: result.mods.add("ctrl")
    if ModSuper in event.keyMods: result.mods.add("super")
  of TextEvent:
    result.eventType = "text"
    result.text = event.text
    result.keyCode = if event.text.len > 0: int(event.text[0]) else: 0
  of MouseEvent:
    result.eventType = "mouse"
    result.x = event.mouseX
    result.y = event.mouseY
    result.button = case event.button
      of Left: "left"
      of Right: "right"
      of Middle: "middle"
      of ScrollUp: "scroll_up"
      of ScrollDown: "scroll_down"
      of Unknown: "unknown"
    result.action = case event.action
      of Press: "press"
      of Release: "release"
      of Repeat: "repeat"
    if ModShift in event.mods: result.mods.add("shift")
    if ModAlt in event.mods: result.mods.add("alt")
    if ModCtrl in event.mods: result.mods.add("ctrl")
  of MouseMoveEvent:
    result.eventType = "mouse_move"
    result.x = event.moveX
    result.y = event.moveY
    if ModShift in event.moveMods: result.mods.add("shift")
    if ModAlt in event.moveMods: result.mods.add("alt")
    if ModCtrl in event.moveMods: result.mods.add("ctrl")
  of ResizeEvent:
    result.eventType = "resize"

# Compatibility alias: 'event.type' works in addition to 'event.eventType'
template type*(e: SimpleEvent): string = e.eventType

# Style helper function
proc getStyle(name: string): Style =
  if gState.styleSheet.hasKey(name):
    let sc = gState.styleSheet[name]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  elif gState.styleSheet.hasKey("default"):
    # Use theme's default style as fallback
    let sc = gState.styleSheet["default"]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  else:
    result = defaultStyle()

# Unified Drawing API - works with any layer
proc draw(layer: string, x, y: int, text: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc draw(layerId: int, x, y: int, text: string, style: Style = getStyle("default")) =
  # Integer layer ID overload (0 = default layer)
  let targetLayer = if layerId == 0: gDefaultLayer
                    elif layerId < gState.layers.len: gState.layers[layerId]
                    else: nil
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc clear(layer: string = "", transparent: bool = false) =
  # Clear specific layer, or all layers if no layer specified
  if layer == "":
    for l in gState.layers:
      if transparent: l.buffer.clearTransparent()
      else: l.buffer.clear(gState.themeBackground)
  else:
    let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
    if targetLayer.isNil: return
    if transparent: targetLayer.buffer.clearTransparent() else: targetLayer.buffer.clear(gState.themeBackground)

proc fillRect(layer: string, x, y, w, h: int, ch: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.fillRect(x, y, w, h, ch, style)

# Runtime helper functions
proc print(args: varargs[string, `$`]) = echo args.join(" ")
template termWidth: int = gState.termWidth
template termHeight: int = gState.termHeight
proc str(x: int): string = $x
proc str(x: float): string = $x
proc str(x: bool): string = $x
proc str(x: string): string = x

# Lifecycle callbacks
proc onInit() =
  ## Initialization - runs once at startup
  var counter = 0
  counter += 1
  text 0, 0, "Counter: " & $counter
  text 0, 1, "Press CTRL-C to exit"
  text 0, 2, "Terminal should be restored properly"

proc onUpdate(dt: float) =
  ## Update logic - runs every frame
  discard

proc onRender() =
  ## Rendering - runs every frame
  discard

proc main() =
  ## Main entry point with tStorie runtime integration
  when not defined(emscripten):
    # Setup terminal
    gTerminalState = setupRawMode()
    hideCursor()
    enableMouseReporting()
    enableKeyboardProtocol()
    
    # Setup signal handlers for graceful shutdown on CTRL-C
    setupSignalHandlers(proc(sig: cint) {.noconv.} = gRunning = false)
    
    # Get terminal size and initialize state
    let (w, h) = getTermSize()
    gState = newAppState(w, h)
    
    # Initialize default layer (layer 0)
    gDefaultLayer = addLayer(gState, "default", 0)
    
    # Initialize input parser
    gInputParser = newTerminalInputParser()
    
    # User initialization
    onInit()
    
    var lastTime = epochTime()
    
    try:
      # Main event loop
      while gState.running and gRunning:
        let currentTime = epochTime()
        let deltaTime = currentTime - lastTime
        lastTime = currentTime
        
        # Update FPS counter
        gState.updateFpsCounter(deltaTime)
        
        # User update
        onUpdate(deltaTime)
        
        # User render
        onRender()
        
        # Frame rate limiting
        if gState.targetFps > 0.0:
          let frameTime = epochTime() - currentTime
          let targetFrameTime = 1.0 / gState.targetFps
          let sleepTime = targetFrameTime - frameTime
          if sleepTime > 0:
            sleep(int(sleepTime * 1000))
    finally:
      # Cleanup terminal
      disableKeyboardProtocol()
      disableMouseReporting()
      showCursor()
      clearScreen()
      restoreTerminal(gTerminalState)
      stdout.write("\n")
      stdout.flushFile()

when isMainModule:
  main()
