/* Generated by Nim Compiler v2.2.6 */
/* Compiled for: Linux, amd64, gcc */
/* Command for C compiler:
   gcc -c  -w -fmax-errors=3 -fno-strict-aliasing -pthread -Os -fno-ident  -fPIC  -I/home/codespace/.choosenim/toolchains/nim-2.2.6/lib -I/workspaces/telestorie/lib -o /workspaces/telestorie/nimcache_plugin/@mcompression_plugin.nim.c.o /workspaces/telestorie/nimcache_plugin/@mcompression_plugin.nim.c */
#define NIM_INTBITS 64

#include "nimbase.h"
#undef LANGUAGE_C
#undef MIPSEB
#undef MIPSEL
#undef PPC
#undef R3000
#undef R4000
#undef i386
#undef linux
#undef mips
#undef near
#undef far
#undef powerpc
#undef unix
typedef struct NimStrPayload NimStrPayload;
typedef struct NimStringV2 NimStringV2;
typedef struct Exception Exception;
typedef struct RootObj RootObj;
typedef struct TNimTypeV2 TNimTypeV2;
typedef struct tySequence__xhQiLwJj5RFCOa9c4fVuodA tySequence__xhQiLwJj5RFCOa9c4fVuodA;
typedef struct tySequence__xhQiLwJj5RFCOa9c4fVuodA_Content tySequence__xhQiLwJj5RFCOa9c4fVuodA_Content;
typedef struct tyObject_StackTraceEntry__1PUuHpJIPD3aeC4eiQfrTg tyObject_StackTraceEntry__1PUuHpJIPD3aeC4eiQfrTg;
struct NimStrPayload {
	NI cap;
	NIM_CHAR data[SEQ_DECL_SIZE];
};
struct NimStringV2 {
	NI len;
	NimStrPayload* p;
};
struct TNimTypeV2 {
	void* destructor;
	NI size;
	NI16 align;
	NI16 depth;
	NU32* display;
	void* traceImpl;
	void* typeInfoV1;
	NI flags;
	void* vTable[SEQ_DECL_SIZE];
};
struct RootObj {
	TNimTypeV2* m_type;
};
struct tySequence__xhQiLwJj5RFCOa9c4fVuodA {
  NI len; tySequence__xhQiLwJj5RFCOa9c4fVuodA_Content* p;
};
struct Exception {
	RootObj Sup;
	Exception* parent;
	NCSTRING name;
	NimStringV2 message;
	tySequence__xhQiLwJj5RFCOa9c4fVuodA trace;
	Exception* up;
};
struct tyObject_StackTraceEntry__1PUuHpJIPD3aeC4eiQfrTg {
	NCSTRING procname;
	NI line;
	NCSTRING filename;
};
struct tySequence__xhQiLwJj5RFCOa9c4fVuodA_Content { NI cap; tyObject_StackTraceEntry__1PUuHpJIPD3aeC4eiQfrTg data[SEQ_DECL_SIZE]; };
N_LIB_EXPORT N_CDECL(NimStringV2, compressData)(NimStringV2 data_p0);
N_LIB_PRIVATE N_NIMCALL(NimStringV2, encode__pureZbase64_u42)(NIM_CHAR* s_p0, NI s_p0Len_0, NIM_BOOL safe_p1);
static N_INLINE(NIM_BOOL*, nimErrorFlag)(void);
N_LIB_EXPORT N_CDECL(NimStringV2, decompressData)(NimStringV2 data_p0);
N_LIB_PRIVATE N_NIMCALL(NimStringV2, decode__pureZbase64_u519)(NimStringV2 s_p0);
static N_INLINE(void, eqdestroy___system_u281)(NimStringV2 x_p0);
N_LIB_PRIVATE N_NIMCALL(void, raiseDefect)(void);
static N_INLINE(void, popCurrentException)(void);
N_LIB_PRIVATE N_NIMCALL(void, eqcopy___stdZtypedthreads_u223)(Exception** dest_p0, Exception* src_p1, NIM_BOOL cyclic_p2);
N_LIB_EXPORT N_CDECL(NCSTRING, getPluginVersion)(void);
N_LIB_EXPORT N_CDECL(NIM_BOOL, isCompressionAvailable)(void);
N_LIB_EXPORT N_CDECL(NCSTRING, compress_string)(NCSTRING data_p0);
N_LIB_PRIVATE N_NIMCALL(NimStringV2, cstrToNimstr)(NCSTRING str_p0);
static N_INLINE(NCSTRING, nimToCStringConv)(NimStringV2 s_p0);
N_LIB_PRIVATE N_NOCONV(void, deallocShared)(void* p_p0);
N_LIB_EXPORT N_CDECL(NCSTRING, decompress_string)(NCSTRING data_p0);
N_LIB_PRIVATE N_NIMCALL(void, nimTestErrorFlag)(void);
N_LIB_PRIVATE N_NIMCALL(void, atpsystemdotnim_Init000)(void);
N_LIB_PRIVATE N_NIMCALL(void, NimMainModule)(void);
static const struct {
  NI cap; NIM_CHAR data[0+1];
} TM__mP5NZI4gYbgb7jbHWmHyJg_2 = { 0 | NIM_STRLIT_FLAG, "" };
static const NimStringV2 TM__mP5NZI4gYbgb7jbHWmHyJg_3 = {0, (NimStrPayload*)&TM__mP5NZI4gYbgb7jbHWmHyJg_2};
extern NIM_THREADVAR NIM_BOOL nimInErrorMode__system_u4363;
extern NIM_THREADVAR Exception* currException__system_u4070;
static N_INLINE(NIM_BOOL*, nimErrorFlag)(void) {
	NIM_BOOL* result;
	result = (&nimInErrorMode__system_u4363);
	return result;
}
N_LIB_EXPORT N_CDECL(NimStringV2, compressData)(NimStringV2 data_p0) {
	NimStringV2 result;
NIM_BOOL* nimErr_;
{nimErr_ = nimErrorFlag();
	result.len = 0; result.p = NIM_NIL;
	result = encode__pureZbase64_u42(((data_p0).p) ? (data_p0.p->data) : NIM_NIL, data_p0.len, NIM_FALSE);
	if (NIM_UNLIKELY(*nimErr_)) goto BeforeRet_;
	}BeforeRet_: ;
	return result;
}
static N_INLINE(void, eqdestroy___system_u281)(NimStringV2 x_p0) {
}
static N_INLINE(void, popCurrentException)(void) {
	eqcopy___stdZtypedthreads_u223(&currException__system_u4070, (*currException__system_u4070).up, NIM_FALSE);
}
N_LIB_EXPORT N_CDECL(NimStringV2, decompressData)(NimStringV2 data_p0) {
	NimStringV2 result;
	NimStringV2 T2_;
NIM_BOOL* nimErr_;
{nimErr_ = nimErrorFlag();
	result.len = 0; result.p = NIM_NIL;
	T2_.len = 0; T2_.p = NIM_NIL;
	T2_ = decode__pureZbase64_u519(data_p0);
	if (NIM_UNLIKELY(*nimErr_)) {eqdestroy___system_u281(T2_); goto LA1_;}
	result = T2_;
	if (NIM_UNLIKELY(*nimErr_)) {
		LA1_:;
		{
			*nimErr_ = NIM_FALSE;
			raiseDefect();
			result = TM__mP5NZI4gYbgb7jbHWmHyJg_3;
			popCurrentException();
			LA4_:;
		}
	}
	if (NIM_UNLIKELY(*nimErr_)) goto BeforeRet_;
	}BeforeRet_: ;
	return result;
}
N_LIB_EXPORT N_CDECL(NCSTRING, getPluginVersion)(void) {
	NCSTRING result;
{	result = "compression_plugin v1.0.0";
	goto BeforeRet_;
	}BeforeRet_: ;
	return result;
}
N_LIB_EXPORT N_CDECL(NIM_BOOL, isCompressionAvailable)(void) {
	NIM_BOOL result;
{	result = NIM_TRUE;
	goto BeforeRet_;
	}BeforeRet_: ;
	return result;
}
static N_INLINE(NCSTRING, nimToCStringConv)(NimStringV2 s_p0) {
	NCSTRING result;
	{
		if (!(s_p0.len == ((NI)0))) goto LA3_;
		result = "";
	}
	goto LA1_;
LA3_: ;
	{
		result = ((NCSTRING) ((*s_p0.p).data));
	}
LA1_: ;
	return result;
}
N_LIB_EXPORT N_CDECL(NCSTRING, compress_string)(NCSTRING data_p0) {
	NCSTRING result;
	NimStringV2 input_1;
	NimStringV2 compressed_1;
NIM_BOOL* nimErr_;
{nimErr_ = nimErrorFlag();
	result = (NCSTRING)0;
	input_1.len = 0; input_1.p = NIM_NIL;
	compressed_1.len = 0; compressed_1.p = NIM_NIL;
	input_1 = cstrToNimstr(data_p0);
	compressed_1 = compressData(input_1);
	if (NIM_UNLIKELY(*nimErr_)) goto LA1_;
	result = nimToCStringConv(compressed_1);
	if (compressed_1.p && !(compressed_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(compressed_1.p);
}
	if (input_1.p && !(input_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(input_1.p);
}
	goto BeforeRet_;
	{
		LA1_:;
	}
	{
		if (compressed_1.p && !(compressed_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(compressed_1.p);
}
		if (input_1.p && !(input_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(input_1.p);
}
	}
	if (NIM_UNLIKELY(*nimErr_)) goto BeforeRet_;
	}BeforeRet_: ;
	return result;
}
N_LIB_EXPORT N_CDECL(NCSTRING, decompress_string)(NCSTRING data_p0) {
	NCSTRING result;
	NimStringV2 input_1;
	NimStringV2 decompressed_1;
NIM_BOOL* nimErr_;
{nimErr_ = nimErrorFlag();
	result = (NCSTRING)0;
	input_1.len = 0; input_1.p = NIM_NIL;
	decompressed_1.len = 0; decompressed_1.p = NIM_NIL;
	input_1 = cstrToNimstr(data_p0);
	decompressed_1 = decompressData(input_1);
	if (NIM_UNLIKELY(*nimErr_)) goto LA1_;
	result = nimToCStringConv(decompressed_1);
	if (decompressed_1.p && !(decompressed_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(decompressed_1.p);
}
	if (input_1.p && !(input_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(input_1.p);
}
	goto BeforeRet_;
	{
		LA1_:;
	}
	{
		if (decompressed_1.p && !(decompressed_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(decompressed_1.p);
}
		if (input_1.p && !(input_1.p->cap & NIM_STRLIT_FLAG)) {
 deallocShared(input_1.p);
}
	}
	if (NIM_UNLIKELY(*nimErr_)) goto BeforeRet_;
	}BeforeRet_: ;
	return result;
}
N_LIB_EXPORT N_CDECL(void, NimDestroyGlobals)(void) {
}

N_LIB_PRIVATE void PreMainInner(void) {
}

N_LIB_PRIVATE int cmdCount;
N_LIB_PRIVATE char** cmdLine;
N_LIB_PRIVATE char** gEnv;
N_LIB_PRIVATE void PreMain(void) {
#if 0
	void (*volatile inner)(void);
	inner = PreMainInner;
	atpsystemdotnim_Init000();
	(*inner)();
#else
	atpsystemdotnim_Init000();
	PreMainInner();
#endif
}

N_LIB_PRIVATE N_CDECL(void, NimMainInner)(void) {
	NimMainModule();
}

N_LIB_EXPORT N_CDECL(void, NimMain)(void) {
#if 0
	void (*volatile inner)(void);
	PreMain();
	inner = NimMainInner;
	(*inner)();
#else
	PreMain();
	NimMainInner();
#endif
}

N_LIB_PRIVATE void NIM_POSIX_INIT NimMainInit(void) {
	NimMain();
}

N_LIB_PRIVATE N_NIMCALL(void, NimMainModule)(void) {
{
}
}

