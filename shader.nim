# Generated by tStorie Nim Export (Standalone)
# Source: untitled.md

import times, os
import std/[strutils, tables]  # For join and getOrDefault
import src/types
import src/layers
import src/appstate
import src/input  # Input parsing and polling
import src/simple_event  # Simplified event API
when not defined(emscripten):
  import src/platform/terminal

# tStorie library imports
import lib/canvas
import lib/storie_themes

# Global state
var gState: AppState
var gDefaultLayer: Layer  # Single default layer (layer 0)
var gRunning {.global.} = true
var gInputParser: TerminalInputParser  # For input event parsing
when not defined(emscripten):
  var gTerminalState: TerminalState

# Style helper function
proc getStyle(name: string): Style =
  if gState.styleSheet.hasKey(name):
    let sc = gState.styleSheet[name]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  elif gState.styleSheet.hasKey("default"):
    # Use theme's default style as fallback
    let sc = gState.styleSheet["default"]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  else:
    result = defaultStyle()

# Unified Drawing API - works with any layer
proc draw(layer: string, x, y: int, text: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc draw(layerId: int, x, y: int, text: string, style: Style = getStyle("default")) =
  # Integer layer ID overload (0 = default layer)
  let targetLayer = if layerId == 0: gDefaultLayer
                    elif layerId < gState.layers.len: gState.layers[layerId]
                    else: nil
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc clear(layer: string = "", transparent: bool = false) =
  # Clear specific layer, or all layers if no layer specified
  if layer == "":
    for l in gState.layers:
      if transparent: l.buffer.clearTransparent()
      else: l.buffer.clear(gState.themeBackground)
  else:
    let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
    if targetLayer.isNil: return
    if transparent: targetLayer.buffer.clearTransparent() else: targetLayer.buffer.clear(gState.themeBackground)

proc fillRect(layer: string, x, y, w, h: int, ch: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.fillRect(x, y, w, h, ch, style)

# Runtime helper functions
proc print(args: varargs[string, `$`]) = echo args.join(" ")
template termWidth: int = gState.termWidth
template termHeight: int = gState.termHeight
proc str(x: int): string = $x
proc str(x: float): string = $x
proc str(x: bool): string = $x
proc str(x: string): string = x

# User global variables
var effectName1: string
var effectName3: string
var effectName5: string
var currentEffect: int
var renderHeight
var effectName4: string
var effectName0: string
var reduction: int
var effectName2: string
var numEffects: int
var effectName6: string

proc main() =
  when not defined(emscripten):
    gTerminalState = setupRawMode()
    hideCursor()
    enableMouseReporting()
    enableKeyboardProtocol()
    
    # Setup signal handlers for graceful shutdown on CTRL-C
    setupSignalHandlers(proc(sig: cint) {.noconv.} = gRunning = false)
    
    let (w, h) = getTermSize()
    gState = newAppState(w, h)
    
    # Initialize default layer (layer 0)
    gDefaultLayer = addLayer(gState, "default", 0)
    
    # Load theme and stylesheet
    let theme = getTheme("catppuccin")
    gState.styleSheet = applyTheme(theme, "catppuccin")
    gState.themeBackground = theme.bgPrimary
    
    # Initialization
    # Initialize shader system
    currentEffect = 0
    numEffects = 7
    
    # Shader names
    effectName0 = "Plasma - Sine wave interference"
    effectName1 = "Ripple - Concentric waves"
    effectName2 = "Fire - Rising flames"
    effectName3 = "Fractal Noise - Multi-octave"
    effectName4 = "Wave Pattern - Horizontal flow"
    effectName5 = "Tunnel - Perspective distortion"
    effectName6 = "Matrix Rain - Digital cascade"
    
    # Initialize shader (effectId, layerId, x, y, width, height, reduction)
    # reduction: 1=full res, 2=half res (2x faster), 4=quarter res (4x faster)
    # Max useful reduction: ~8 (beyond that, too few pixels render)
    renderHeight = termHeight - 4
    reduction = 8  # Default to half resolution for better performance
    initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
    
    print "Terminal shaders initialized with native rendering"
    DENSITY_ASCII   = [" ", ".", ":", "-", "=", "+", "*", "#", "%", "@"]
    DENSITY_SMOOTH  = [" ", "░", "▒", "▓", "█"]
    DENSITY_BLOCKS  = [" ", "▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"]
    DENSITY_BRAILLE = [" ", "⡀", "⡄", "⡆", "⡇", "⣇", "⣧", "⣷", "⣿"]

    var lastTime = epochTime()
    
    try:
      # Main loop
      while gState.running and gRunning:
        let currentTime = epochTime()
        let deltaTime = currentTime - lastTime
        lastTime = currentTime
        
        # Update FPS counter
        gState.updateFpsCounter(deltaTime)
        
        # Poll for input events
        let events = pollInput(gInputParser)
        for nativeEvent in events:
          # Convert to simplified event API
          let event = toSimpleEvent(nativeEvent)
          # Process input event
          if event.type == "text":
            var key = event.text
            if key == "n" or key == "N":
              # Next effect
              currentEffect = (currentEffect + 1) mod numEffects
              renderHeight = termHeight - 4
              initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
            elif key == "p" or key == "P":
              # Previous effect
              currentEffect = (currentEffect - 1 + numEffects) mod numEffects
              renderHeight = termHeight - 4
              initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
            elif key == "+" or key == "=":
              # Increase resolution (decrease reduction)
              if reduction > 1:
                reduction = reduction div 2
                renderHeight = termHeight - 4
                initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
                print "Resolution: " & $(termWidth div reduction) & "x" & $(renderHeight div reduction)
            elif key == "-" or key == "_":
              # Decrease resolution (increase reduction)
              if reduction < 8:
                reduction = reduction * 2
                renderHeight = termHeight - 4
                initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
                print "Resolution: " & $(termWidth div reduction) & "x" & $(renderHeight div reduction)
            elif key == "s" or key == "S":
              # Toggle pause (changed from P to S to avoid conflict with Previous)
              pauseShader()
              print "Animation paused"
            elif key == "r" or key == "R":
              # Reset animation
              resetShader()
              print "Animation reset"
          
          elif event.type == "mouse":
            if event.action == "press":
              var mouseX = event.x
              var leftThird = termWidth / 3
              var rightThird = (termWidth * 2) / 3
              
              if mouseX < leftThird:
                # Click on left side - previous effect
                currentEffect = (currentEffect - 1 + numEffects) mod numEffects
                renderHeight = termHeight - 4
                initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
              elif mouseX > rightThird:
                # Click on right side - next effect
                currentEffect = (currentEffect + 1) mod numEffects
                renderHeight = termHeight - 4
                initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)

        # Update
        # Update shader animation every frame
        updateShader()

        # Render
        # Draw the current shader effect
        drawShader(0)
        
        # Get effect name based on index
        var effectName = "Unknown"
        if currentEffect == 0:
          effectName = effectName0
        elif currentEffect == 1:
          effectName = effectName1
        elif currentEffect == 2:
          effectName = effectName2
        elif currentEffect == 3:
          effectName = effectName3
        elif currentEffect == 4:
          effectName = effectName4
        elif currentEffect == 5:
          effectName = effectName5
        elif currentEffect == 6:
          effectName = effectName6
        
        # Draw UI footer
        var footerY = termHeight - 2
        var headerStyle = getStyle("heading")
        var bodyStyle = getStyle("body")
        var linkStyle = getStyle("link")
        
        # Clear footer area
        fillRect(0, 0, footerY, termWidth, 2, " ", bodyStyle)
        
        # Effect name
        draw(0, 2, footerY, effectName, headerStyle)
        
        # Controls
        var controls = "  [P] Prev  [N] Next  [+/-] Res  [S] Pause  [R] Reset  [Q] Quit  (Click left/right to navigate)"
        draw(0, 2, footerY + 1, controls, linkStyle)
        
        # Progress indicator
        var resText = "Res: 1/" & $(reduction)
        var progressText = "Effect " & $(currentEffect + 1) & "/" & $(numEffects) & "  " & resText
        draw(0, termWidth - len(progressText) - 2, footerY + 1, progressText, bodyStyle)

        # Composite layers and display to terminal
        gState.compositeLayers()
        gState.currentBuffer.display(gState.previousBuffer, gState.colorSupport)

        # Frame rate limiting
        if gState.targetFps > 0.0:
          let frameTime = epochTime() - currentTime
          let targetFrameTime = 1.0 / gState.targetFps
          let sleepTime = targetFrameTime - frameTime
          if sleepTime > 0:
            sleep(int(sleepTime * 1000))
    finally:
      # Cleanup terminal
      disableKeyboardProtocol()
      disableMouseReporting()
      showCursor()
      clearScreen()
      restoreTerminal(gTerminalState)
      stdout.write("\n")
      stdout.flushFile()

when isMainModule:
  main()
