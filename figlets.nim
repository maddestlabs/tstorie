# Generated by tStorie Nim Export (Standalone)
# Source: untitled.md

import times, os
import std/[strutils, tables]  # For join and getOrDefault
import src/types
import src/layers
import src/appstate
import src/input  # Input parsing and polling
import src/simple_event  # Simplified event API
when not defined(emscripten):
  import src/platform/terminal

# tStorie library imports
import lib/figlet
import lib/storie_themes

# ============================================================================
# Embedded Content from Markdown
# ============================================================================
# This section contains data blocks embedded in the source markdown file.
# Content is stored as compile-time strings for zero-overhead access.

var gEmbeddedContent {.global.} = initTable[string, string]()

proc initEmbeddedContent() =
  ## Initialize embedded content at startup
  ## This loads all embedded data blocks (figlet fonts, data files, etc.)
  
  # Embedded content: standard (FIGlet font)
  gEmbeddedContent["standard"] = """
flf2a$ 6 4 6 -1 4
3x5 font by Richard Kirk (rak@crosfield.co.uk).
Ported to figlet, and slightly changed (without permission :-})
by Daniel Cabeza Gras (bardo@dia.fi.upm.es)

    @
    @
    @
    @
    @
    @@
    @
 #  @
 #  @
 #  @
    @
 #  @@
    @
# # @
# # @
    @
    @
    @@
    @
# # @
### @
# # @
### @
# # @@
    @
 ## @
##  @
### @
 ## @
##  @@
    @
# # @
  # @
 #  @
#   @
# # @@
    @
 #  @
#   @
 ## @
# # @
### @@
    @
  # @
 #  @
#   @
    @
    @@
    @
  # @
 #  @
 #  @
 #  @
  # @@
    @
#   @
 #  @
 #  @
 #  @
#   @@
    @
 #  @
### @
 #  @
### @
 #  @@
    @
    @
 #  @
### @
 #  @
    @@
    @
    @
    @
    @
 #  @
#   @@
    @
    @
    @
### @
    @
    @@
    @
    @
    @
    @
    @
 #  @@
    @
  # @
  # @
 #  @
#   @
#   @@
    @
### @
# # @
# # @
# # @
### @@
    @
 #  @
##  @
 #  @
 #  @
### @@
    @
### @
  # @
### @
#   @
### @@
    @
### @
  # @
 ## @
  # @
### @@
    @
# # @
# # @
### @
  # @
  # @@
    @
### @
#   @
### @
  # @
### @@
    @
### @
#   @
### @
# # @
### @@
    @
### @
  # @
  # @
  # @
  # @@
    @
### @
# # @
### @
# # @
### @@
    @
### @
# # @
### @
  # @
### @@
    @
    @
 #  @
    @
 #  @
    @@
    @
    @
 #  @
    @
 #  @
#   @@
    @
  # @
 #  @
#   @
 #  @
  # @@
    @
    @
### @
    @
### @
    @@
    @
#   @
 #  @
  # @
 #  @
#   @@
    @
### @
  # @
 ## @
    @
 #  @@
    @
### @
# # @
#   @
### @
    @@
    @
 #  @
# # @
### @
# # @
# # @@
    @
##  @
# # @
##  @
# # @
##  @@
    @
 ## @
#   @
#   @
#   @
 ## @@
    @
##  @
# # @
# # @
# # @
##  @@
    @
### @
#   @
##  @
#   @
### @@
    @
### @
#   @
##  @
#   @
#   @@
    @
 ## @
#   @
# # @
# # @
 ## @@
    @
# # @
# # @
### @
# # @
# # @@
    @
### @
 #  @
 #  @
 #  @
### @@
    @
 ## @
  # @
  # @
# # @
 #  @@
    @
# # @
# # @
##  @
# # @
# # @@
    @
#   @
#   @
#   @
#   @
### @@
    @
# # @
### @
### @
# # @
# # @@
    @
### @
# # @
# # @
# # @
# # @@
    @
 #  @
# # @
# # @
# # @
 #  @@
    @
##  @
# # @
##  @
#   @
#   @@
    @
 #  @
# # @
# # @
 ## @
  # @@
    @
##  @
# # @
##  @
# # @
# # @@
    @
 ## @
#   @
 #  @
  # @
##  @@
    @
### @
 #  @
 #  @
 #  @
 #  @@
    @
# # @
# # @
# # @
# # @
### @@
    @
# # @
# # @
# # @
# # @
 #  @@
    @
# # @
# # @
### @
### @
# # @@
    @
# # @
# # @
 #  @
# # @
# # @@
    @
# # @
# # @
 #  @
 #  @
 #  @@
    @
### @
  # @
 #  @
#   @
### @@
    @
 ## @
 #  @
 #  @
 #  @
 ## @@
    @
#   @
#   @
 #  @
  # @
  # @@
    @
##  @
 #  @
 #  @
 #  @
##  @@
    @
 #  @
# # @
    @
    @
    @@
    @
    @
    @
    @
    @
### @@
    @
#   @
 #  @
  # @
    @
    @@
    @
    @
 ## @
# # @
### @
    @@
    @
#   @
### @
# # @
### @
    @@
    @
    @
### @
#   @
### @
    @@
    @
  # @
### @
# # @
### @
    @@
    @
    @
### @
##  @
### @
    @@
    @
 ## @
 #  @
### @
 #  @
##  @@
    @
    @
### @
# # @
 ## @
### @@
    @
#   @
### @
# # @
# # @
    @@
    @
 #  @
    @
 #  @
 ## @
    @@
    @
 #  @
    @
 #  @
 #  @
#   @@
    @
#   @
# # @
##  @
# # @
    @@
    @
 #  @
 #  @
 #  @
 ## @
    @@
    @
    @
### @
### @
# # @
    @@
    @
    @
##  @
# # @
# # @
    @@
    @
    @
### @
# # @
### @
    @@
    @
    @
### @
# # @
### @
#   @@
    @
    @
### @
# # @
### @
  # @@
    @
    @
### @
#   @
#   @
    @@
    @
    @
 ## @
 #  @
##  @
    @@
    @
 #  @
### @
 #  @
 ## @
    @@
    @
    @
# # @
# # @
### @
    @@
    @
    @
# # @
# # @
 #  @
    @@
    @
    @
# # @
### @
### @
    @@
    @
    @
# # @
 #  @
# # @
    @@
    @
    @
# # @
### @
  # @
### @@
    @
    @
##  @
 #  @
 ## @
    @@
    @
 ## @
 #  @
##  @
 #  @
 ## @@
    @
 #  @
 #  @
 #  @
 #  @
 #  @@
    @
##  @
 #  @
 ## @
 #  @
##  @@
    @
  # @
### @
#   @
    @
    @@
    @
# # @
 #  @
# # @
### @
# # @@
    @
# # @
### @
# # @
# # @
### @@
    @
# # @
    @
# # @
# # @
### @@
    @
# # @
 ## @
# # @
### @
    @@
    @
# # @
### @
# # @
### @
    @@
    @
# # @
    @
# # @
### @
    @@
    @
### @
##  @
# # @
##  @
#   @@
"""

# Helper functions to access embedded content
proc getEmbeddedContent*(name: string): string =
  ## Get embedded content by name
  ## Returns empty string if content doesn't exist
  gEmbeddedContent.getOrDefault(name, "")

proc hasEmbeddedContent*(name: string): bool =
  ## Check if embedded content exists
  gEmbeddedContent.hasKey(name)

# Specific helpers for figlet fonts
proc getEmbeddedFont*(name: string): string =
  ## Get embedded FIGlet font by name
  ## This is an alias for getEmbeddedContent for clarity
  getEmbeddedContent(name)

# Global state
var gState: AppState
var gDefaultLayer: Layer  # Single default layer (layer 0)
var gRunning {.global.} = true
var gInputParser: TerminalInputParser  # For input event parsing
when not defined(emscripten):
  var gTerminalState: TerminalState

# Unified Drawing API - works with any layer
proc draw(layer: string, x, y: int, text: string, style: Style = defaultStyle()) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc draw(layerId: int, x, y: int, text: string, style: Style = defaultStyle()) =
  # Integer layer ID overload (0 = default layer)
  let targetLayer = if layerId == 0: gDefaultLayer
                    elif layerId < gState.layers.len: gState.layers[layerId]
                    else: nil
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc clear(layer: string = "", transparent: bool = false) =
  # Clear specific layer, or all layers if no layer specified
  if layer == "":
    for l in gState.layers:
      if transparent: l.buffer.clearTransparent()
      else: l.buffer.clear(gState.themeBackground)
  else:
    let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
    if targetLayer.isNil: return
    if transparent: targetLayer.buffer.clearTransparent() else: targetLayer.buffer.clear(gState.themeBackground)

proc fillRect(layer: string, x, y, w, h: int, ch: string, style: Style = defaultStyle()) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.fillRect(x, y, w, h, ch, style)

# Runtime helper functions
proc print(args: varargs[string, `$`]) = echo args.join(" ")
template termWidth: int = gState.termWidth
template termHeight: int = gState.termHeight
proc str(x: int): string = $x
proc str(x: float): string = $x
proc str(x: bool): string = $x
proc str(x: string): string = x
proc getStyle(name: string): Style =
  if gState.styleSheet.hasKey(name):
    let sc = gState.styleSheet[name]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  elif gState.styleSheet.hasKey("default"):
    # Use theme's default style as fallback
    let sc = gState.styleSheet["default"]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  else:
    result = defaultStyle()

proc main() =
  when not defined(emscripten):
    gTerminalState = setupRawMode()
    hideCursor()
    enableMouseReporting()
    enableKeyboardProtocol()
    
    let (w, h) = getTermSize()
    gState = newAppState(w, h)
    
    # Initialize default layer (layer 0)
    gDefaultLayer = addLayer(gState, "default", 0)
    
    # Initialize embedded content (fonts, data, etc.)
    initEmbeddedContent()
    
    # Load theme and stylesheet
    let theme = getTheme("futurism")
    gState.styleSheet = applyTheme(theme)
    gState.themeBackground = theme.bgPrimary
    
    # Initialization
    var fontLoaded = loadFont("standard")

    var lastTime = epochTime()
    
    try:
      # Main loop
      while gState.running and gRunning:
        let currentTime = epochTime()
        let deltaTime = currentTime - lastTime
        lastTime = currentTime
        
        # Update FPS counter
        gState.updateFpsCounter(deltaTime)
        
        # Render
        clear()
        
        # Manual way - loop through lines
        draw(0, 2, 2, "Manual way:")
        var lines = figletRender("standard", "HELLO")
        var y = 3
        for line in lines:
          draw(0, 2, y, line)
          y = y + 1
        
        # With style
        var warning = getStyle("warning")
        draw(0, 2, 10, "With style:")
        drawFigletText(0, 2, 11, "standard", "STYLED", 0, warning)
        
        # Horizontal with letter spacing
        draw(0, 2, 18, "Letter spacing (3):")
        drawFigletText(0, 2, 19, "standard", "SPACE", 0, 0, 0, 3)
        
        # Vertical text
        draw(0, 45, 2, "Vertical:")
        drawFigletText(0, 45, 3, "standard", "HEY", 0, 0, 1, 0)

        # Composite layers and display to terminal
        gState.compositeLayers()
        gState.currentBuffer.display(gState.previousBuffer, gState.colorSupport)

        # Frame rate limiting
        if gState.targetFps > 0.0:
          let frameTime = epochTime() - currentTime
          let targetFrameTime = 1.0 / gState.targetFps
          let sleepTime = targetFrameTime - frameTime
          if sleepTime > 0:
            sleep(int(sleepTime * 1000))
    finally:
      # Cleanup terminal
      disableKeyboardProtocol()
      disableMouseReporting()
      showCursor()
      clearScreen()
      restoreTerminal(gTerminalState)
      stdout.write("\n")
      stdout.flushFile()

when isMainModule:
  main()
