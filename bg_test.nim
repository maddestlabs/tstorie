# Generated by tStorie Nim Export (Standalone)
# Source: untitled.md

import times, os
import std/[strutils, tables]  # For join and getOrDefault
import src/types
import src/layers
import src/appstate
when not defined(emscripten):
  import src/platform/terminal

# tStorie library imports
import lib/storie_themes

# Global state
var gState: AppState
var gBgLayer, gFgLayer: Layer  # Layer references for drawing API
var gRunning {.global.} = true
when not defined(emscripten):
  var gTerminalState: TerminalState

# Drawing API - convenience wrappers using layer references
proc bgClear() = gBgLayer.buffer.clear()
proc bgClearTransparent() = gBgLayer.buffer.clearTransparent()
proc bgWrite(x, y: int, ch: string, style: Style) = gBgLayer.buffer.write(x, y, ch, style)
proc bgWriteText(x, y: int, text: string, style: Style) = gBgLayer.buffer.writeText(x, y, text, style)
proc bgFillRect(x, y, w, h: int, ch: string, style: Style) = gBgLayer.buffer.fillRect(x, y, w, h, ch, style)
proc fgClear() = gFgLayer.buffer.clear()
proc fgClearTransparent() = gFgLayer.buffer.clearTransparent()
proc fgWrite(x, y: int, ch: string, style: Style) = gFgLayer.buffer.write(x, y, ch, style)
proc fgWriteText(x, y: int, text: string, style: Style) = gFgLayer.buffer.writeText(x, y, text, style)
proc fgFillRect(x, y, w, h: int, ch: string, style: Style) = gFgLayer.buffer.fillRect(x, y, w, h, ch, style)

# Runtime helper functions
proc print(args: varargs[string, `$`]) = echo args.join(" ")
template termWidth: int = gState.termWidth
template termHeight: int = gState.termHeight
proc getStyle(name: string): Style =
  if gState.styleSheet.hasKey(name):
    let sc = gState.styleSheet[name]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  else:
    result = defaultStyle()

proc main() =
  when not defined(emscripten):
    gTerminalState = setupRawMode()
    hideCursor()
    
    let (w, h) = getTermSize()
    gState = newAppState(w, h)
    
    # Initialize standard layers
    gBgLayer = newLayer("background", w, h, 0)
    gFgLayer = newLayer("foreground", w, h, 1)
    gState.layers.add(gBgLayer)
    gState.layers.add(gFgLayer)
    
    # Load theme and stylesheet
    let theme = getTheme("catppuccin")
    gState.styleSheet = applyTheme(theme)
    gState.themeBackground = theme.bgPrimary
    
    # Initialization
    print "Testing background colors with theme"

    var lastTime = epochTime()
    
    try:
      # Main loop
      while gState.running and gRunning:
        let currentTime = epochTime()
        let deltaTime = currentTime - lastTime
        lastTime = currentTime
        
        # Update FPS counter
        gState.updateFpsCounter(deltaTime)
        
        # Render
        # First clear to theme background
        bgClear()
        
        # Fill entire screen with spaces using theme background
        # This should show the Catppuccin purple background
        var w = termWidth
        var h = termHeight
        
        # Get styles from stylesheet
        var bodyStyle = getStyle("body")
        var headingStyle = getStyle("heading")
        var linkStyle = getStyle("link")
        var placeholderStyle = getStyle("placeholder")
        
        # Fill with solid color blocks to test background rendering
        bgFillRect(0, 0, w, 5, "█", bodyStyle)
        bgFillRect(0, 5, w, 5, "▓", headingStyle)
        bgFillRect(0, 10, w, 5, "▒", linkStyle)
        bgFillRect(0, 15, w div 2, 5, "░", placeholderStyle)
        
        # Write some text on the foreground
        fgWrite(2, 2, "Body style (should have purple bg)", bodyStyle)
        fgWrite(2, 7, "Heading style (should have purple bg)", headingStyle)
        fgWrite(2, 12, "Link style (should have purple bg)", linkStyle)
        fgWrite(2, 17, "Placeholder style (should have purple bg)", placeholderStyle)
        
        # Bottom test area - plain text
        fgWrite(2, 22, "Check console output for background RGB values", bodyStyle)

        # Composite layers and display to terminal
        gState.compositeLayers()
        gState.currentBuffer.display(gState.previousBuffer, gState.colorSupport)

        # Frame rate limiting
        if gState.targetFps > 0.0:
          let frameTime = epochTime() - currentTime
          let targetFrameTime = 1.0 / gState.targetFps
          let sleepTime = targetFrameTime - frameTime
          if sleepTime > 0:
            sleep(int(sleepTime * 1000))
    finally:
      # Cleanup terminal
      showCursor()
      clearScreen()
      restoreTerminal(gTerminalState)
      stdout.write("\n")
      stdout.flushFile()

when isMainModule:
  main()
