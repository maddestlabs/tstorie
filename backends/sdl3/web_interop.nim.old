## SDL3 Web Interop - Minimal JS bridge for web-specific features
## 
## This module provides ONLY the web-specific functionality that SDL3 doesn't handle:
## - URL parameter parsing
## - Gist content loading
## - localStorage access (if needed)
##
## Everything else (rendering, input, events) is handled by SDL3 directly.

when defined(emscripten):
  # JavaScript interop using EM_ASM
  
  proc getUrlParam*(key: cstring): cstring {.importc: "tstorie_getUrlParam", header: "<emscripten.h>".}
  proc fetchGistContent*(gistId: cstring, callback: proc(content: cstring) {.cdecl.}) {.importc: "tstorie_fetchGist", header: "<emscripten.h>".}
  
  # URL parameter parsing
  proc parseUrlParams*(): seq[(string, string)] =
    ## Parse URL parameters from the browser location
    ## Returns a sequence of (key, value) tuples
    result = @[]
    
    {.emit: """
    // Get URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    for (const [key, value] of urlParams) {
      // Store in Nim sequence - we'll do this from Nim side
    }
    """.}
    
    # Use a simpler approach: get all params via individual calls
    # JavaScript will define a global with param names
    {.emit: """
    window._tstorie_params = [];
    const urlParams = new URLSearchParams(window.location.search);
    for (const [key, value] of urlParams) {
      window._tstorie_params.push({key: key, value: value});
    }
    """.}
  
  proc getUrlParamCount*(): int =
    ## Get number of URL parameters
    {.emit: """
    `result` = window._tstorie_params ? window._tstorie_params.length : 0;
    """.}
  
  proc getUrlParamAt*(index: int): (string, string) =
    ## Get URL parameter at index
    var key: cstring
    var value: cstring
    {.emit: """
    if (window._tstorie_params && `index` < window._tstorie_params.length) {
      const param = window._tstorie_params[`index`];
      `key` = allocateUTF8(param.key);
      `value` = allocateUTF8(param.value);
    } else {
      `key` = allocateUTF8("");
      `value` = allocateUTF8("");
    }
    """.}
    result = ($key, $value)
  
  # Gist loading via fetch API
  proc loadGistContent*(gistId: string): string =
    ## Load gist content from GitHub (synchronous for simplicity)
    ## In production, this should be async, but for initial implementation
    ## we can use a synchronous XMLHttpRequest
    result = ""
    
    var contentPtr: cstring
    {.emit: """
    const gistId = UTF8ToString(`gistId`);
    const apiUrl = `https://api.github.com/gists/${gistId}`;
    
    // Synchronous fetch (not ideal but simplest for now)
    try {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', apiUrl, false); // synchronous
      xhr.send();
      
      if (xhr.status === 200) {
        const data = JSON.parse(xhr.responseText);
        const files = data.files;
        
        // Get first .md file
        for (const [filename, fileData] of Object.entries(files)) {
          if (filename.endsWith('.md')) {
            `contentPtr` = allocateUTF8(fileData.content);
            break;
          }
        }
      }
    } catch (e) {
      console.error('[tStorie] Failed to load gist:', e);
      `contentPtr` = allocateUTF8("");
    }
    """.}
    
    if not contentPtr.isNil:
      result = $contentPtr
  
  # Console logging (useful for debugging)
  proc consoleLog*(msg: string) =
    {.emit: """
    console.log('[tStorie]', UTF8ToString(`msg`));
    """.}
  
  proc consoleWarn*(msg: string) =
    {.emit: """
    console.warn('[tStorie]', UTF8ToString(`msg`));
    """.}
  
  proc consoleError*(msg: string) =
    {.emit: """
    console.error('[tStorie]', UTF8ToString(`msg`));
    """.}

else:
  # Stubs for non-web builds
  proc parseUrlParams*(): seq[(string, string)] = @[]
  proc getUrlParamCount*(): int = 0
  proc getUrlParamAt*(index: int): (string, string) = ("", "")
  proc loadGistContent*(gistId: string): string = ""
  proc consoleLog*(msg: string) = discard
  proc consoleWarn*(msg: string) = discard
  proc consoleError*(msg: string) = discard
