# Generated by tStorie Nim Export (Standalone)
# Source: untitled.md

import times, os
import std/[strutils, tables]  # For join and getOrDefault
import src/types
import src/layers
import src/appstate
import src/input  # Input parsing and polling
import src/simple_event  # Simplified event API
when not defined(emscripten):
  import src/platform/terminal

# tStorie library imports
import lib/canvas
import lib/particles
import lib/section_manager
import lib/storie_themes

# Global state
var gState: AppState
var gDefaultLayer: Layer  # Single default layer (layer 0)
var gRunning {.global.} = true
var gInputParser: TerminalInputParser  # For input event parsing
when not defined(emscripten):
  var gTerminalState: TerminalState

# Particle system state
import lib/particles
import lib/particles_bindings
var gParticleSystems = initTable[string, ParticleSystem]()

# Style helper function
proc getStyle(name: string): Style =
  if gState.styleSheet.hasKey(name):
    let sc = gState.styleSheet[name]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  elif gState.styleSheet.hasKey("default"):
    # Use theme's default style as fallback
    let sc = gState.styleSheet["default"]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  else:
    result = defaultStyle()

# Style brightness adjustment
proc brightness(style: Style, factor: float): Style =
  ## Adjusts the brightness of a style's foreground color
  ## factor < 1.0 = darker, factor > 1.0 = brighter
  result = style
  result.fg.r = uint8(clamp(float(style.fg.r) * factor, 0.0, 255.0))
  result.fg.g = uint8(clamp(float(style.fg.g) * factor, 0.0, 255.0))
  result.fg.b = uint8(clamp(float(style.fg.b) * factor, 0.0, 255.0))

# Unified Drawing API - works with any layer
proc draw(layer: string, x, y: int, text: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc draw(layerId: int, x, y: int, text: string, style: Style = getStyle("default")) =
  # Integer layer ID overload (0 = default layer)
  let targetLayer = if layerId == 0: gDefaultLayer
                    elif layerId < gState.layers.len: gState.layers[layerId]
                    else: nil
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc clear(layer: string = "", transparent: bool = false) =
  # Clear specific layer, or all layers if no layer specified
  if layer == "":
    for l in gState.layers:
      if transparent: l.buffer.clearTransparent()
      else: l.buffer.clear(gState.themeBackground)
  else:
    let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
    if targetLayer.isNil: return
    if transparent: targetLayer.buffer.clearTransparent() else: targetLayer.buffer.clear(gState.themeBackground)

proc fillRect(layer: string, x, y, w, h: int, ch: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.fillRect(x, y, w, h, ch, style)

# Runtime helper functions
proc print(args: varargs[string, `$`]) = echo args.join(" ")
template termWidth: int = gState.termWidth
template termHeight: int = gState.termHeight
proc getMouseX(): int = gState.lastMouseX
proc getMouseY(): int = gState.lastMouseY
proc str(x: int): string = $x
proc str(x: float): string = $x
proc str(x: bool): string = $x
proc str(x: string): string = x

# User global variables
var hasEssence: bool
var visitedLibrary: bool
var hasKey: bool
var hasAmulet: bool
var bugTimer: float
var hasTorch: bool
var torchQuality: string
var bugSpawnInterval: float
var hasWeapon: bool

proc main() =
  when not defined(emscripten):
    gTerminalState = setupRawMode()
    hideCursor()
    enableMouseReporting()
    enableKeyboardProtocol()
    
    # Setup signal handlers for graceful shutdown on CTRL-C
    setupSignalHandlers(proc(sig: cint) {.noconv.} = gRunning = false)
    
    let (w, h) = getTermSize()
    gState = newAppState(w, h)
    
    # Initialize default layer (layer 0)
    gDefaultLayer = addLayer(gState, "default", 0)
    
    # Load theme and stylesheet
    let theme = getTheme("coffee")
    gState.styleSheet = applyTheme(theme, "coffee")
    gState.themeBackground = theme.bgPrimary
    
    # Initialization
    # Canvas-based Interactive Fiction using Nimini
    # The Depths of Khel-Daran - A dungeon adventure
    
    # Track player state with simple variables
    hasTorch = false
    hasKey = false
    hasAmulet = false
    hasEssence = false
    hasWeapon = false
    visitedLibrary = false
    torchQuality = "dim"
    
    # Bug effect tracking
    bugTimer = 0.0
    bugSpawnInterval = 3.0  # Spawn bugs every 3 seconds
    
    # Initialize canvas system with all sections
    # Start at section 1 (entrance - section 0 is the code blocks)
    initCanvas(1)
    
    # Initialize bug particle system
    var bgStyle = getStyle("default")
    var bgR = int(bgStyle.bg.r)
    var bgG = int(bgStyle.bg.g)
    var bgB = int(bgStyle.bg.b)
    var fgR = int(bgStyle.fg.r)
    var fgG = int(bgStyle.fg.g)
    var fgB = int(bgStyle.fg.b)
    
    particleInit("bugs", 50)
    particleSetBackgroundColor("bugs", bgR, bgG, bgB)
    
    # Configure base bug settings
    particleSetEmitRate("bugs", 0.0)  # Manual emission only
    particleSetChars("bugs", "o0@●")  # Bug head characters
    particleSetColorRange("bugs", fgR, fgG, fgB, fgR, fgG, fgB)  # Use theme foreground color
    
    # Enable trails for segmented body
    particleSetTrailEnabled("bugs", true)
    particleSetTrailLength("bugs", 4)  # 4-segment body
    particleSetTrailSpacing("bugs", 0.8)  # Tight spacing
    particleSetTrailFade("bugs", false)  # Solid body segments
    particleSetTrailChars("bugs", "/\\.-|*")  # Random body segment chars
    
    # Short lifetime - bugs disappear after crossing
    particleSetLifeRange("bugs", 3.0, 5.0)
    
    # Light turbulence for slight wobble
    particleSetTurbulence("bugs", 3.0)
    particleSetDamping("bugs", 0.98)
    
    # Initialize bug splat particle system
    particleInit("splat", 50)  # More particles for bigger splats
    particleSetBackgroundColor("splat", bgR, bgG, bgB)
    particleSetEmitRate("splat", 0.0)  # Manual only
    particleSetChars("splat", "X*+#.:,`")  # Splat characters with debris
    particleSetColorRange("splat", fgR, fgG, fgB, fgR, fgG, fgB)  # Same color as bugs
    particleSetLifeRange("splat", 1.5, 2.5)  # Fade after 1.5-2.5 seconds
    particleSetFadeOut("splat", true)  # Fade to nothing
    particleSetVelocityRange("splat", -15.0, -15.0, 15.0, 15.0)  # Wider spread for debris
    particleSetGravity("splat", 0.0)
    particleSetDamping("splat", 0.75)  # Slow down quickly

    var lastTime = epochTime()
    
    try:
      # Main loop
      while gState.running and gRunning:
        let currentTime = epochTime()
        let deltaTime = currentTime - lastTime
        lastTime = currentTime
        
        # Update FPS counter
        gState.updateFpsCounter(deltaTime)
        
        # Poll for input events
        let events = pollInput(gInputParser)
        for nativeEvent in events:
          # Convert to simplified event API
          let event = toSimpleEvent(nativeEvent)
          # Process input event
          # Handle keyboard and mouse input for canvas navigation
          
          if event.type == "key":
            if event.action == "press":
              # Pass key events to canvas system
              var handled = canvasHandleKey(event.keyCode, 0)
              if handled:
          
          elif event.type == "mouse":
            if event.action == "press":
              # Check if we clicked on a bug!
              var hitBug = particleCheckHit("bugs", event.x, event.y, 2.0)
              if hitBug:
                # Spawn splat particles at click location
                particleSetEmitterPos("splat", float(event.x), float(event.y))
                particleEmit("splat", rand(10) + 12)  # 12-21 particles for bigger splat
            
            # Pass mouse release events to canvas system for link navigation
            if event.action == "release":
              var handled = canvasHandleMouse(event.x, event.y, event.button, false)
              if handled:

        # Check if mouse tracking should be re-enabled
        checkMouseTrackingReenabled(gInputParser)

        # Update
        canvasUpdate()
        
        # Update bug particles
        particleUpdate("bugs", deltaTime)
        
        # Update splat particles
        particleUpdate("splat", deltaTime)
        
        # Bug spawning timer
        bugTimer += deltaTime
        if bugTimer >= bugSpawnInterval:
          bugTimer = 0.0
          
          # Randomly select which edge to spawn from (0=top, 1=right, 2=bottom, 3=left)
          var edge = rand(4)
          
          # Spawn position and velocity depend on edge
          # Random arc direction for variety
          var arcDir = float(rand(2) * 2 - 1)  # -1 or 1 (arc up or down)
          var gravityStrength = 12.0 + float(rand(10))  # 12-21 for varied arc curves
          
          if edge == 0:
            # Spawn from TOP edge, move downward with random arc
            var spawnX = float(rand(termWidth - 4) + 2)
            particleSetEmitterPos("bugs", spawnX, 1.0)
            # Move down and either left or right
            var horizontalDir = float(rand(3) - 1) * 40.0  # -40, 0, or 40
            particleSetVelocityRange("bugs", horizontalDir - 15.0, 80.0, horizontalDir + 15.0, 80.0)
            particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
            
          elif edge == 1:
            # Spawn from RIGHT edge, move leftward with random arc
            var spawnY = float(rand(termHeight - 4) + 2)
            particleSetEmitterPos("bugs", float(termWidth - 2), spawnY)
            particleSetVelocityRange("bugs", -80.0, -15.0, -80.0, 15.0)
            particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
            
          elif edge == 2:
            # Spawn from BOTTOM edge, move upward with random arc
            var spawnX = float(rand(termWidth - 4) + 2)
            particleSetEmitterPos("bugs", spawnX, float(termHeight - 2))
            var horizontalDir = float(rand(3) - 1) * 40.0
            particleSetVelocityRange("bugs", horizontalDir - 15.0, -80.0, horizontalDir + 15.0, -80.0)
            particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
            
          else:
            # Spawn from LEFT edge, move rightward with random arc
            var spawnY = float(rand(termHeight - 4) + 2)
            particleSetEmitterPos("bugs", 1.0, spawnY)
            particleSetVelocityRange("bugs", 80.0, -15.0, 80.0, 15.0)
            particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
          
          # Emit 1 bug at a time for individual randomization
          particleEmit("bugs", 1)
          
          # Vary spawn interval for natural randomness
          bugSpawnInterval = 2.0 + (float(rand(100)) / 80.0) * 2.5  # 2.0-4.5 seconds

        # Render
        clear()
        canvasRender()
        
        # Render bugs behind text (layer 0 = behind canvas content)
        particleRender("bugs", 0)
        
        # Render splats on top of bugs but still behind text
        particleRender("splat", 0)
        
        # Top border with cracks
        var x = 0
        while x < termWidth:
          var char = "─"
          # Add random cracks and branches
          if x % 7 == 3:
            char = "╌"
          elif x % 11 == 5:
            char = "┬"
          elif x % 13 == 2:
            char = "╥"
          elif x % 17 == 8:
            char = "┴"
          draw(0, x, 0, char)
          x = x + 1
        
        # Bottom border with cracks
        x = 0
        while x < termWidth:
          var char = "─"
          # Different crack pattern on bottom
          if x % 8 == 2:
            char = "╌"
          elif x % 12 == 7:
            char = "┴"
          elif x % 15 == 4:
            char = "╨"
          elif x % 19 == 11:
            char = "┬"
          draw(0, x, termHeight - 1, char)
          x = x + 1
        
        # Left border with vertical cracks
        var y = 1
        while y < termHeight - 1:
          var char = "│"
          # Add cracks and branches
          if y % 6 == 2:
            char = "╎"
          elif y % 9 == 4:
            char = "├"
          elif y % 13 == 7:
            char = "╞"
          elif y % 16 == 10:
            char = "┤"
          draw(0, 0, y, char)
          y = y + 1
        
        # Right border with vertical cracks
        y = 1
        while y < termHeight - 1:
          var char = "│"
          # Different crack pattern on right
          if y % 7 == 3:
            char = "╎"
          elif y % 10 == 5:
            char = "┤"
          elif y % 14 == 8:
            char = "╡"
          elif y % 17 == 11:
            char = "├"
          draw(0, termWidth - 1, y, char)
          y = y + 1
        
        # Corner pieces - weathered and broken
        draw(0, 0, 0, "╔")
        draw(0, termWidth - 1, 0, "╗")
        draw(0, 0, termHeight - 1, "╚")
        draw(0, termWidth - 1, termHeight - 1, "╝")
        
        # Add some additional crack details
        # Top left area cracks
        if termWidth > 10:
          draw(0, 5, 0, "┯")
          draw(0, 5, 1, "╽")
          
        # Top right area cracks
        if termWidth > 10:
          draw(0, termWidth - 6, 0, "┯")
          draw(0, termWidth - 6, 1, "╽")
        
        # Bottom left area cracks
        if termHeight > 5:
          draw(0, 4, termHeight - 1, "┷")
          draw(0, 4, termHeight - 2, "╿")
        
        # Bottom right area cracks
        if termWidth > 10 and termHeight > 5:
          draw(0, termWidth - 7, termHeight - 1, "┷")
          draw(0, termWidth - 7, termHeight - 2, "╿")

        # Composite layers and display to terminal
        gState.compositeLayers()
        gState.currentBuffer.display(gState.previousBuffer, gState.colorSupport)

        # Frame rate limiting
        if gState.targetFps > 0.0:
          let frameTime = epochTime() - currentTime
          let targetFrameTime = 1.0 / gState.targetFps
          let sleepTime = targetFrameTime - frameTime
          if sleepTime > 0:
            sleep(int(sleepTime * 1000))
    finally:
      # Cleanup terminal
      disableKeyboardProtocol()
      disableMouseReporting()
      showCursor()
      clearScreen()
      restoreTerminal(gTerminalState)
      stdout.write("\n")
      stdout.flushFile()

when isMainModule:
  main()
