## WebGPU Noise Shader Generator
## Generates complete WGSL compute shaders from TStorie noise configurations

import ../lib/noise_composer
import std/[strformat, os]

proc generateCompleteShader(cfg: NoiseConfig, name: string): string =
  ## Generate a complete WebGPU compute shader with bindings
  result = fmt"""// Generated by TStorie Noise Composer
// Configuration: {name}

// Output buffer
@group(0) @binding(0) var<storage, read_write> output: array<u32>;

// Parameters uniform
@group(0) @binding(1) var<uniform> params: Params;

struct Params {{
  width: u32,
  height: u32,
  offsetX: i32,
  offsetY: i32,
}}

"""
  
  # Add the generated noise functions
  result.add(cfg.toWGSL())
  
  # Add the compute shader main function
  result.add(fmt"""

// Main compute shader
@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {{
  let x = i32(global_id.x);
  let y = i32(global_id.y);
  
  if (x >= i32(params.width) || y >= i32(params.height)) {{
    return;
  }}
  
  // Sample noise at pixel coordinate (with optional offset for animation)
  let noise = generatedNoise(x + params.offsetX, y + params.offsetY);
  
  // Store as 16-bit value (0..65535)
  let idx = u32(y) * params.width + u32(x);
  output[idx] = u32(noise);
}}
""")

proc main() =
  echo "TStorie WebGPU Noise Shader Generator"
  echo "======================================"
  echo ""
  
  # Create output directory
  let outDir = "docs/shaders/generated"
  createDir(outDir)
  
  # Example 1: Basic terrain
  echo "Generating terrain.wgsl..."
  let terrain = noise(ntPerlin2D).seed(42).scale(100)
  writeFile(outDir / "terrain.wgsl", generateCompleteShader(terrain, "Basic Terrain"))
  
  # Example 2: Detailed clouds
  echo "Generating clouds.wgsl..."
  let clouds = noise(ntSimplex2D).seed(123).scale(60).octaves(3)
  writeFile(outDir / "clouds.wgsl", generateCompleteShader(clouds, "Multi-Octave Clouds"))
  
  # Example 3: Mountain ridges
  echo "Generating mountains.wgsl..."
  let mountains = noise(ntPerlin2D).seed(999).scale(80).octaves(4).ridged()
  writeFile(outDir / "mountains.wgsl", generateCompleteShader(mountains, "Ridged Mountains"))
  
  # Example 4: Billowy clouds
  echo "Generating billow.wgsl..."
  let billow = noise(ntSimplex2D).seed(456).scale(50).octaves(3).billow()
  writeFile(outDir / "billow.wgsl", generateCompleteShader(billow, "Billow Clouds"))
  
  # Example 5: Turbulent fire
  echo "Generating turbulence.wgsl..."
  let turbulence = noise(ntPerlin2D).seed(777).scale(40).octaves(3).turbulent()
  writeFile(outDir / "turbulence.wgsl", generateCompleteShader(turbulence, "Turbulent Fire"))
  
  echo ""
  echo "âœ“ Generated 5 WebGPU compute shaders in", outDir
  echo ""
  echo "Usage in JavaScript:"
  echo "==================="
  echo """
  // Load shader
  const shaderCode = await fetch('shaders/generated/clouds.wgsl').then(r => r.text());
  
  // Create compute pipeline
  const computePipeline = device.createComputePipeline({
    layout: 'auto',
    compute: {
      module: device.createShaderModule({ code: shaderCode }),
      entryPoint: 'main'
    }
  });
  
  // Create output buffer (width * height * 4 bytes for u32)
  const outputBuffer = device.createBuffer({
    size: width * height * 4,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
  });
  
  // Create params buffer
  const paramsBuffer = device.createBuffer({
    size: 16, // 4 * u32
    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
  });
  
  // Update params (e.g., for animation)
  device.queue.writeBuffer(paramsBuffer, 0, new Uint32Array([
    width,
    height,
    offsetX,  // Animate this for scrolling effect
    offsetY
  ]));
  
  // Create bind group
  const bindGroup = device.createBindGroup({
    layout: computePipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: outputBuffer } },
      { binding: 1, resource: { buffer: paramsBuffer } }
    ]
  });
  
  // Dispatch compute shader
  const commandEncoder = device.createCommandEncoder();
  const passEncoder = commandEncoder.beginComputePass();
  passEncoder.setPipeline(computePipeline);
  passEncoder.setBindGroup(0, bindGroup);
  passEncoder.dispatchWorkgroups(
    Math.ceil(width / 8),
    Math.ceil(height / 8)
  );
  passEncoder.end();
  
  // Read back results (or use in another shader)
  device.queue.submit([commandEncoder.finish()]);
"""

when isMainModule:
  main()
