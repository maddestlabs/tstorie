# Generated by tStorie Nim Export (Standalone)
# Source: untitled.md

import times, os, math
import std/[strutils, tables, random]  # For join, getOrDefault, and random
import src/types
import src/layers
import src/appstate
import src/input  # Input parsing and polling
import src/simple_event  # Simplified event API
import lib/storie_themes  # Theme and stylesheet management
when not defined(emscripten):
  import src/platform/terminal

# tStorie library imports
import lib/storie_themes

# Global state
var gState: AppState
var gDefaultLayer: Layer  # Single default layer (layer 0)
var gRunning {.global.} = true
var gDeltaTime {.global.} = 0.016  # Time since last frame in seconds
var gStartTime {.global.} = 0.0  # App start time
var gTimeMs {.global.} = 0  # Milliseconds since start
var gInputParser: TerminalInputParser  # For input event parsing
when not defined(emscripten):
  var gTerminalState: TerminalState

# Style helper function
proc getStyle(name: string): Style =
  if gState.styleSheet.hasKey(name):
    let sc = gState.styleSheet[name]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  elif gState.styleSheet.hasKey("default"):
    # Use theme's default style as fallback
    let sc = gState.styleSheet["default"]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  else:
    result = defaultStyle()

# Style brightness adjustment
proc brightness(style: Style, factor: float): Style =
  ## Adjusts the brightness of a style's foreground color
  ## factor < 1.0 = darker, factor > 1.0 = brighter
  result = style
  result.fg.r = uint8(clamp(float(style.fg.r) * factor, 0.0, 255.0))
  result.fg.g = uint8(clamp(float(style.fg.g) * factor, 0.0, 255.0))
  result.fg.b = uint8(clamp(float(style.fg.b) * factor, 0.0, 255.0))

# Unified Drawing API - works with any layer
proc draw(layer: string, x, y: int, text: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.writeCellText(x, y, text, style)

proc draw(layerId: int, x, y: int, text: string, style: Style = getStyle("default")) =
  # Integer layer ID overload (0 = default layer)
  let targetLayer = if layerId == 0: gDefaultLayer
                    elif layerId < gState.layers.len: gState.layers[layerId]
                    else: nil
  if targetLayer.isNil: return
  targetLayer.buffer.writeCellText(x, y, text, style)

proc clear(layer: string = "", transparent: bool = false) =
  # Clear specific layer, or all layers if no layer specified
  if layer == "":
    for l in gState.layers:
      if transparent: l.buffer.clearCellsTransparent()
      else: l.buffer.clearCells(gState.themeBackground)
  else:
    let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
    if targetLayer.isNil: return
    if transparent: targetLayer.buffer.clearCellsTransparent() else: targetLayer.buffer.clearCells(gState.themeBackground)

proc fillRect(layer: string, x, y, w, h: int, ch: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.fillCellRect(x, y, w, h, ch, style)

# Runtime helper functions
proc print(args: varargs[string, `$`]) = echo args.join(" ")
template termWidth: int = gState.termWidth
template termHeight: int = gState.termHeight
template mouseX: int = gState.lastMouseX
template mouseY: int = gState.lastMouseY
proc str(x: int): string = $x
proc str(x: float): string = $x
proc str(x: bool): string = $x
proc str(x: string): string = x
# Timing functions
proc getTime(): float = epochTime() - gStartTime
proc getTimeMs(): float = (epochTime() - gStartTime) * 1000.0
proc getFps(): float = gState.fps
proc getFrameCount(): int = gState.frameCount
proc getDeltaTime(): float = gDeltaTime
# Param functions (stubs - no URL params in terminal builds)
proc hasParam(name: string): bool = false
proc getParam(name: string): string = ""
proc getParamInt(name: string, default: int): int = default
# Random number generation
var gRng = initRand()  # Global RNG
proc randomize() = gRng = initRand()
proc randomize(seed: int) = gRng = initRand(seed)
proc rand(max: int): int = random.rand(gRng, max)
proc rand(min, max: int): int = random.rand(gRng, max - min) + min

# User global variables
var seedValue: int
var visualizationWidth: int
var octavesValue: int
var gpuPending: bool
var samplesGenerated: int
var animating: bool
var offsetY: int
var lacunarityValue: int
var message: string
var currentNoiseType: int
var currentFBMMode: int
var gpuAvailable: bool
var offsetX: int
var visualizationHeight: int
var animFrame: int
var scaleValue: int
var useGPU: bool
var shaderLength: int
var gainValue: int

proc main() =
  gStartTime = epochTime()
  when not defined(emscripten):
    gTerminalState = setupRawMode()
    hideCursor()
    enableMouseReporting()
    enableKeyboardProtocol()
    
    # Setup signal handlers for graceful shutdown on CTRL-C
    setupSignalHandlers(proc(sig: cint) {.noconv.} = gRunning = false)
    
    let (w, h) = getTermSize()
    gState = newAppState(w, h)
    
    # Initialize default layer (layer 0)
    gDefaultLayer = addLayer(gState, "default", 0)
    
    # Load theme and stylesheet
    let theme = getTheme("catppuccin")
    gState.styleSheet = applyTheme(theme, "catppuccin")
    gState.themeBackground = theme.bg
    
    # Initialization
    # ===================================================================
    # State Management
    # ===================================================================
    animFrame = 0
    offsetX = 0
    offsetY = 0
    animating = false
    
    # Noise configuration
    currentNoiseType = 0
    currentFBMMode = 0
    
    seedValue = 42
    scaleValue = 100
    octavesValue = 3
    gainValue = 500
    lacunarityValue = 2000
    
    # Visualization
    visualizationWidth = 60
    visualizationHeight = 20
    
    # Performance tracking
    shaderLength = 0
    samplesGenerated = 0
    var cpuTimeMs = 0
    var gpuTimeMs = 0
    
    # GPU state
    useGPU = false
    gpuAvailable = false
    gpuPending = false
    
    # Check if GPU is available (web only)
    when defined(emscripten):
      if webgpuSupported():
        gpuAvailable = webgpuReady()
        if gpuAvailable:
          message = "WebGPU available! Press G to toggle GPU mode"
    
    # Message
    message = "Press N: Noise type | M: FBM mode | +/-: Octaves | S: Seed | A: Animate | G: GPU"

    var lastTime = epochTime()
    
    try:
      # Main loop
      while gState.running and gRunning:
        let currentTime = epochTime()
        let deltaTime = currentTime - lastTime
        lastTime = currentTime
        gDeltaTime = deltaTime
        
        # Update FPS counter
        gState.updateFpsCounter(deltaTime)
        
        # Poll for input events
        let events = pollInput(gInputParser)
        for nativeEvent in events:
          # Convert to simplified event API
          let event = toSimpleEvent(nativeEvent)
          # Process input event
          # ===================================================================
          # Input Handling
          # ===================================================================
          if event.type == "text":
            var ch = event.text
            
            # N - Change noise type
            if ch == "n" or ch == "N":
              currentNoiseType = currentNoiseType + 1
              if currentNoiseType > 2:
                currentNoiseType = 0
              typeName = "Perlin 2D"
              if currentNoiseType == 1:
                typeName = "Simplex 2D"
              elif currentNoiseType == 2:
                typeName = "Worley 2D"
              message = "Noise type: " & typeName
            
            # M - Change FBM mode
            elif ch == "m" or ch == "M":
              currentFBMMode = currentFBMMode + 1
              if currentFBMMode > 3:
                currentFBMMode = 0
              modeName = "Standard"
              if currentFBMMode == 1:
                modeName = "Ridged"
              elif currentFBMMode == 2:
                modeName = "Billow"
              elif currentFBMMode == 3:
                modeName = "Turbulent"
              message = "FBM mode: " & modeName
            
            # + - Increase octaves
            elif ch == "+" or ch == "=":
              if octavesValue < 4:
                octavesValue = octavesValue + 1
                message = "Octaves: " & str(octavesValue)
              else:
                message = "Maximum octaves reached (4)"
            
            # - - Decrease octaves
            elif ch == "-" or ch == "_":
              if octavesValue > 1:
                octavesValue = octavesValue - 1
                message = "Octaves: " & str(octavesValue)
              else:
                message = "Minimum octaves reached (1)"
            
            # S - Randomize seed
            elif ch == "s" or ch == "S":
              seedValue = seedValue + 1
              message = "New seed: " & str(seedValue)
            
            # A - Toggle animation
            elif ch == "a" or ch == "A":
              if animating:
                animating = false
                message = "Animation paused"
              else:
                animating = true
                message = "Animation started"
            
            # G - Toggle GPU mode (web only)
            elif ch == "g" or ch == "G":
              when defined(emscripten):
                if gpuAvailable:
                  useGPU = not useGPU
                  if useGPU:
                    message = "GPU mode enabled"
                  else:
                    message = "GPU mode disabled (using CPU)"
                    gpuPending = false
                else:
                  message = "GPU not available in this browser"
              else:
                message = "GPU mode only available in web version"
            
            # R - Reset view
            elif ch == "r" or ch == "R":
              offsetX = 0
              offsetY = 0
              message = "View reset to origin"
          
          elif event.type == "key":
            # Arrow keys - Pan view
            if event.keyCode == KEY_UP and event.action == "press":
              offsetY = offsetY - 5
              message = "Panned up (Y: " & str(offsetY) & ")"
            elif event.keyCode == KEY_DOWN and event.action == "press":
              offsetY = offsetY + 5
              message = "Panned down (Y: " & str(offsetY) & ")"
            elif event.keyCode == KEY_LEFT and event.action == "press":
              offsetX = offsetX - 5
              message = "Panned left (X: " & str(offsetX) & ")"
            elif event.keyCode == KEY_RIGHT and event.action == "press":
              offsetX = offsetX + 5
              message = "Panned right (X: " & str(offsetX) & ")"

        # Check if mouse tracking should be re-enabled
        checkMouseTrackingReenabled(gInputParser)

        # Update
        # ===================================================================
        # Animation Update
        # ===================================================================
        animFrame = animFrame + 1
        
        if animating:
          # Slowly pan the noise view
          offsetX = offsetX + 1
          if offsetX > 1000:
            offsetX = 0

        # Render
        # ===================================================================
        # Render
        # ===================================================================
        clear()
        
        let w = termWidth
        let h = termHeight
        
        # Title banner
        fillBox(0, 0, 0, w, 3, "═", getStyle("primary"))
        drawLabel(0, w div 2 - 15, 1, "WEBGPU NOISE GENERATION", getStyle("warning"))
        
        # Decorative corners
        drawLabel(0, 0, 0, "╔", getStyle("primary"))
        drawLabel(0, w - 1, 0, "╗", getStyle("primary"))
        drawLabel(0, 0, 2, "╚", getStyle("primary"))
        drawLabel(0, w - 1, 2, "╝", getStyle("primary"))
        
        # ===================================================================
        # Configuration Panel
        # ===================================================================
        drawPanel(0, 2, 5, 35, 20, "Noise Configuration", "double")
        
        drawLabel(0, 4, 7, "Type:", getStyle("info"))
        typeName = "Perlin 2D"
        if currentNoiseType == 1:
          typeName = "Simplex 2D"
        elif currentNoiseType == 2:
          typeName = "Worley 2D"
        drawLabel(0, 20, 7, typeName, getStyle("success"))
        
        drawLabel(0, 4, 9, "FBM Mode:", getStyle("info"))
        modeName = "Standard"
        if currentFBMMode == 1:
          modeName = "Ridged"
        elif currentFBMMode == 2:
          modeName = "Billow"
        elif currentFBMMode == 3:
          modeName = "Turbulent"
        drawLabel(0, 20, 9, modeName, getStyle("success"))
        
        drawLabel(0, 4, 11, "Seed:", getStyle("info"))
        drawLabel(0, 20, 11, str(seedValue), getStyle("warning"))
        
        drawLabel(0, 4, 13, "Scale:", getStyle("info"))
        drawLabel(0, 20, 13, str(scaleValue), getStyle("default"))
        
        drawLabel(0, 4, 15, "Octaves:", getStyle("info"))
        drawLabel(0, 20, 15, str(octavesValue), getStyle("default"))
        
        drawLabel(0, 4, 17, "Gain:", getStyle("info"))
        drawLabel(0, 20, 17, str(gainValue), getStyle("default"))
        
        drawLabel(0, 4, 19, "Lacunarity:", getStyle("info"))
        drawLabel(0, 20, 19, str(lacunarityValue), getStyle("default"))
        
        drawLabel(0, 4, 21, "Animation:", getStyle("info"))
        if animating:
          drawLabel(0, 20, 21, "RUNNING", getStyle("success"))
        else:
          drawLabel(0, 20, 21, "PAUSED", getStyle("dim"))
        
        # ===================================================================
        # Noise Visualization
        # ===================================================================
        drawPanel(0, 39, 5, visualizationWidth + 4, visualizationHeight + 4, "Noise Output (CPU Sampling)", "rounded")
        
        # Get noise type
        var noiseType = ntPerlin2D
        if currentNoiseType == 1:
          noiseType = ntSimplex2D
        elif currentNoiseType == 2:
          noiseType = ntWorley2D
        
        # Create noise configuration
        var noiseConfig = noise(noiseType)
        noiseConfig = noiseSeed(noiseConfig, seedValue)
        noiseConfig = noiseScale(noiseConfig, scaleValue)
        noiseConfig = noiseOctaves(noiseConfig, octavesValue)
        noiseConfig = noiseGain(noiseConfig, gainValue)
        noiseConfig = noiseLacunarity(noiseConfig, lacunarityValue)
        
        # Apply FBM mode
        if currentFBMMode == 1:
          noiseConfig = noiseRidged(noiseConfig)
        elif currentFBMMode == 2:
          noiseConfig = noiseBillow(noiseConfig)
        elif currentFBMMode == 3:
          noiseConfig = noiseTurbulent(noiseConfig)
        
        # Sample and render noise
        var sampleCount = 0
        var minVal = 65535
        var maxVal = 0
        var avgVal = 0
        
        # Try GPU execution if enabled and available (web only)
        when defined(emscripten) and useGPU and gpuAvailable and not gpuPending:
          let started = webgpuStart(noiseConfig, visualizationWidth, visualizationHeight, offsetX, offsetY)
          if started:
            gpuPending = true
            message = "GPU execution started..."
        
        # Check if GPU results are ready
        var hasGPUResults = false
        when defined(emscripten) and gpuPending and webgpuIsReady():
          gpuPending = false
          hasGPUResults = true
          message = "GPU execution complete!"
        
        var vy = 0
        while vy < visualizationHeight:
          var vx = 0
          while vx < visualizationWidth:
            # Get value from GPU or CPU
            var value = 0
            if hasGPUResults:
              let idx = vy * visualizationWidth + vx
              value = webgpuGet(idx)
            else:
              let nx = vx + offsetX
              let ny = vy + offsetY
              value = noiseSample(noiseConfig, nx, ny)
            
            sampleCount = sampleCount + 1
            avgVal = avgVal + value
            if value < minVal:
              minVal = value
            if value > maxVal:
              maxVal = value
            
            # Map value to character (0-65535 mapped to 6 levels)
            var char = " "
            if value > 52428:
              char = "█"
            elif value > 39321:
              char = "▓"
            elif value > 26214:
              char = "▒"
            elif value > 13107:
              char = "░"
            elif value > 6553:
              char = "·"
            
            # Color based on value
            var style = getStyle("default")
            if value < 16384:
              style = getStyle("primary")
            elif value < 32768:
              style = getStyle("info")
            elif value < 49152:
              style = getStyle("success")
            else:
              style = getStyle("warning")
            
            drawLabel(0, 41 + vx, 7 + vy, char, style)
            vx = vx + 1
          vy = vy + 1
        
        avgVal = avgVal / sampleCount
        samplesGenerated = sampleCount
        
        # ===================================================================
        # Statistics Panel
        # ===================================================================
        let statsHeight = if gpuAvailable: 16 else: 14
        drawPanel(0, 2, 26, 35, statsHeight, "Statistics", "single")
        
        drawLabel(0, 4, 28, "Frame:", getStyle("info"))
        drawLabel(0, 20, 28, str(animFrame), getStyle("default"))
        
        drawLabel(0, 4, 30, "Samples:", getStyle("info"))
        drawLabel(0, 20, 30, str(samplesGenerated), getStyle("success"))
        
        drawLabel(0, 4, 32, "Min Value:", getStyle("info"))
        drawLabel(0, 20, 32, str(minVal), getStyle("default"))
        
        drawLabel(0, 4, 33, "Max Value:", getStyle("info"))
        drawLabel(0, 20, 33, str(maxVal), getStyle("default"))
        
        drawLabel(0, 4, 34, "Avg Value:", getStyle("info"))
        drawLabel(0, 20, 34, str(avgVal), getStyle("default"))
        
        drawLabel(0, 4, 36, "Offset X:", getStyle("info"))
        drawLabel(0, 20, 36, str(offsetX), getStyle("dim"))
        
        drawLabel(0, 4, 37, "Offset Y:", getStyle("info"))
        drawLabel(0, 20, 37, str(offsetY), getStyle("dim"))
        
        when defined(emscripten) and gpuAvailable:
          drawLabel(0, 4, 39, "GPU Mode:", getStyle("info"))
          if useGPU:
            drawLabel(0, 20, 39, "ENABLED", getStyle("success"))
          else:
            drawLabel(0, 20, 39, "DISABLED", getStyle("dim"))
        
        # ===================================================================
        # WGSL Shader Generation
        # ===================================================================
        drawPanel(0, 39, 30, visualizationWidth + 4, 10, "WebGPU Shader Generation", "double")
        
        # Generate WGSL shader code
        let wgslShader = noiseToWGSL(noiseConfig)
        shaderLength = len(wgslShader)
        
        drawLabel(0, 41, 32, "WGSL Shader Generated:", getStyle("success"))
        drawLabel(0, 41, 34, "Length:", getStyle("info"))
        drawLabel(0, 50, 34, str(shaderLength) & " chars", getStyle("warning"))
        
        # ===================================================================
        # Controls Panel
        # ===================================================================
        drawPanel(0, 2, 41, 35, 12, "Controls", "rounded")
        
        drawLabel(0, 4, 43, "N - Change Noise Type", getStyle("info"))
        drawLabel(0, 4, 44, "M - Change FBM Mode", getStyle("info"))
        drawLabel(0, 4, 45, "+ - Increase Octaves", getStyle("info"))
        drawLabel(0, 4, 46, "- - Decrease Octaves", getStyle("info"))
        drawLabel(0, 4, 47, "S - Randomize Seed", getStyle("info"))
        drawLabel(0, 4, 48, "A - Toggle Animation", getStyle("info"))
        drawLabel(0, 4, 49, "G - Toggle GPU Mode", getStyle("info"))
        drawLabel(0, 4, 50, "Arrow Keys - Pan View", getStyle("info"))
        drawLabel(0, 4, 51, "R - Reset View", getStyle("info"))
        drawLabel(0, 4, 50, "R - Reset View", getStyle("info"))
        
        # ===================================================================
        # API Reference
        # ===================================================================
        drawPanel(0, 39, 41, visualizationWidth + 4, 12, "Noise Composer API", "single")
        
        drawLabel(0, 41, 43, "Builder Pattern:", getStyle("warning"))
        drawLabel(0, 41, 44, "  var cfg = noise(type)", getStyle("dim"))
        drawLabel(0, 41, 45, "  cfg = noiseSeed(cfg, s)", getStyle("dim"))
        drawLabel(0, 41, 46, "  cfg = noiseScale(cfg, n)", getStyle("dim"))
        drawLabel(0, 41, 47, "  cfg = noiseOctaves(cfg, n)", getStyle("dim"))
        
        drawLabel(0, 41, 49, "FBM Modes:", getStyle("warning"))
        drawLabel(0, 41, 50, "  noiseRidged() noiseBillow()", getStyle("dim"))
        drawLabel(0, 41, 51, "  noiseTurbulence()", getStyle("dim"))
        
        drawLabel(0, 41, 52, "Sample: noiseSample2D(cfg,x,y)", getStyle("dim"))
        
        # Footer message bar
        fillBox(0, 0, h - 2, w, 2, " ", getStyle("default"))
        drawLabel(0, 2, h - 1, message, getStyle("warning"))

        # Composite layers and display to terminal
        gState.compositeLayers()
        gState.currentBuffer.display(gState.previousBuffer, gState.colorSupport)

        # Frame rate limiting
        if gState.targetFps > 0.0:
          let frameTime = epochTime() - currentTime
          let targetFrameTime = 1.0 / gState.targetFps
          let sleepTime = targetFrameTime - frameTime
          if sleepTime > 0:
            sleep(int(sleepTime * 1000))
    finally:
      # Cleanup terminal
      disableKeyboardProtocol()
      disableMouseReporting()
      showCursor()
      clearScreen()
      restoreTerminal(gTerminalState)
      stdout.write("\n")
      stdout.flushFile()

when isMainModule:
  main()
