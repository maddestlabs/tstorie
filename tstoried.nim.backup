## TStoried - TStorie Editor/Daemon
##
## Standalone terminal markdown editor for TStorie content.
## Built independently to identify core vs. application concerns.
##
## Usage:
##   tstoried                    # Start with empty document
##   tstoried file.md            # Load file
##   tstoried --gist abc123      # Load gist
##
## Keyboard shortcuts:
##   Ctrl+Q - Quit
##   Ctrl+W - Save file
##   Ctrl+G - Create/update gist
##   Ctrl+O - Open file/gist browser
##   Esc    - Cancel/back

import std/[os, strutils, parseopt, terminal, times]
import lib/[storie_types, storie_themes, gist_api, editor_base]

# ================================================================
# APPLICATION STATE
# ================================================================

type
  EditorMode = enum
    modeEdit      ## Text editing
    modeBrowse    ## File/gist browser
  
  EditorApp = object
    mode: EditorMode
    previousMode: EditorMode
    
    # Document state
    lines: seq[string]
    cursor: tuple[row, col: int]
    scroll: int
    filename: string
    gistId: string
    modified: bool
    
    # Browser state
    browserItems: seq[tuple[text, data: string]]
    browserSelected: int
    
    # Display
    termWidth: int
    termHeight: int
    showLineNumbers: bool
    
    # Theme
    stylesheet: StyleSheet
    statusMsg: string
    running: bool

var app: EditorApp

# ================================================================
# INITIALIZATION
# ================================================================

proc initApp*() =
  app.mode = modeEdit
  app.previousMode = modeEdit
  app.lines = @[""]
  app.cursor = (0, 0)
  app.scroll = 0
  app.filename = ""
  app.gistId = ""
  app.modified = false
  app.browserItems = @[]
  app.browserSelected = 0
  app.showLineNumbers = true
  app.running = true
  
  # Get terminal size
  app.termWidth = terminalWidth()
  app.termHeight = terminalHeight()
  
  # Setup theme
  app.stylesheet = applyFullTheme("miami-vice")
  app.statusMsg = "Ready | Ctrl+Q: Quit"

# ================================================================
# DOCUMENT OPERATIONS
# ================================================================

proc getText(): string =
  return app.lines.join("\n")

proc setText(text: string) =
  app.lines = text.split('\n')
  if app.lines.len == 0:
    app.lines = @[""]
  app.cursor = (0, 0)
  app.scroll = 0
  app.modified = true

proc insertChar(ch: char) =
  let row = app.cursor.row
  let col = app.cursor.col
  if row >= 0 and row < app.lines.len:
    var line = app.lines[row]
    line.insert($ch, col)
    app.lines[row] = line
    app.cursor.col += 1
    app.modified = true

proc deleteChar() =
  let row = app.cursor.row
  let col = app.cursor.col
  
  if col > 0:
    var line = app.lines[row]
    if col <= line.len:
      line.delete(col - 1 .. col - 1)
      app.lines[row] = line
      app.cursor.col -= 1
      app.modified = true
  elif row > 0:
    let prevLine = app.lines[row - 1]
    let currentLine = app.lines[row]
    app.lines[row - 1] = prevLine & currentLine
    app.lines.delete(row)
    app.cursor.row -= 1
    app.cursor.col = prevLine.len
    app.modified = true

proc insertNewline() =
  let row = app.cursor.row
  let col = app.cursor.col
  let line = app.lines[row]
  
  let beforeCursor = if col <= line.len: line[0 ..< col] else: line
  let afterCursor = if col <= line.len: line[col .. ^1] else: ""
  
  app.lines[row] = beforeCursor
  app.lines.insert(afterCursor, row + 1)
  app.cursor.row += 1
  app.cursor.col = 0
  app.modified = true

proc moveCursor(drow, dcol: int) =
  var newRow = app.cursor.row + drow
  var newCol = app.cursor.col + dcol
  
  newRow = max(0, min(newRow, app.lines.len - 1))
  let lineLen = app.lines[newRow].len
  newCol = max(0, min(newCol, lineLen))
  
  app.cursor = (newRow, newCol)

proc ensureCursorVisible() =
  let gutterWidth = if app.showLineNumbers: 5 else: 0
  let visibleHeight = app.termHeight - 1  # Reserve 1 for status
  
  if app.cursor.row < app.scroll:
    app.scroll = app.cursor.row
  elif app.cursor.row >= app.scroll + visibleHeight:
    app.scroll = app.cursor.row - visibleHeight + 1

# ================================================================
# FILE OPERATIONS  
# ================================================================

proc loadFile(path: string) =
  if not fileExists(path):
    app.statusMsg = "Error: File not found"
    return
  
  try:
    let content = readFile(path)
    setText(content)
    app.filename = path
    app.modified = false
    app.statusMsg = "Loaded: " & path
  except IOError as e:
    app.statusMsg = "Error: " & e.msg

proc saveFile() =
  if app.filename == "":
    app.statusMsg = "Error: No filename"
    return
  
  try:
    writeFile(app.filename, getText())
    app.modified = false
    app.statusMsg = "Saved: " & app.filename
  except IOError as e:
    app.statusMsg = "Error: " & e.msg

proc loadGistById(gistId: string) =
  try:
    let gist = loadGist(gistId)
    if not gist.hasMarkdownFile():
      app.statusMsg = "Error: No markdown files in gist"
      return
    
    let mdFile = gist.getFirstMarkdownFile()
    setText(mdFile.content)
    app.gistId = gistId
    app.filename = mdFile.filename
    app.modified = false
    app.statusMsg = "Loaded gist: " & gistId
  except GistError as e:
    app.statusMsg = "Error: " & e.msg

proc createOrUpdateGist() =
  if not hasGithubToken():
    app.statusMsg = "Error: Set GITHUB_TOKEN"
    return
  
  let content = getText()
  let filename = if app.filename != "": app.filename else: "tstorie.md"
  
  try:
    if app.gistId != "":
      var gist = Gist(
        id: app.gistId,
        description: "TStorie content",
        public: true,
        files: @[GistFile(filename: filename, content: content)]
      )
      updateGist(gist)
      app.statusMsg = "Updated gist: " & app.gistId
    else:
      var gist = Gist(
        description: "TStorie content",
        public: true,
        files: @[GistFile(filename: filename, content: content)]
      )
      let newId = createGist(gist)
      app.gistId = newId
      app.statusMsg = "Created gist: " & newId
    app.modified = false
  except GistError as e:
    app.statusMsg = "Error: " & e.msg

# ================================================================
# BROWSER MODE
# ================================================================

proc populateBrowser() =
  app.browserItems = @[]
  
  # Add local markdown files
  try:
    for kind, path in walkDir("."):
      if kind == pcFile and path.endsWith(".md"):
        app.browserItems.add((path, path))
  except OSError:
    discard
  
  # Add gists if token available
  if hasGithubToken():
    try:
      let gists = listUserGists()
      for gist in gists:
        if gist.hasMarkdownFile():
          let desc = if gist.description != "": gist.description else: gist.id
          app.browserItems.add(("[GIST] " & desc, gist.id))
    except GistError:
      discard
  
  app.browserSelected = 0

proc switchMode(newMode: EditorMode) =
  app.previousMode = app.mode
  app.mode = newMode
  
  if newMode == modeBrowse:
    populateBrowser()
    app.statusMsg = "BROWSE | Enter: Open | Esc: Cancel"
  else:
    app.statusMsg = if app.filename != "": app.filename else: "[No File]"

# ================================================================
# RENDERING
# ================================================================

proc render() =
  # Clear screen
  stdout.write("\e[2J\e[H")
  
  case app.mode
  of modeEdit:
    # Render text editor
    let gutterWidth = if app.showLineNumbers: 5 else: 0
    let visibleHeight = app.termHeight - 1
    let visibleStart = app.scroll
    let visibleEnd = min(app.scroll + visibleHeight, app.lines.len)
    
    for i in visibleStart ..< visibleEnd:
      let screenY = i - visibleStart
      
      # Line number
      if app.showLineNumbers:
        let lineNum = i + 1
        let numStr = align($lineNum, 4)
        let isCurrentLine = (i == app.cursor.row)
        stdout.write(if isCurrentLine: "\e[1;35m" else: "\e[2;37m")
        stdout.write(numStr)
        stdout.write("\e[0mâ”‚")
      
      # Line content
      stdout.write(app.lines[i])
      stdout.write("\n")
    
    # Position cursor
    let cursorScreenY = app.cursor.row - app.scroll
    let cursorScreenX = app.cursor.col + gutterWidth
    if cursorScreenY >= 0 and cursorScreenY < visibleHeight:
      stdout.write("\e[" & $(cursorScreenY + 1) & ";" & $(cursorScreenX + 1) & "H")
  
  of modeBrowse:
    # Render file browser
    let visibleHeight = app.termHeight - 1
    for i, item in app.browserItems:
      if i >= visibleHeight:
        break
      
      let isSelected = (i == app.browserSelected)
      if isSelected:
        stdout.write("\e[1;35;40m")
      stdout.write(item.text)
      if isSelected:
        stdout.write("\e[0m")
      stdout.write("\n")
  
  # Status bar at bottom
  stdout.write("\e[" & $app.termHeight & ";1H")
  stdout.write("\e[1;35;40m")
  stdout.write(app.statusMsg)
  # Pad to full width
  let padding = app.termWidth - app.statusMsg.len
  if padding > 0:
    stdout.write(repeat(" ", padding))
  stdout.write("\e[0m")
  
  stdout.flushFile()

# ================================================================
# INPUT HANDLING
# ================================================================

proc handleInput(ch: char): bool =
  case app.mode
  of modeEdit:
    case ch
    of '\x11':  # Ctrl+Q
      return false
    of '\x17':  # Ctrl+W
      saveFile()
    of '\x07':  # Ctrl+G
      createOrUpdateGist()
    of '\x0F':  # Ctrl+O
      switchMode(modeBrowse)
    of '\x7F':  # Backspace
      deleteChar()
      ensureCursorVisible()
    of '\r', '\n':  # Enter
      insertNewline()
      ensureCursorVisible()
    of '\x1B':  # Escape sequence
      discard  # Would need to read more chars for arrow keys
    of ' '..'~':  # Printable characters
      insertChar(ch)
      ensureCursorVisible()
    else:
      discard
  
  of modeBrowse:
    case ch
    of '\x1B':  # Escape
      switchMode(modeEdit)
    of '\r', '\n':  # Enter
      if app.browserSelected >= 0 and app.browserSelected < app.browserItems.len:
        let item = app.browserItems[app.browserSelected]
        if item.data.endsWith(".md"):
          loadFile(item.data)
        else:
          loadGistById(item.data)
        switchMode(modeEdit)
    of 'j', 'J':  # Down
      if app.browserSelected < app.browserItems.len - 1:
        inc app.browserSelected
    of 'k', 'K':  # Up
      if app.browserSelected > 0:
        dec app.browserSelected
    of '\x11':  # Ctrl+Q
      return false
    else:
      discard
  
  return true

# ================================================================
# MAIN LOOP
# ================================================================

proc main() =
  # Parse command line
  var filename = ""
  var gistId = ""
  
  var p = initOptParser()
  while true:
    p.next()
    case p.kind
    of cmdEnd: break
    of cmdShortOption, cmdLongOption:
      case p.key
      of "gist", "g":
        gistId = p.val
      of "help", "h":
        echo "TStoried - TStorie Editor"
        echo "Usage: tstoried [file.md]"
        echo "       tstoried --gist ID"
        quit(0)
      else:
        discard
    of cmdArgument:
      filename = p.key
  
  # Initialize
  initApp()
  
  # Load initial content
  if gistId != "":
    loadGistById(gistId)
  elif filename != "":
    loadFile(filename)
  
  # Setup terminal
  hideCursor()
  system.addQuitProc(resetAttributes)
  
  try:
    # Main loop
    while app.running:
      # Update terminal size
      app.termWidth = terminalWidth()
      app.termHeight = terminalHeight()
      
      # Render
      render()
      
      # Handle input
      if not getch().handleInput():
        app.running = false
      
      # Small delay to reduce CPU
      sleep(10)
  finally:
    # Cleanup
    showCursor()
    resetAttributes()
    stdout.write("\e[2J\e[H")
    stdout.write("Goodbye!\n")
    stdout.flushFile()

when isMainModule:
  main()


# ================================================================
# APPLICATION STATE
# ================================================================

type
  EditorMode = enum
    modeEdit      ## Text editing
    modePreview   ## Live preview
    modeSplit     ## Split edit/preview
    modeBrowse    ## File/gist browser
    modeCommand   ## Command input
  
  EditorApp = object
    # Widget manager
    wm: WidgetManager
    
    # Mode
    mode: EditorMode
    previousMode: EditorMode
    
    # Widgets
    textBox: TextBox
    statusLabel: Label
    browserList: ListView
    
    # Document state
    filename: string
    gistId: string
    modified: bool
    
    # Theme
    themeName: string
    stylesheet: StyleSheet
    
    # Layers
    bgLayer: Layer
    fgLayer: Layer
    uiLayer: Layer

var app: EditorApp

# ================================================================
# INITIALIZATION
# ================================================================

proc initApp*(themeName: string = "miami-vice") =
  ## Initialize the editor application
  app.mode = modeEdit
  app.previousMode = modeEdit
  app.filename = ""
  app.gistId = ""
  app.modified = false
  app.themeName = themeName
  
  # Setup theme and stylesheet
  app.stylesheet = applyFullTheme(themeName)
  
  # Create widget manager
  app.wm = newWidgetManager(app.stylesheet)
  
  # Create layers
  let termWidth = getTerminalWidth()
  let termHeight = getTerminalHeight()
  
  app.bgLayer = newLayer("background", 0, 0, termWidth, termHeight)
  app.fgLayer = newLayer("foreground", 0, 0, termWidth, termHeight)
  app.uiLayer = newLayer("ui", 0, 0, termWidth, termHeight)
  
  # Create widgets
  app.textBox = newTextBox("editor", 0, 0, termWidth, termHeight - 1)
  app.textBox.showLineNumbers = true
  app.wm.addWidget(app.textBox)
  
  app.statusLabel = newLabel("status", 0, termHeight - 1, termWidth, 1, "Ready | Ctrl+Q: Quit")
  app.statusLabel.normalStyle = "editor.statusbar"
  app.wm.addWidget(app.statusLabel)
  
  app.browserList = newListView("browser", 0, 0, termWidth, termHeight - 1)
  app.browserList.visible = false
  app.wm.addWidget(app.browserList)
  
  # Set initial focus
  app.wm.focusWidget(app.textBox)

# ================================================================
# FILE OPERATIONS
# ================================================================

proc loadFile*(path: string) =
  ## Load a markdown file into the editor
  if not fileExists(path):
    app.statusLabel.setText("Error: File not found: " & path)
    return
  
  try:
    let content = readFile(path)
    app.textBox.setText(content)
    app.filename = path
    app.modified = false
    app.statusLabel.setText("Loaded: " & path)
  except IOError as e:
    app.statusLabel.setText("Error loading file: " & e.msg)

proc saveFile*() =
  ## Save current content to file
  if app.filename == "":
    app.statusLabel.setText("Error: No filename. Use Ctrl+O to set filename.")
    return
  
  try:
    let content = app.textBox.getText()
    writeFile(app.filename, content)
    app.modified = false
    app.statusLabel.setText("Saved: " & app.filename)
  except IOError as e:
    app.statusLabel.setText("Error saving file: " & e.msg)

proc loadGistById*(gistId: string) =
  ## Load a gist into the editor
  try:
    let gist = loadGist(gistId)
    
    # Find first markdown file
    if not gist.hasMarkdownFile():
      app.statusLabel.setText("Error: Gist has no markdown files")
      return
    
    let mdFile = gist.getFirstMarkdownFile()
    app.textBox.setText(mdFile.content)
    app.gistId = gistId
    app.filename = mdFile.filename
    app.modified = false
    app.statusLabel.setText("Loaded gist: " & gistId)
  except GistError as e:
    app.statusLabel.setText("Error loading gist: " & e.msg)

proc createOrUpdateGist*() =
  ## Create new gist or update existing one
  if not hasGithubToken():
    app.statusLabel.setText("Error: Set GITHUB_TOKEN environment variable")
    return
  
  let content = app.textBox.getText()
  let filename = if app.filename != "": app.filename else: "tstorie.md"
  
  try:
    if app.gistId != "":
      # Update existing gist
      var gist = Gist(
        id: app.gistId,
        description: "TStorie content",
        public: true,
        files: @[GistFile(filename: filename, content: content)]
      )
      updateGist(gist)
      app.modified = false
      app.statusLabel.setText("Updated gist: " & app.gistId)
    else:
      # Create new gist
      var gist = Gist(
        description: "TStorie content",
        public: true,
        files: @[GistFile(filename: filename, content: content)]
      )
      let newId = createGist(gist)
      app.gistId = newId
      app.modified = false
      app.statusLabel.setText("Created gist: " & newId)
  except GistError as e:
    app.statusLabel.setText("Error with gist: " & e.msg)

# ================================================================
# MODE SWITCHING
# ================================================================

proc switchMode*(newMode: EditorMode) =
  ## Switch editor mode and update widget visibility
  app.previousMode = app.mode
  app.mode = newMode
  
  # Update widget visibility
  case newMode
  of modeEdit:
    app.textBox.visible = true
    app.textBox.width = getTerminalWidth()
    app.textBox.height = getTerminalHeight() - 1
    app.browserList.visible = false
    app.wm.focusWidget(app.textBox)
    app.statusLabel.setText("EDIT | " & (if app.filename != "": app.filename else: "[No File]"))
  
  of modePreview:
    app.textBox.visible = false
    app.browserList.visible = false
    # TODO: Implement preview rendering using canvas
    app.statusLabel.setText("PREVIEW | (Preview not yet implemented)")
  
  of modeSplit:
    app.textBox.visible = true
    app.textBox.width = getTerminalWidth() div 2
    app.textBox.height = getTerminalHeight() - 1
    app.browserList.visible = false
    app.wm.focusWidget(app.textBox)
    # TODO: Render preview on right side
    app.statusLabel.setText("SPLIT | (Split view not yet fully implemented)")
  
  of modeBrowse:
    app.textBox.visible = false
    app.browserList.visible = true
    app.browserList.width = getTerminalWidth()
    app.browserList.height = getTerminalHeight() - 1
    app.wm.focusWidget(app.browserList)
    
    # Populate browser with files/gists
    app.browserList.clearItems()
    
    # Add local files in current directory
    try:
      for kind, path in walkDir("."):
        if kind == pcFile and path.endsWith(".md"):
          app.browserList.addItem(path, path, "ðŸ“„")
    except OSError:
      discard
    
    # Add gists if token available
    if hasGithubToken():
      try:
        let gists = listUserGists()
        for gist in gists:
          if gist.hasMarkdownFile():
            let desc = if gist.description != "": gist.description else: gist.id
            app.browserList.addItem(desc, gist.id, "ðŸ“¦")
      except GistError:
        discard
    
    app.statusLabel.setText("BROWSE | Enter: Open | Esc: Cancel")
  
  of modeCommand:
    # TODO: Implement command palette
    app.statusLabel.setText("COMMAND | (Not yet implemented)")

# ================================================================
# INPUT HANDLING
# ================================================================

proc handleGlobalInput*(event: InputEvent): bool =
  ## Handle global keyboard shortcuts
  if event.kind == evKey and event.action == "press":
    # Check for Ctrl+key combinations
    if event.key.startsWith("ctrl+"):
      case event.key[5 .. ^1]
      of "q":
        return false  # Quit
      of "e":
        switchMode(modeEdit)
        return true
      of "p":
        switchMode(modePreview)
        return true
      of "s":
        switchMode(modeSplit)
        return true
      of "o":
        switchMode(modeBrowse)
        return true
      of "w":
        saveFile()
        return true
      of "g":
        createOrUpdateGist()
        return true
      else:
        discard
    
    # Mode-specific keys
    if app.mode == modeBrowse:
      case event.keyCode
      of 27:  # Escape
        switchMode(app.previousMode)
        return true
      of 257:  # Enter
        let item = app.browserList.getSelectedItem()
        if item.data != "":
          if item.data.endsWith(".md"):
            # Load file
            loadFile(item.data)
          else:
            # Load gist
            loadGistById(item.data)
          switchMode(modeEdit)
        return true
      else:
        discard
  
  return false

# ================================================================
# UPDATE & RENDER
# ================================================================

proc update*(dt: float) =
  ## Update application state
  app.wm.update(dt)
  
  # Track modification state
  if app.textBox.modified:
    app.modified = true

proc render*() =
  ## Render application to screen
  # Clear layers
  bgClear()
  fgClear()
  
  # Render widgets
  app.wm.render(app.fgLayer)
  
  # Render mode-specific overlays
  if app.mode == modeSplit:
    # Draw vertical divider
    let splitX = app.textBox.width
    let dividerStyle = if app.stylesheet.hasKey("editor.border"):
      toStyle(app.stylesheet["editor.border"])
    else:
      Style(fg: Color(r: 128, g: 128, b: 128), bg: Color(r: 0, g: 0, b: 0),
            bold: false, italic: false, underline: false, dim: false)
    
    for y in 0 ..< getTerminalHeight() - 1:
      put(app.fgLayer, splitX, y, "â”‚", dividerStyle)
  
  # Render layers
  renderLayers()

# ================================================================
# MAIN LOOP
# ================================================================

proc main() =
  ## Main application entry point
  
  # Parse command line arguments
  var filename = ""
  var gistId = ""
  var themeName = "miami-vice"
  
  var p = initOptParser()
  while true:
    p.next()
    case p.kind
    of cmdEnd: break
    of cmdShortOption, cmdLongOption:
      case p.key
      of "gist", "g":
        gistId = p.val
      of "theme", "t":
        themeName = p.val
      of "help", "h":
        echo "TStoried - TStorie Editor"
        echo ""
        echo "Usage:"
        echo "  tstoried [file.md]         Load file"
        echo "  tstoried --gist ID         Load gist"
        echo "  tstoried --theme NAME      Set theme"
        echo ""
        echo "Shortcuts:"
        echo "  Ctrl+E  Edit mode"
        echo "  Ctrl+P  Preview mode"
        echo "  Ctrl+S  Split mode"
        echo "  Ctrl+O  Browse files/gists"
        echo "  Ctrl+W  Save file"
        echo "  Ctrl+G  Create/update gist"
        echo "  Ctrl+Q  Quit"
        quit(0)
      else:
        discard
    of cmdArgument:
      filename = p.key
  
  # Initialize terminal
  when not defined(js):
    initTerminal()
  
  # Initialize app
  initApp(themeName)
  
  # Load initial content
  if gistId != "":
    loadGistById(gistId)
  elif filename != "":
    loadFile(filename)
  
  # Main loop
  var running = true
  when not defined(js):
    var lastTime = cpuTime()
  
  while running:
    # Calculate delta time
    when not defined(js):
      let now = cpuTime()
      let dt = now - lastTime
      lastTime = now
    else:
      let dt = 0.016  # ~60 FPS
    
    # Poll events
    let event = pollEvent()
    if event.kind != evNone:
      # Global shortcuts
      let continueRunning = handleGlobalInput(event)
      if not continueRunning:
        running = false
        continue
      
      # Widget input
      discard app.wm.handleInput(event)
    
    # Update
    update(dt)
    
    # Render
    render()
    
    # Cap framerate
    when not defined(js):
      sleep(16)  # ~60 FPS
  
  # Cleanup
  when not defined(js):
    shutdownTerminal()

when isMainModule:
  main()
