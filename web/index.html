<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TStorie - Terminal Engine</title>
    <style>
        @font-face {
            font-family: 'FiraCode';
            src: url('assets/FiraCodeNerdFont-Regular.ttf') format('truetype');
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'FiraCode', 'Consolas', 'Monaco', monospace;
            width: 100vw;
            height: 100vh;
        }
        
        body.custom-font {
            font-family: var(--custom-font-family), 'FiraCode', 'Consolas', 'Monaco', monospace;
        }
        
        #container {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        #terminal {
            display: block;
            background: #000;
            outline: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            font-smooth: never;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            font-family: 'FiraCode', 'Consolas', 'Monaco', monospace;
        }
        
        #terminal.custom-font {
            font-family: var(--custom-font-family), 'FiraCode', 'Consolas', 'Monaco', monospace;
        }
        
        #loading {
            position: absolute;
            color: #0f0;
            font-size: 16px;
            text-align: center;
            z-index: 10;
        }
        
        #loading.hidden {
            display: none;
        }
        
        .error {
            color: #f00;
            background: #300;
            padding: 20px;
            border: 2px solid #f00;
            max-width: 600px;
            margin: 20px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div>Loading TStorie...</div>
            <div id="progress"></div>
        </div>
        <canvas id="terminal" tabindex="0"></canvas>
    </div>
    
    <script>
        // Setup Module before loading WASM (Emscripten will merge with this)
        let canvas = document.getElementById('terminal');  // Use 'let' so we can replace it with WebGL canvas
        const loading = document.getElementById('loading');
        const progress = document.getElementById('progress');
        const container = document.getElementById('container');
        
        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const gistId = urlParams.get('gist');
        const demoName = urlParams.get('demo');
        const fontUrl = urlParams.get('font');
        const shaderGistId = urlParams.get('shader');
        
        // Gist/demo loading state
        let gistMarkdown = null;
        let moduleReady = false;
        let gistReady = false;
        let shaderCode = null;
        let shaderReady = false;
        
        if (gistId) {
            console.log('Gist parameter detected:', gistId);
        }
        
        if (demoName) {
            console.log('Demo parameter detected:', demoName);
        }
        
        if (shaderGistId) {
            console.log('Shader parameter detected:', shaderGistId);
        }
        
        // Load custom font if specified
        if (fontUrl) {
            console.log('Custom font parameter detected:', fontUrl);
            try {
                let actualUrl = fontUrl;
                let fontFamily = '';
                
                // Check if it's a full URL or just a font name
                if (fontUrl.startsWith('http://') || fontUrl.startsWith('https://')) {
                    // It's a full URL
                    const fontMatch = fontUrl.match(/family=([^:&]+)/);
                    if (fontMatch) {
                        fontFamily = fontMatch[1].replace(/\+/g, ' ');
                    }
                } else {
                    // It's just a font name, construct Google Fonts URL
                    fontFamily = fontUrl.replace(/-/g, ' ');
                    actualUrl = 'https://fonts.googleapis.com/css2?family=' + fontUrl.replace(/\s+/g, '+') + '&display=swap';
                }
                
                console.log('Loading font from:', actualUrl);
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = actualUrl;
                document.head.appendChild(link);
                
                if (fontFamily) {
                    document.documentElement.style.setProperty('--custom-font-family', fontFamily);
                    document.body.classList.add('custom-font');
                    canvas.classList.add('custom-font');
                    // Store font family for TStorieTerminal to use
                    const fullFontFamily = "'" + fontFamily + "', 'FiraCode', 'Consolas', 'Monaco', monospace";
                    if (typeof Module !== 'undefined') {
                        Module.customFontFamily = fullFontFamily;
                    } else {
                        // Module not defined yet, we'll set it when defining Module
                        window.customFontFamily = fullFontFamily;
                    }
                    console.log('Applied custom font:', fontFamily);
                }
            } catch (e) {
                console.error('Error loading custom font:', e);
            }
        }
        
        function tryLoadGist() {
            // Only load if both module and gist are ready
            console.log('tryLoadGist called - moduleReady:', moduleReady, 'gistReady:', gistReady, 'hasMarkdown:', !!gistMarkdown);
            if (moduleReady && gistReady && gistMarkdown) {
                console.log('=== Loading markdown (' + gistMarkdown.length + ' bytes) ===');
                try {
                    if (typeof Module.ccall === 'function') {
                        Module.ccall(
                            'emLoadMarkdownFromJS',
                            null,
                            ['string'],
                            [gistMarkdown],
                            { async: false }
                        );
                        console.log('=== Successfully loaded content via ccall ===');
                        Module.setStatus('');
                    } else if (typeof Module._emLoadMarkdownFromJS === 'function') {
                        // Fallback: manually allocate string in WASM memory
                        console.log('Using manual string allocation');
                        var len = Module.lengthBytesUTF8(gistMarkdown) + 1;
                        var strPtr = Module._malloc(len);
                        Module.stringToUTF8(gistMarkdown, strPtr, len);
                        Module._emLoadMarkdownFromJS(strPtr);
                        Module._free(strPtr);
                        console.log('=== Successfully loaded content via manual allocation ===');
                        Module.setStatus('');
                    } else {
                        console.error('Module.ccall and Module._emLoadMarkdownFromJS not available');
                        progress.textContent = 'Error: Load function not available';
                    }
                } catch (e) {
                    console.error('Error loading markdown:', e);
                    progress.textContent = 'Error loading content: ' + e.message;
                }
            }
        }
        
        // Set up URL parameter store BEFORE Module loads
        // This must be available when WASM initializes
        // Use quoted property access to prevent Closure Compiler mangling
        window['urlParamStore'] = {};
        const specialParams = ['gist', 'demo', 'font', 'shader'];
        for (const [key, value] of urlParams.entries()) {
            if (!specialParams.includes(key)) {
                window['urlParamStore'][key] = value;
                console.log('Pre-initialized URL param:', key, '=', value);
            }
        }
        
        // Provide getter function for Nim to call (MUST exist before WASM loads)
        window['jsGetUrlParam'] = function(name) {
            const value = window['urlParamStore'][name] || '';
            console.log('[JS] jsGetUrlParam(' + name + ') returning:', value);
            return value;
        };
        
        var Module = {
            waitingForGist: (gistId || demoName) ? true : false,
            customFontFamily: window.customFontFamily || null,
            canvas: canvas,
            print: function(text) {
                console.log(text);
            },
            printErr: function(text) {
                console.error(text);
                progress.textContent = 'Error: ' + text;
            },
            setStatus: function(text) {
                if (text) {
                    progress.textContent = text;
                } else {
                    loading.classList.add('hidden');
                }
            },
            onRuntimeInitialized: async function() {
                moduleReady = true;
                
                // Set waiting flag if gist or demo is present (must be done before init)
                if (gistId || demoName) {
                    console.log('Setting wait flag for content before initialization');
                    try {
                        if (typeof Module._emSetWaitingForGist === 'function') {
                            Module._emSetWaitingForGist();
                        } else if (typeof Module.ccall === 'function') {
                            Module.ccall('emSetWaitingForGist', null, [], []);
                        }
                    } catch (e) {
                        console.error('Error calling emSetWaitingForGist:', e);
                    }
                }
                
                // Initialize tstorie (wait for it to complete)
                if (typeof inittstorie === 'function') {
                    await inittstorie();
                } else {
                    console.error('inittstorie function not found. Make sure tstorie.js is loaded.');
                }
                
                // Initialize shader system if shader is loaded
                if (shaderGistId && shaderReady) {
                    initShaderSystem();
                }
                
                // Try loading content if it's ready
                if (gistId || demoName) {
                    tryLoadGist();
                } else {
                    Module.setStatus('');
                }
            }
        };
        
        // Fetch gist if specified
        if (gistId) {
            progress.textContent = 'Loading gist ' + gistId + '...';
            
            fetch('https://api.github.com/gists/' + gistId)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Gist not found (HTTP ' + response.status + ')');
                    }
                    return response.json();
                })
                .then(function(gist) {
                    // Find first .md file in gist
                    var mdFile = null;
                    for (var filename in gist.files) {
                        if (filename.endsWith('.md')) {
                            mdFile = gist.files[filename];
                            break;
                        }
                    }
                    
                    if (mdFile) {
                        console.log('Found markdown file in gist:', mdFile.filename, '(' + mdFile.content.length + ' bytes)');
                        gistMarkdown = mdFile.content;
                        gistReady = true;
                        progress.textContent = 'Loaded ' + mdFile.filename + ', starting...';
                        
                        // Try loading gist if module is ready
                        tryLoadGist();
                    } else {
                        throw new Error('No .md file found in gist');
                    }
                })
                .catch(function(error) {
                    console.error('Error loading gist:', error);
                    progress.textContent = 'Error: ' + error.message;
                    gistMarkdown = null;
                });
        }
        
        // Fetch demo from local server if specified
        if (demoName) {
            progress.textContent = 'Loading demo ' + demoName + '...';
            
            // Add .md extension if not present
            var demoFile = demoName.endsWith('.md') ? demoName : demoName + '.md';
            var demoUrl = 'demos/' + demoFile;
            
            fetch(demoUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Demo not found (HTTP ' + response.status + ')');
                    }
                    return response.text();
                })
                .then(function(content) {
                    console.log('Loaded demo file:', demoFile, '(' + content.length + ' bytes)');
                    gistMarkdown = content;
                    gistReady = true;
                    progress.textContent = 'Loaded ' + demoFile + ', starting...';
                    
                    // Try loading demo if module is ready
                    tryLoadGist();
                })
                .catch(function(error) {
                    console.error('Error loading demo:', error);
                    progress.textContent = 'Error loading demo: ' + error.message;
                    gistMarkdown = null;
                });
        }
        
        // Fetch shader if specified
        if (shaderGistId) {
            progress.textContent = 'Loading shader ' + shaderGistId + '...';
            
            fetch('https://api.github.com/gists/' + shaderGistId)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Shader gist not found (HTTP ' + response.status + ')');
                    }
                    return response.json();
                })
                .then(function(gist) {
                    // Find first .js file in gist
                    var jsFile = null;
                    for (var filename in gist.files) {
                        if (filename.endsWith('.js')) {
                            jsFile = gist.files[filename];
                            break;
                        }
                    }
                    
                    if (jsFile) {
                        console.log('Found shader file in gist:', jsFile.filename);
                        shaderCode = jsFile.content;
                        shaderReady = true;
                        progress.textContent = 'Loaded shader ' + jsFile.filename;
                        
                        // Initialize shader system if module is ready
                        if (moduleReady) {
                            initShaderSystem();
                        }
                    } else {
                        throw new Error('No .js file found in shader gist');
                    }
                })
                .catch(function(error) {
                    console.error('Error loading shader:', error);
                    progress.textContent = 'Shader error: ' + error.message;
                    shaderCode = null;
                });
        }
        
        console.log('Load from gist with URL parameter: ?gist=YOUR_GIST_ID');
        console.log('Load local demo with URL parameter: ?demo=demo_name (or ?demo=demo_name.md)');
        console.log('Use custom font with: ?font=Font+Name or ?font=FULL_GOOGLE_FONTS_URL');
        console.log('Apply shader effect with: ?shader=SHADER_GIST_ID');
    </script>
    
    <!-- Shader system -->
    <script>
        let shaderSystem = null;
        
        function initShaderSystem() {
            if (!shaderCode || !canvas) {
                console.log('Cannot init shader system - missing code or canvas');
                return;
            }
            
            try {
                console.log('Initializing shader system...');
                
                // Store original terminal canvas reference
                const terminalCanvas = canvas;
                
                // Get actual rendered dimensions
                const width = terminalCanvas.width || 800;
                const height = terminalCanvas.height || 600;
                
                console.log('Terminal dimensions:', width, 'x', height);
                
                // Keep terminal rendering to its original canvas
                // We'll sample from it each frame
                
                // Create new WebGL canvas for shader output
                const webglCanvas = document.createElement('canvas');
                webglCanvas.id = 'terminal-webgl';
                webglCanvas.width = width;
                webglCanvas.height = height;
                webglCanvas.className = terminalCanvas.className;
                webglCanvas.style.cssText = terminalCanvas.style.cssText;
                webglCanvas.style.outline = 'none';  // Ensure outline is disabled
                webglCanvas.tabIndex = terminalCanvas.tabIndex || 0;
                
                // Hide terminal canvas but keep it rendering
                terminalCanvas.style.display = 'none';
                
                // Insert WebGL canvas after terminal canvas
                terminalCanvas.parentNode.insertBefore(webglCanvas, terminalCanvas.nextSibling);
                
                // Forward input events from WebGL canvas to terminal canvas
                ['keydown', 'keyup', 'keypress', 'mousedown', 'mouseup', 'mousemove', 'click'].forEach(eventType => {
                    webglCanvas.addEventListener(eventType, function(e) {
                        const clonedEvent = new e.constructor(e.type, e);
                        terminalCanvas.dispatchEvent(clonedEvent);
                    });
                });
                
                // Function to sync WebGL canvas dimensions from terminal canvas
                function syncCanvasDimensions() {
                    const newWidth = terminalCanvas.width;
                    const newHeight = terminalCanvas.height;
                    const newStyleWidth = terminalCanvas.style.width;
                    const newStyleHeight = terminalCanvas.style.height;
                    
                    // Always sync both buffer size and style dimensions together
                    if (webglCanvas.width !== newWidth || webglCanvas.height !== newHeight ||
                        webglCanvas.style.width !== newStyleWidth || webglCanvas.style.height !== newStyleHeight) {
                        webglCanvas.width = newWidth;
                        webglCanvas.height = newHeight;
                        webglCanvas.style.width = newStyleWidth;
                        webglCanvas.style.height = newStyleHeight;
                        console.log('Synced shader canvas size:', newWidth, 'x', newHeight, 'style:', newStyleWidth, 'x', newStyleHeight);
                        
                        // Force viewport update on next render
                        if (shaderSystem && shaderSystem.gl) {
                            shaderSystem.gl.viewport(0, 0, newWidth, newHeight);
                        }
                    }
                }
                
                // Watch for terminal canvas size changes and sync to WebGL canvas
                const resizeObserver = new ResizeObserver(entries => {
                    for (const entry of entries) {
                        if (entry.target === terminalCanvas) {
                            // Use requestAnimationFrame to ensure terminal canvas properties are updated
                            requestAnimationFrame(syncCanvasDimensions);
                        }
                    }
                });
                resizeObserver.observe(terminalCanvas);
                
                // Also listen to window resize to catch any missed updates
                window.addEventListener('resize', () => {
                    // Double-delay to ensure terminal has processed the resize
                    requestAnimationFrame(() => {
                        requestAnimationFrame(syncCanvasDimensions);
                    });
                });
                
                // Update canvas reference for shader rendering
                canvas = webglCanvas;
                
                // Evaluate shader code (should define getShaderConfig())
                eval(shaderCode);
                
                if (typeof getShaderConfig !== 'function') {
                    throw new Error('Shader must export getShaderConfig() function');
                }
                
                const config = getShaderConfig();
                if (!config.vertexShader || !config.fragmentShader) {
                    throw new Error('Shader config must include vertexShader and fragmentShader');
                }
                
                // Create WebGL context from new canvas
                const gl = webglCanvas.getContext('webgl') || webglCanvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL not supported');
                }
                
                // Compile shaders
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, config.vertexShader);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, config.fragmentShader);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Shader program link failed: ' + gl.getProgramInfoLog(program));
                }
                
                // Create fullscreen quad
                const positions = new Float32Array([
                    -1, -1,  1, -1,  -1, 1,
                    -1, 1,   1, -1,   1, 1
                ]);
                
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Create texture for terminal canvas
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                
                // Get attribute and uniform locations
                const posLocation = gl.getAttribLocation(program, 'position');
                const timeLocation = gl.getUniformLocation(program, 'time');
                const resolutionLocation = gl.getUniformLocation(program, 'resolution');
                const textureLocation = gl.getUniformLocation(program, 'contentTexture');
                
                // Get custom uniform locations if defined
                const customUniforms = config.uniforms || {};
                const uniformLocations = {};
                for (const name in customUniforms) {
                    uniformLocations[name] = gl.getUniformLocation(program, name);
                }
                
                const startTime = Date.now();
                
                shaderSystem = {
                    gl: gl,
                    program: program,
                    terminalCanvas: terminalCanvas,
                    visibleCanvas: webglCanvas,
                    texture: texture,
                    posBuffer: posBuffer,
                    posLocation: posLocation,
                    timeLocation: timeLocation,
                    resolutionLocation: resolutionLocation,
                    textureLocation: textureLocation,
                    uniformLocations: uniformLocations,
                    customUniforms: customUniforms,
                    startTime: startTime,
                    animationId: null,
                    
                    render: function() {
                        // Update texture from terminal canvas (which is still rendering)
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, terminalCanvas);
                        
                        // Set viewport to match canvas
                        gl.viewport(0, 0, webglCanvas.width, webglCanvas.height);
                        
                        // Use shader program
                        gl.useProgram(program);
                        
                        // Set uniforms
                        const time = (Date.now() - startTime) / 1000.0;
                        gl.uniform1f(timeLocation, time);
                        gl.uniform2f(resolutionLocation, webglCanvas.width, webglCanvas.height);
                        gl.uniform1i(textureLocation, 0);
                        
                        // Set custom uniforms
                        for (const name in customUniforms) {
                            const value = customUniforms[name];
                            const location = uniformLocations[name];
                            if (location) {
                                if (typeof value === 'number') {
                                    gl.uniform1f(location, value);
                                } else if (Array.isArray(value)) {
                                    if (value.length === 2) {
                                        gl.uniform2f(location, value[0], value[1]);
                                    } else if (value.length === 3) {
                                        gl.uniform3f(location, value[0], value[1], value[2]);
                                    } else if (value.length === 4) {
                                        gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                                    }
                                }
                            }
                        }
                        
                        // Draw fullscreen quad
                        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                        gl.enableVertexAttribArray(posLocation);
                        gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);
                        
                        gl.drawArrays(gl.TRIANGLES, 0, 6);
                        
                        // Continue render loop
                        this.animationId = requestAnimationFrame(() => this.render());
                    }
                };
                
                // Start continuous render loop
                shaderSystem.render();
                
                console.log('Shader system initialized successfully');
                progress.textContent = '';
            } catch (e) {
                console.error('Failed to initialize shader system:', e);
                progress.textContent = 'Shader initialization error: ' + e.message;
            }
        }
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const info = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error('Shader compile failed: ' + info);
            }
            
            return shader;
        }
    </script>
    
    <!-- Load our terminal interface first -->
    <script src="tstorie.js"></script>
    
    <!-- Then load the WASM module -->
    <script src="tstorie.wasm.js" onerror="document.getElementById('container').innerHTML = '<div class=\'error\'><h2>Failed to load WASM module</h2><p>Make sure tstorie.wasm.js exists in the same directory.</p></div>';"></script>
</body>
</html>