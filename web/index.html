<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Favicons for cross-platform support -->
    <link rel="icon" type="image/png" sizes="16x16" href="./assets/favicons/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./assets/favicons/favicon-32x32.png">
    <link rel="icon" type="image/x-icon" href="./assets/favicons/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="./assets/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="./assets/favicons/android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="./assets/favicons/android-chrome-512x512.png">
    <link rel="manifest" href="./assets/favicons/site.webmanifest">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>t|Storie Í≠≤Í≠ºÍ≠±ÍÆáÍÆñÍÆëÍ≠∫ÍÆÆ Í≠ºÍÆë·èΩÍÆñÍÆëÍ≠º</title>
    <style>
        @font-face {
            font-family: '3270-Regular';
            src: url('./assets/3270-Regular.ttf') format('truetype');
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        body {
            background: #001111;
            font-family: '3270-Regular', 'Consolas', 'Monaco', monospace;
        }
        
        body.custom-font {
            font-family: var(--custom-font-family), '3270-Regular', 'Consolas', 'Monaco', monospace;
        }
        
        #container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        #terminal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            display: block;
            margin: 0 !important;
            padding: 0 !important;
            border: 0;
            background: #001111;
            outline: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            font-smooth: never;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
            font-family: '3270-Regular', 'Consolas', 'Monaco', monospace;
            object-fit: fill;
        }
        
        #terminal.custom-font {
            font-family: var(--custom-font-family), '3270-Regular', 'Consolas', 'Monaco', monospace;
        }
        
        #loading {
            position: absolute;
            color: #999;
            font-size: 16px;
            text-align: center;
            z-index: 10;
        }

        #cursor {
            color: #fff;
            display: inline-block;
            width: 10px;
            animation: blink 1s steps(2, start) infinite;
        }

        #t {
            color: #00d98e;
        }
        
        @keyframes blink {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0;
            }
        }
        
        #loading.hidden {
            display: none;
        }
        
        .error {
            color: #f00;
            background: #300;
            padding: 20px;
            border: 2px solid #f00;
            max-width: 600px;
            margin: 20px;
        }
        
        /* Settings Panel Styles */
        #settings-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 20, 20, 0.9);
            border: 2px solid #00d98e;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        #settings-toggle:hover {
            background: rgba(0, 40, 40, 0.95);
            transform: rotate(90deg);
        }
        
        #settings-toggle svg {
            width: 24px;
            height: 24px;
            fill: #00d98e;
        }
        
        #settings-panel {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 360px;
            max-height: 90vh;
            background: rgba(0, 20, 20, 0.98);
            border: 2px solid #00d98e;
            border-radius: 8px;
            padding: 20px;
            z-index: 999;
            display: none;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 217, 142, 0.2);
            font-family: '3270-Regular', 'Consolas', 'Monaco', monospace;
            color: #00d98e;
        }
        
        #settings-panel.visible {
            display: block;
        }
        
        #settings-panel h2 {
            margin: 0 0 20px 0;
            font-size: 20px;
            color: #00d98e;
            border-bottom: 1px solid #00d98e;
            padding-bottom: 10px;
        }
        
        .setting-group {
            margin-bottom: 20px;
        }
        
        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            color: #00d98e;
            font-weight: bold;
        }
        
        .setting-group input[type="text"],
        .setting-group input[type="range"],
        .setting-group select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 40, 40, 0.8);
            border: 1px solid #00d98e;
            border-radius: 4px;
            color: #00d98e;
            font-family: '3270-Regular', 'Consolas', 'Monaco', monospace;
            font-size: 13px;
        }
        
        .setting-group input[type="text"]:focus,
        .setting-group select:focus {
            outline: none;
            border-color: #00ffaa;
            box-shadow: 0 0 8px rgba(0, 217, 142, 0.3);
        }
        
        .setting-group input[type="range"] {
            cursor: pointer;
        }
        
        .range-value {
            display: inline-block;
            margin-left: 10px;
            font-size: 14px;
            color: #00ffaa;
        }
        
        .shader-checkbox-group {
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 40, 40, 0.5);
            border: 1px solid #00d98e;
            border-radius: 4px;
            padding: 10px;
        }
        
        .shader-checkbox-group label {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-weight: normal;
            cursor: pointer;
            font-size: 13px;
        }
        
        .shader-checkbox-group input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }
        
        .setting-hint {
            font-size: 11px;
            color: #00d98e80;
            margin-top: 4px;
            font-style: italic;
        }
        
        .settings-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .settings-buttons button {
            flex: 1;
            padding: 10px;
            background: rgba(0, 217, 142, 0.2);
            border: 1px solid #00d98e;
            border-radius: 4px;
            color: #00d98e;
            font-family: '3270-Regular', 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .settings-buttons button:hover {
            background: rgba(0, 217, 142, 0.4);
            border-color: #00ffaa;
        }
        
        .settings-buttons button.primary {
            background: rgba(0, 217, 142, 0.3);
        }
        
        .settings-buttons button.primary:hover {
            background: rgba(0, 217, 142, 0.5);
        }
        
        /* Drag-and-Drop Overlay */
        #drop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 217, 142, 0.15);
            border: 4px dashed #00d98e;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            pointer-events: none;
        }
        
        #drop-overlay.drag-active {
            display: flex;
        }
        
        #drop-overlay-text {
            font-size: 32px;
            color: #00d98e;
            text-align: center;
            text-shadow: 0 0 20px rgba(0, 217, 142, 0.8);
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        
        #drop-status {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 20, 20, 0.95);
            border: 2px solid #00d98e;
            border-radius: 6px;
            padding: 12px 24px;
            color: #00d98e;
            font-size: 14px;
            z-index: 2001;
            display: none;
            box-shadow: 0 4px 16px rgba(0, 217, 142, 0.3);
        }
        
        #drop-status.visible {
            display: block;
        }
        
        #drop-status.error {
            border-color: #ff4444;
            color: #ff4444;
        }
    </style>
</head>
<body>
    <!-- Settings Toggle Button -->
    <button id="settings-toggle" title="Settings">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
            <path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65z"/>
        </svg>
    </button>
    
    <!-- Settings Panel -->
    <div id="settings-panel">
        <h2>‚öô t|Storie Settings</h2>
        
        <div class="setting-group">
            <label for="fontsize-slider">Font Size: <span class="range-value" id="fontsize-value">16</span>px</label>
            <input type="range" id="fontsize-slider" min="8" max="32" value="16" step="1">
            <div class="setting-hint">Adjust terminal font size (8-32px)</div>
        </div>
        
        <div class="setting-group">
            <label>Shaders (select multiple):</label>
            <div class="shader-checkbox-group" id="shader-checkboxes">
                <label><input type="checkbox" value="bloom"> bloom</label>
                <label><input type="checkbox" value="blur"> blur</label>
                <label><input type="checkbox" value="crt"> crt</label>
                <label><input type="checkbox" value="crtbloom"> crtbloom</label>
                <label><input type="checkbox" value="graphpaper"> graphpaper</label>
                <label><input type="checkbox" value="invert"> invert</label>
                <label><input type="checkbox" value="notebook"> notebook</label>
            </div>
            <div class="setting-hint">Combine multiple shaders for unique effects</div>
        </div>
        
        <div class="setting-group">
            <label for="theme-select">Theme:</label>
            <select id="theme-select">
                <option value="">Default</option>
                <option value="catppuccin">Catppuccin</option>
                <option value="nord">Nord</option>
                <option value="dracula">Dracula</option>
                <option value="miami-vice">Miami Vice</option>
                <option value="outrun">Outrun</option>
                <option value="cyberpunk">Cyberpunk</option>
                <option value="terminal">Terminal</option>
                <option value="solarized-dark">Solarized Dark</option>
                <option value="neotopia">Neotopia</option>
                <option value="coffee">Coffee</option>
            </select>
            <div class="setting-hint">Color scheme for the terminal</div>
        </div>
        
        <div class="setting-group">
            <label for="content-input">Content:</label>
            <input type="text" id="content-input" placeholder="gist:ID, demo:name, browser:key, decode:xxx">
            <div class="setting-hint">Load content from various sources</div>
        </div>
        
        <div class="setting-group">
            <label for="font-input">Custom Font:</label>
            <input type="text" id="font-input" placeholder="Font name or Google Fonts URL">
            <div class="setting-hint">e.g., "Roboto+Mono" or full URL</div>
        </div>
        
        <div class="settings-buttons">
            <button id="reset-button">Reset</button>
            <button id="apply-button" class="primary">Apply & Reload</button>
        </div>
    </div>
    
    <!-- Drag-and-Drop Overlay -->
    <div id="drop-overlay">
        <div id="drop-overlay-text">
            üìÑ Drop .md or .png file here
        </div>
    </div>
    
    <!-- Drop Status Message -->
    <div id="drop-status"></div>
    
    <div id="container">
        <div id="loading">
            <div>Loading <span id="t">t</span><span id="cursor">|</span>Storie...</div>
            <div id="progress"></div>
        </div>
        <canvas id="terminal" tabindex="0"></canvas>
    </div>
    
    <script>
        // ===== SETTINGS PANEL LOGIC =====
        const settingsToggle = document.getElementById('settings-toggle');
        const settingsPanel = document.getElementById('settings-panel');
        const fontsizeSlider = document.getElementById('fontsize-slider');
        const fontsizeValue = document.getElementById('fontsize-value');
        const shaderCheckboxes = document.querySelectorAll('#shader-checkboxes input[type="checkbox"]');
        const themeSelect = document.getElementById('theme-select');
        const contentInput = document.getElementById('content-input');
        const fontInput = document.getElementById('font-input');
        const applyButton = document.getElementById('apply-button');
        const resetButton = document.getElementById('reset-button');
        
        // Toggle settings panel
        settingsToggle.addEventListener('click', function() {
            settingsPanel.classList.toggle('visible');
        });
        
        // Close panel when clicking outside
        document.addEventListener('click', function(e) {
            if (!settingsPanel.contains(e.target) && !settingsToggle.contains(e.target)) {
                settingsPanel.classList.remove('visible');
            }
        });
        
        // Update fontsize display
        fontsizeSlider.addEventListener('input', function() {
            fontsizeValue.textContent = this.value;
        });
        
        // Parse current URL parameters and populate form
        function loadCurrentSettings() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Font size
            const fontsize = urlParams.get('fontsize');
            if (fontsize) {
                fontsizeSlider.value = fontsize;
                fontsizeValue.textContent = fontsize;
            }
            
            // Shaders
            const shaderParam = urlParams.get('shader');
            if (shaderParam) {
                const activeShaders = shaderParam.split(/\s+/).map(s => s.trim()).filter(s => s);
                shaderCheckboxes.forEach(checkbox => {
                    checkbox.checked = activeShaders.includes(checkbox.value);
                });
            }
            
            // Theme
            const theme = urlParams.get('theme');
            if (theme) {
                themeSelect.value = theme;
            }
            
            // Content
            const content = urlParams.get('content');
            if (content) {
                contentInput.value = content;
            }
            
            // Font
            const font = urlParams.get('font');
            if (font) {
                fontInput.value = font;
            }
        }
        
        // Apply settings and reload
        applyButton.addEventListener('click', function() {
            const newParams = new URLSearchParams();
            
            // Font size
            const fontsize = fontsizeSlider.value;
            if (fontsize && fontsize !== '16') {  // Only add if not default
                newParams.set('fontsize', fontsize);
            }
            
            // Shaders
            const selectedShaders = Array.from(shaderCheckboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);
            if (selectedShaders.length > 0) {
                newParams.set('shader', selectedShaders.join(' '));
            }
            
            // Theme
            const theme = themeSelect.value;
            if (theme) {
                newParams.set('theme', theme);
            }
            
            // Content
            const content = contentInput.value.trim();
            if (content) {
                newParams.set('content', content);
            }
            
            // Font
            const font = fontInput.value.trim();
            if (font) {
                newParams.set('font', font);
            }
            
            // Build new URL and reload
            const newUrl = window.location.pathname + (newParams.toString() ? '?' + newParams.toString() : '');
            window.location.href = newUrl;
        });
        
        // Reset to defaults
        resetButton.addEventListener('click', function() {
            if (confirm('Reset all settings to defaults?')) {
                window.location.href = window.location.pathname;
            }
        });
        
        // Reposition panel on window resize
        function repositionPanel() {
            // Panel is already positioned with CSS, but we could add logic here if needed
            // For now, CSS fixed positioning handles this automatically
        }
        
        window.addEventListener('resize', repositionPanel);
        
        // Load current settings on page load
        loadCurrentSettings();
    </script>
    
    <script>
        // ===== DRAG-AND-DROP FILE HANDLING =====
        (function() {
            const dropOverlay = document.getElementById('drop-overlay');
            const dropStatus = document.getElementById('drop-status');
            const container = document.getElementById('container');
            
            let dragCounter = 0;
            
            function showDropStatus(message, isError = false) {
                dropStatus.textContent = message;
                dropStatus.className = 'visible' + (isError ? ' error' : '');
                
                if (!isError) {
                    setTimeout(() => {
                        dropStatus.classList.remove('visible');
                    }, 3000);
                }
            }
            
            // Prevent default drag behaviors on the whole document
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.body.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, false);
            });
            
            // Show overlay when dragging over
            document.body.addEventListener('dragenter', (e) => {
                dragCounter++;
                if (e.dataTransfer.items && e.dataTransfer.items.length > 0) {
                    dropOverlay.classList.add('drag-active');
                }
            });
            
            // Update overlay appearance
            document.body.addEventListener('dragover', (e) => {
                e.dataTransfer.dropEffect = 'copy';
            });
            
            // Hide overlay when dragging away
            document.body.addEventListener('dragleave', () => {
                dragCounter--;
                if (dragCounter === 0) {
                    dropOverlay.classList.remove('drag-active');
                }
            });
            
            // Handle dropped files
            document.body.addEventListener('drop', async (e) => {
                dragCounter = 0;
                dropOverlay.classList.remove('drag-active');
                
                const files = e.dataTransfer.files;
                if (files.length === 0) return;
                
                const file = files[0];
                
                // Check if we have a running app with dropTarget enabled
                let hasDropTarget = false;
                try {
                    if (window.Module && window.Module.ccall) {
                        hasDropTarget = window.Module.ccall('emCheckDropTarget', 'number', [], []) === 1;
                    }
                } catch (err) {
                    console.log('Could not check dropTarget:', err);
                }
                
                // If app wants drops, send to it regardless of file type
                if (hasDropTarget) {
                    await handleGenericFileDrop(file);
                    return;
                }
                
                // Otherwise use default behavior: load .md or .png files
                if (file.name.endsWith('.md')) {
                    await handleMarkdownFile(file);
                } else if (file.name.endsWith('.png')) {
                    await handlePNGFile(file);
                }
            });
            
            // Handle markdown files
            async function handleMarkdownFile(file) {
                try {
                    showDropStatus(`üìñ Loading ${file.name}...`, false);
                    
                    const content = await file.text();
                    
                    // Wait for Module to be ready
                    if (!window.Module || !window.Module.ccall) {
                        showDropStatus('‚è≥ Waiting for tStorie engine...', false);
                        
                        // Wait up to 10 seconds for Module to initialize
                        let attempts = 0;
                        while ((!window.Module || !window.Module.ccall) && attempts < 100) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            attempts++;
                        }
                        
                        if (!window.Module || !window.Module.ccall) {
                            throw new Error('tStorie engine not ready');
                        }
                    }
                    
                    // Load markdown into tStorie
                    console.log('Loading markdown via drag-and-drop:', file.name, content.length, 'bytes');
                    
                    if (window.Module.ccall) {
                        window.Module.ccall(
                            'emLoadMarkdownFromJS',
                            null,
                            ['string'],
                            [content],
                            { async: false }
                        );
                        showDropStatus(`‚úì Loaded ${file.name}`, false);
                    } else {
                        throw new Error('Module not ready');
                    }
                    
                } catch (error) {
                    console.error('Failed to load markdown file:', error);
                    showDropStatus(`‚ùå Error: ${error.message}`, true);
                }
            }
            
            // Handle PNG files with embedded workflows
            async function handlePNGFile(file) {
                try {
                    showDropStatus(`üñºÔ∏è Extracting workflow from ${file.name}...`, false);
                    
                    // Use existing extractWorkflowFromPNG function
                    const content = await extractWorkflowFromPNG(file);
                    
                    if (!content) {
                        showDropStatus('‚ùå No workflow found in PNG', true);
                        return;
                    }
                    
                    // Wait for Module to be ready
                    if (!window.Module || !window.Module.ccall) {
                        showDropStatus('‚è≥ Waiting for tStorie engine...', false);
                        
                        let attempts = 0;
                        while ((!window.Module || !window.Module.ccall) && attempts < 100) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            attempts++;
                        }
                        
                        if (!window.Module || !window.Module.ccall) {
                            throw new Error('tStorie engine not ready');
                        }
                    }
                    
                    // Load extracted workflow
                    console.log('Loading workflow from PNG via drag-and-drop:', file.name, content.length, 'bytes');
                    
                    if (window.Module.ccall) {
                        window.Module.ccall(
                            'emLoadMarkdownFromJS',
                            null,
                            ['string'],
                            [content],
                            { async: false }
                        );
                        showDropStatus(`‚úì Loaded workflow from ${file.name}`, false);
                    } else {
                        throw new Error('Module not ready');
                    }
                    
                } catch (error) {
                    console.error('Failed to load PNG file:', error);
                    showDropStatus(`‚ùå Error: ${error.message}`, true);
                }
            }
            
            // Handle generic file drops for apps with dropTarget
            async function handleGenericFileDrop(file) {
                try {
                    showDropStatus(`üì¶ Processing ${file.name}...`, false);
                    
                    // Read file as ArrayBuffer
                    const arrayBuffer = await file.arrayBuffer();
                    const data = new Uint8Array(arrayBuffer);
                    
                    // Wait for Module to be ready
                    if (!window.Module || !window.Module.ccall) {
                        showDropStatus('‚è≥ Waiting for tStorie engine...', false);
                        
                        let attempts = 0;
                        while ((!window.Module || !window.Module.ccall) && attempts < 100) {
                            await new Promise(resolve => setTimeout(resolve, 100));
                            attempts++;
                        }
                        
                        if (!window.Module || !window.Module.ccall) {
                            throw new Error('tStorie engine not ready');
                        }
                    }
                    
                    // Pass to the running app via emHandleDroppedFile
                    console.log('Sending dropped file to app:', file.name, data.length, 'bytes');
                    
                    // Convert Uint8Array to binary string (each byte becomes a character code)
                    let binaryString = '';
                    for (let i = 0; i < data.length; i++) {
                        binaryString += String.fromCharCode(data[i]);
                    }
                    
                    window.Module.ccall(
                        'emHandleDroppedFile',
                        null,
                        ['string', 'string', 'number'],
                        [file.name, binaryString, data.length],
                        { async: false }
                    );
                    showDropStatus(`‚úì File sent to app: ${file.name}`, false);
                    
                } catch (error) {
                    console.error('Failed to handle file drop:', error);
                    showDropStatus(`‚ùå Error: ${error.message}`, true);
                }
            }
            
            console.log('‚úì Drag-and-drop initialized - you can now drop .md or .png files');
        })();
    </script>
    
    <script>
        // ===== MAIN APPLICATION LOGIC =====
        // Setup Module before loading WASM (Emscripten will merge with this)
        let canvas = document.getElementById('terminal');  // Use 'let' so we can replace it with WebGL canvas
        window.canvas = canvas;  // Store globally for shader system access
        const loading = document.getElementById('loading');
        const progress = document.getElementById('progress');
        const container = document.getElementById('container');
        
        // Expose terminal canvas globally for PNG export (will be updated if shader system is used)
        window.terminalCanvas = canvas;
        
        // Note: Canvas resizing is handled by the WebGL renderer's resize() method
        // which is called on window resize events and properly accounts for device pixel ratio
        
        // Compression/Decompression utilities for URL sharing
        async function compress(string) {
            const byteArray = new TextEncoder().encode(string);
            const stream = new CompressionStream('deflate-raw');
            const writer = stream.writable.getWriter();
            writer.write(byteArray);
            writer.close();
            const buffer = await new Response(stream.readable).arrayBuffer();
            return btoa(String.fromCharCode(...new Uint8Array(buffer)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        async function decompress(b64) {
            // Convert base64url to base64
            let base64 = b64.replace(/-/g, '+').replace(/_/g, '/');
            // Add padding
            while (base64.length % 4) {
                base64 += '=';
            }
            
            const binaryString = atob(base64);
            const byteArray = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                byteArray[i] = binaryString.charCodeAt(i);
            }
            
            const stream = new DecompressionStream('deflate-raw');
            const writer = stream.writable.getWriter();
            writer.write(byteArray);
            writer.close();
            const buffer = await new Response(stream.readable).arrayBuffer();
            return new TextDecoder().decode(buffer);
        }
        
        // ===== PNG CHUNK MANIPULATION (ComfyUI-style workflow sharing) =====
        // Zero-dependency PNG metadata embedding for storing workflows in screenshots
        
        // CRC32 calculation for PNG chunks
        function calculateCRC32(data) {
            let crc = 0xFFFFFFFF;
            const crcTable = new Uint32Array(256);
            
            // Build CRC table
            for (let n = 0; n < 256; n++) {
                let c = n;
                for (let k = 0; k < 8; k++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                crcTable[n] = c;
            }
            
            // Calculate CRC
            for (let i = 0; i < data.length; i++) {
                crc = crcTable[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }
        
        // Create a PNG tEXt chunk with keyword and text
        function createPNGTextChunk(keyword, text) {
            const keywordBytes = new TextEncoder().encode(keyword);
            const textBytes = new TextEncoder().encode(text);
            
            // tEXt chunk: keyword + null byte + text
            const dataLength = keywordBytes.length + 1 + textBytes.length;
            const chunk = new Uint8Array(12 + dataLength); // length(4) + type(4) + data + crc(4)
            const view = new DataView(chunk.buffer);
            
            // Length (4 bytes)
            view.setUint32(0, dataLength, false); // big-endian
            
            // Type: "tEXt" (4 bytes)
            chunk[4] = 116; // 't'
            chunk[5] = 69;  // 'E'
            chunk[6] = 88;  // 'X'
            chunk[7] = 116; // 't'
            
            // Data: keyword + null + text
            chunk.set(keywordBytes, 8);
            chunk[8 + keywordBytes.length] = 0; // null separator
            chunk.set(textBytes, 9 + keywordBytes.length);
            
            // CRC (4 bytes) - calculated over type + data
            const crcData = chunk.subarray(4, 8 + dataLength);
            const crc = calculateCRC32(crcData);
            view.setUint32(8 + dataLength, crc, false);
            
            return chunk;
        }
        
        // Inject a chunk before the IEND chunk in PNG data
        function injectChunkBeforeIEND(pngData, newChunk) {
            // Find IEND chunk (last 12 bytes: length=0, "IEND", CRC)
            // Search backwards for IEND signature
            let iendPos = -1;
            for (let i = pngData.length - 12; i >= 8; i--) {
                if (pngData[i] === 73 && pngData[i+1] === 69 && 
                    pngData[i+2] === 78 && pngData[i+3] === 68) { // "IEND"
                    iendPos = i - 4; // Start of IEND chunk (length field)
                    break;
                }
            }
            
            if (iendPos === -1) {
                throw new Error('Invalid PNG: IEND chunk not found');
            }
            
            // Create new PNG with injected chunk
            const result = new Uint8Array(pngData.length + newChunk.length);
            result.set(pngData.subarray(0, iendPos), 0);
            result.set(newChunk, iendPos);
            result.set(pngData.subarray(iendPos), iendPos + newChunk.length);
            
            return result;
        }
        
        // Extract tEXt chunks from PNG data
        function extractPNGTextChunks(pngData) {
            const chunks = {};
            let pos = 8; // Skip PNG signature
            
            while (pos < pngData.length - 12) {
                const view = new DataView(pngData.buffer, pngData.byteOffset + pos);
                const length = view.getUint32(0, false); // big-endian
                
                // Read chunk type
                const type = String.fromCharCode(
                    pngData[pos + 4],
                    pngData[pos + 5],
                    pngData[pos + 6],
                    pngData[pos + 7]
                );
                
                // If it's a tEXt chunk, extract the data
                if (type === 'tEXt') {
                    const dataStart = pos + 8;
                    const dataEnd = dataStart + length;
                    const chunkData = pngData.subarray(dataStart, dataEnd);
                    
                    // Find null separator between keyword and text
                    let nullPos = 0;
                    while (nullPos < chunkData.length && chunkData[nullPos] !== 0) {
                        nullPos++;
                    }
                    
                    if (nullPos < chunkData.length) {
                        const keyword = new TextDecoder().decode(chunkData.subarray(0, nullPos));
                        const text = new TextDecoder().decode(chunkData.subarray(nullPos + 1));
                        chunks[keyword] = text;
                    }
                }
                
                // Stop at IEND
                if (type === 'IEND') break;
                
                // Move to next chunk: length(4) + type(4) + data(length) + crc(4)
                pos += 12 + length;
            }
            
            return chunks;
        }
        
        // Capture terminal canvas and embed workflow data as PNG
        async function captureTerminalToPNG(content) {
            // Get the terminal canvas (or fallback to visible canvas)
            const canvas = window.terminalCanvas || document.getElementById('terminal');
            if (!canvas) {
                throw new Error('Terminal canvas not found');
            }
            
            console.log('Capturing terminal canvas:', canvas.width, 'x', canvas.height);
            
            // Convert canvas to PNG blob
            const blob = await new Promise((resolve, reject) => {
                canvas.toBlob((b) => {
                    if (b) resolve(b);
                    else reject(new Error('Failed to capture canvas'));
                }, 'image/png');
            });
            
            // Read as ArrayBuffer
            const arrayBuffer = await blob.arrayBuffer();
            const pngData = new Uint8Array(arrayBuffer);
            
            // Compress the content
            const compressed = await compress(content);
            
            // Create tEXt chunk with workflow data
            const workflowChunk = createPNGTextChunk('tStorie-workflow', compressed);
            
            // Inject chunk into PNG
            const finalPNG = injectChunkBeforeIEND(pngData, workflowChunk);
            
            console.log('Created PNG with embedded workflow:', finalPNG.length, 'bytes');
            
            return new Blob([finalPNG], { type: 'image/png' });
        }
        
        // Extract workflow from PNG file
        async function extractWorkflowFromPNG(pngFile) {
            const arrayBuffer = await pngFile.arrayBuffer();
            const pngData = new Uint8Array(arrayBuffer);
            
            // Extract tEXt chunks
            const chunks = extractPNGTextChunks(pngData);
            
            if (chunks['tStorie-workflow']) {
                // Decompress the workflow
                const content = await decompress(chunks['tStorie-workflow']);
                console.log('Extracted workflow from PNG:', content.length, 'bytes');
                return content;
            }
            
            return null;
        }
        
        // ===== TSTORIE EDITOR HELPER FUNCTIONS =====
        // These functions provide localStorage and URL sharing for the editor
        
        // Generic function callers for Nim interop
        window.tStorie_callFunction = function(funcName) {
            try {
                const func = window[funcName];
                if (typeof func === 'function') {
                    const result = func();
                    return String(result || '');
                }
                return '';
            } catch (e) {
                console.error('Error calling', funcName, ':', e);
                return '';
            }
        };
        
        window.tStorie_callFunctionWithArg = function(funcName, arg) {
            try {
                const func = window[funcName];
                if (typeof func === 'function') {
                    const result = func(arg);
                    return String(result || '');
                }
                return '';
            } catch (e) {
                console.error('Error calling', funcName, 'with arg:', e);
                return '';
            }
        };
        
        window.tStorie_callFunctionWith2Args = function(funcName, arg1, arg2) {
            try {
                const func = window[funcName];
                if (typeof func === 'function') {
                    const result = func(arg1, arg2);
                    return String(result || '');
                }
                return '';
            } catch (e) {
                console.error('Error calling', funcName, 'with 2 args:', e);
                return '';
            }
        };
        
        // Save to localStorage with tstorie_ prefix
        window.tStorie_saveLocal = function(key, content) {
            try {
                const storageKey = 'tstorie_' + key;
                localStorage.setItem(storageKey, content);
                console.log('Saved:', storageKey, '(' + content.length + ' bytes)');
                return true;
            } catch (e) {
                console.error('Save error:', e);
                return false;
            }
        };
        
        // Load from localStorage
        window.tStorie_loadLocal = function(key) {
            try {
                const storageKey = 'tstorie_' + key;
                const content = localStorage.getItem(storageKey);
                if (content) {
                    return content;
                }
                return localStorage.getItem(key) || '';  // Fallback to raw key
            } catch (e) {
                console.error('Load error:', e);
                return '';
            }
        };
        
        // List all saved documents as JSON string
        window.tStorie_listLocal = function() {
            const items = [];
            try {
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('tstorie_')) {
                        const name = key.substring(8);
                        const content = localStorage.getItem(key);
                        if (content) {
                            items.push({
                                key: name,
                                size: content.length,
                                preview: content.substring(0, 50)
                            });
                        }
                    }
                }
            } catch (e) {
                console.error('List error:', e);
            }
            return JSON.stringify(items);
        };
        
        // Delete from localStorage
        window.tStorie_deleteLocal = function(key) {
            try {
                localStorage.removeItem('tstorie_' + key);
                return true;
            } catch (e) {
                console.error('Delete error:', e);
                return false;
            }
        };
        
        // Copy text to clipboard
        window.tStorie_copyToClipboard = function(text) {
            try {
                navigator.clipboard.writeText(text).then(function() {
                    console.log('Copied to clipboard:', text.substring(0, 50) + '...');
                }).catch(function(e) {
                    console.error('Clipboard error:', e);
                });
                return true;
            } catch (e) {
                console.error('Clipboard error:', e);
                return false;
            }
        };
        
        // Paste text from clipboard (async operation, stores result)
        window.tStorie_pasteFromClipboard = function() {
            try {
                navigator.clipboard.readText().then(function(text) {
                    console.log('Pasted from clipboard:', text.substring(0, 50) + '...');
                    window.tStorie_lastPastedText = text;
                }).catch(function(e) {
                    console.error('Clipboard read error:', e);
                    window.tStorie_lastPastedText = '';
                });
                // Return last pasted text or empty if not available yet
                return window.tStorie_lastPastedText || '';
            } catch (e) {
                console.error('Clipboard error:', e);
                return '';
            }
        };
        
        // Compress content and return shareable URL (synchronous wrapper for async compress)
        window.tStorie_compressToUrl = function(content) {
            // Start async compression but return placeholder
            // The actual URL will be generated asynchronously
            compress(content).then(function(compressed) {
                const baseUrl = window.location.origin + window.location.pathname;
                const shareUrl = baseUrl + '?content=decode:' + compressed;
                console.log('Generated share URL (' + shareUrl.length + ' chars)');
                // Store it globally so it can be retrieved
                window.tStorie_lastShareUrl = shareUrl;
            }).catch(function(e) {
                console.error('Compression error:', e);
                window.tStorie_lastShareUrl = '';
            });
            // Return last generated URL or placeholder
            return window.tStorie_lastShareUrl || 'Generating...';
        };
        
        // Better async URL generation: triggers generation, copies to clipboard when ready
        // Returns immediately, sets window.tStorie_shareUrlReady flag when complete
        window.tStorie_generateAndCopyShareUrl = function(content) {
            window.tStorie_shareUrlReady = false;
            window.tStorie_lastShareUrl = '';
            
            compress(content).then(function(compressed) {
                const baseUrl = window.location.origin + window.location.pathname;
                const shareUrl = baseUrl + '?content=decode:' + compressed;
                console.log('Generated share URL (' + shareUrl.length + ' chars)');
                
                // Store URL
                window.tStorie_lastShareUrl = shareUrl;
                
                // Copy to clipboard
                return navigator.clipboard.writeText(shareUrl).then(function() {
                    console.log('‚úì URL copied to clipboard!');
                    window.tStorie_shareUrlReady = true;
                    window.tStorie_shareUrlCopied = true;
                }).catch(function(e) {
                    console.error('Clipboard error:', e);
                    window.tStorie_shareUrlReady = true;
                    window.tStorie_shareUrlCopied = false;
                });
            }).catch(function(e) {
                console.error('Compression error:', e);
                window.tStorie_lastShareUrl = '';
                window.tStorie_shareUrlReady = true;
                window.tStorie_shareUrlCopied = false;
            });
            
            return 'started';
        };
        
        // Check if share URL generation is complete
        window.tStorie_checkShareUrlReady = function() {
            return window.tStorie_shareUrlReady ? 'true' : 'false';
        };
        
        // Get the generated share URL
        window.tStorie_getShareUrl = function() {
            return window.tStorie_lastShareUrl || '';
        };
        
        // Check if URL was copied to clipboard
        window.tStorie_checkShareUrlCopied = function() {
            return window.tStorie_shareUrlCopied ? 'true' : 'false';
        };
        
        // ===== PNG WORKFLOW EXPORT/IMPORT (ComfyUI-style) =====
        
        // Export current content as PNG with embedded workflow
        window.tStorie_exportToPNG = function(content, filename) {
            window.tStorie_pngExportReady = false;
            window.tStorie_pngExportError = null;
            
            captureTerminalToPNG(content).then(function(blob) {
                // Trigger download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = (filename || 'tstorie-workflow') + '.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('‚úì PNG workflow exported:', a.download);
                window.tStorie_pngExportReady = true;
            }).catch(function(e) {
                console.error('PNG export error:', e);
                window.tStorie_pngExportError = e.message;
                window.tStorie_pngExportReady = true;
            });
            
            return 'started';
        };
        
        // Check if PNG export is complete
        window.tStorie_checkPngExportReady = function() {
            return window.tStorie_pngExportReady ? 'true' : 'false';
        };
        
        // Get PNG export error if any
        window.tStorie_getPngExportError = function() {
            return window.tStorie_pngExportError || '';
        };
        
        // Trigger file picker to load PNG workflow
        window.tStorie_importFromPNG = function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/png';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) {
                    window.tStorie_pngImportContent = null;
                    return;
                }
                
                extractWorkflowFromPNG(file).then(function(content) {
                    if (content) {
                        console.log('‚úì Workflow imported from PNG:', content.length, 'bytes');
                        window.tStorie_pngImportContent = content;
                    } else {
                        console.warn('No workflow found in PNG');
                        window.tStorie_pngImportContent = null;
                    }
                }).catch(function(e) {
                    console.error('PNG import error:', e);
                    window.tStorie_pngImportContent = null;
                });
            };
            
            input.click();
            return 'started';
        };
        
        // Get imported PNG workflow content (call after importFromPNG)
        window.tStorie_getPngImportContent = function() {
            const content = window.tStorie_pngImportContent;
            window.tStorie_pngImportContent = null; // Clear after reading
            return content || '';
        };
        
        // Check if PNG import has content ready
        window.tStorie_checkPngImportReady = function() {
            return window.tStorie_pngImportContent !== undefined ? 'true' : 'false';
        };
        
        // Navigate to URL
        window.tStorie_navigate = function(url) {
            try {
                window.location.href = url;
                return true;
            } catch (e) {
                console.error('Navigation error:', e);
                return false;
            }
        };
        
        // Helper function to generate shareable URL from content
        // Usage in console: generateShareableUrl("# My Story\n...")
        window.generateShareableUrl = async function(content) {
            try {
                const compressed = await compress(content);
                const baseUrl = window.location.origin + window.location.pathname;
                const shareUrl = baseUrl + '?content=decode:' + compressed;
                console.log('Shareable URL (' + shareUrl.length + ' chars):');
                console.log(shareUrl);
                console.log('\nOriginal size: ' + content.length + ' bytes');
                console.log('Compressed size: ' + compressed.length + ' bytes');
                console.log('Compression ratio: ' + (compressed.length / content.length * 100).toFixed(1) + '%');
                return shareUrl;
            } catch (e) {
                console.error('Error generating shareable URL:', e);
                return null;
            }
        };
        
        // Helper to copy the generated URL to clipboard
        window.copyShareableUrl = async function(content) {
            const url = await window.generateShareableUrl(content);
            if (url) {
                try {
                    await navigator.clipboard.writeText(url);
                    console.log('‚úì URL copied to clipboard!');
                    return url;
                } catch (e) {
                    console.error('Failed to copy to clipboard:', e);
                    console.log('Please copy the URL manually from above.');
                    return url;
                }
            }
            return null;
        };
        
        // Parse URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        
        // Parse unified content parameter
        // Supports: ?content=gist:ID, ?content=demo:name, ?content=browser:key, ?content=decode:xxx, ?content=https://gist.github.com/...
        const contentParam = urlParams.get('content');
        
        let gistId = null;
        let demoName = null;
        let localStorageKey = null;
        let compressedContent = null;
        
        // Parse unified content parameter
        if (contentParam) {
            console.log('Content parameter detected:', contentParam);
            
            // Check for decode: prefix (compressed content)
            if (contentParam.startsWith('decode:')) {
                compressedContent = contentParam.substring(7);
                console.log('Parsed as compressed content (' + compressedContent.length + ' chars)');
            }
            // Check for browser:/local: prefix (localStorage)
            else if (contentParam.startsWith('browser:') || contentParam.startsWith('local:')) {
                const prefix = contentParam.startsWith('browser:') ? 'browser:' : 'local:';
                localStorageKey = contentParam.substring(prefix.length);
                console.log('Parsed as localStorage key:', localStorageKey);
            }
            // Check for gist: prefix
            else if (contentParam.startsWith('gist:')) {
                gistId = contentParam.substring(5);
                console.log('Parsed as gist:', gistId);
            }
            // Check for demo: prefix
            else if (contentParam.startsWith('demo:')) {
                demoName = contentParam.substring(5);
                console.log('Parsed as demo:', demoName);
            }
            // Check for full GitHub gist URL
            else if (contentParam.includes('gist.github.com/')) {
                const gistMatch = contentParam.match(/gist\.github\.com\/(?:[^\/]+\/)?([a-f0-9]+)/);
                if (gistMatch) {
                    gistId = gistMatch[1];
                    console.log('Parsed gist ID from URL:', gistId);
                } else {
                    console.error('Could not parse gist ID from URL:', contentParam);
                }
            }
            // Check if it looks like a 32-char hex gist ID
            else if (/^[a-f0-9]{32}$/i.test(contentParam)) {
                gistId = contentParam;
                console.log('Detected as gist ID:', gistId);
            }
            // Default to demo if no prefix and doesn't look like gist ID
            else {
                demoName = contentParam;
                console.log('Defaulting to demo:', demoName);
            }
        }
        
        const fontUrl = urlParams.get('font');
        const fontSizeParam = urlParams.get('fontsize');
        const shaderParam = urlParams.get('shader');
        const themeParam = urlParams.get('theme');
        
        // Parse multiple shaders separated by '+' (which becomes space in URL params)
        // e.g., ?shader=invert+crt will load both invert and crt shaders
        const shaderNames = shaderParam ? shaderParam.split(/\s+/).map(s => s.trim()).filter(s => s) : [];
        
        // Gist/demo loading state
        let gistMarkdown = null;
        let moduleReady = false;
        let gistReady = false;
        let shaderCodes = [];  // Array of shader code objects: [{name, code}, ...]
        let shaderReady = false;
        
        // Load from localStorage if specified
        if (localStorageKey) {
            console.log('Loading from localStorage:', localStorageKey);
            try {
                // Try with tstorie_ prefix first
                let storedContent = localStorage.getItem('tstorie_' + localStorageKey);
                // Fall back to raw key if not found
                if (!storedContent) {
                    storedContent = localStorage.getItem(localStorageKey);
                }
                
                if (storedContent) {
                    console.log('Found content in localStorage (' + storedContent.length + ' bytes)');
                    gistMarkdown = storedContent;
                    gistReady = true;
                    progress.textContent = 'Loaded from browser storage';
                } else {
                    console.error('No content found in localStorage for key:', localStorageKey);
                    progress.textContent = 'Error: Content not found in browser storage';
                }
            } catch (e) {
                console.error('Error reading from localStorage:', e);
                progress.textContent = 'Error: Could not access browser storage';
            }
        }
        
        // Decompress content if specified
        if (compressedContent) {
            console.log('Decompressing content from URL...');
            progress.textContent = 'Decompressing content...';
            decompress(compressedContent)
                .then(function(decompressed) {
                    console.log('Successfully decompressed content (' + decompressed.length + ' bytes)');
                    gistMarkdown = decompressed;
                    gistReady = true;
                    progress.textContent = 'Decompressed content, starting...';
                    
                    // Try loading if module is ready
                    tryLoadGist();
                })
                .catch(function(error) {
                    console.error('Error decompressing content:', error);
                    progress.textContent = 'Error: Failed to decompress content';
                    gistMarkdown = null;
                });
        }
        
        if (gistId) {
            console.log('Loading gist:', gistId);
        }
        
        if (demoName) {
            console.log('Loading demo:', demoName);
        }
        
        // Load custom font if specified
        if (fontUrl) {
            console.log('Custom font parameter detected:', fontUrl);
            try {
                let actualUrl = fontUrl;
                let fontFamily = '';
                
                // Check if it's a full URL or just a font name
                if (fontUrl.startsWith('http://') || fontUrl.startsWith('https://')) {
                    // It's a full URL
                    const fontMatch = fontUrl.match(/family=([^:&]+)/);
                    if (fontMatch) {
                        fontFamily = fontMatch[1].replace(/\+/g, ' ');
                    }
                } else {
                    // It's just a font name, construct Google Fonts URL
                    fontFamily = fontUrl.replace(/-/g, ' ');
                    actualUrl = 'https://fonts.googleapis.com/css2?family=' + fontUrl.replace(/\s+/g, '+') + '&display=swap';
                }
                
                console.log('Loading font from:', actualUrl);
                const link = document.createElement('link');
                link.rel = 'stylesheet';
                link.href = actualUrl;
                document.head.appendChild(link);
                
                if (fontFamily) {
                    document.documentElement.style.setProperty('--custom-font-family', fontFamily);
                    document.body.classList.add('custom-font');
                    canvas.classList.add('custom-font');
                    // Store font family for TStorieTerminal to use
                    const fullFontFamily = "'" + fontFamily + "', '3270-Regular', 'Consolas', 'Monaco', monospace";
                    if (typeof Module !== 'undefined') {
                        Module.customFontFamily = fullFontFamily;
                    } else {
                        // Module not defined yet, we'll set it when defining Module
                        window.customFontFamily = fullFontFamily;
                    }
                    console.log('Applied custom font:', fontFamily);
                }
            } catch (e) {
                console.error('Error loading custom font:', e);
            }
        }
        
        // Parse and store custom font size if specified
        if (fontSizeParam) {
            console.log('Custom font size parameter detected:', fontSizeParam);
            try {
                const parsedSize = parseInt(fontSizeParam, 10);
                if (!isNaN(parsedSize) && parsedSize >= 8 && parsedSize <= 72) {
                    window.customFontSize = parsedSize;
                    console.log('Applied custom font size:', parsedSize, 'px');
                } else {
                    console.warn('Font size out of range (8-72):', parsedSize, '- using default');
                }
            } catch (e) {
                console.error('Error parsing font size:', e);
            }
        }
        
        function tryLoadGist() {
            // Only load if both module and gist are ready
            console.log('tryLoadGist called - moduleReady:', moduleReady, 'gistReady:', gistReady, 'hasMarkdown:', !!gistMarkdown);
            if (moduleReady && gistReady && gistMarkdown) {
                console.log('=== Loading markdown (' + gistMarkdown.length + ' bytes) ===');
                try {
                    if (typeof Module.ccall === 'function') {
                        Module.ccall(
                            'emLoadMarkdownFromJS',
                            null,
                            ['string'],
                            [gistMarkdown],
                            { async: false }
                        );
                        console.log('=== Successfully loaded content via ccall ===');
                        Module.setStatus('');
                    } else if (typeof Module._emLoadMarkdownFromJS === 'function') {
                        // Fallback: manually allocate string in WASM memory
                        console.log('Using manual string allocation');
                        var len = Module.lengthBytesUTF8(gistMarkdown) + 1;
                        var strPtr = Module._malloc(len);
                        Module.stringToUTF8(gistMarkdown, strPtr, len);
                        Module._emLoadMarkdownFromJS(strPtr);
                        Module._free(strPtr);
                        console.log('=== Successfully loaded content via manual allocation ===');
                        Module.setStatus('');
                    } else {
                        console.error('Module.ccall and Module._emLoadMarkdownFromJS not available');
                        progress.textContent = 'Error: Load function not available';
                    }
                } catch (e) {
                    console.error('Error loading markdown:', e);
                    progress.textContent = 'Error loading content: ' + e.message;
                }
            }
        }
        
        // Parse and store all URL parameters by calling into WASM
        // This must happen after Module is loaded but before initialization
        function parseAndStoreUrlParams() {
            if (!Module._emscripten_setParam_internal) {
                console.error('Module._emscripten_setParam_internal not found');
                return;
            }
            
            const specialParams = ['gist', 'demo', 'content', 'font', 'shader'];
            
            for (const [key, value] of urlParams.entries()) {
                if (!specialParams.includes(key)) {
                    try {
                        // Allocate strings in WASM memory and call Nim function
                        const keyLen = lengthBytesUTF8(key) + 1;
                        const keyPtr = Module._malloc(keyLen);
                        stringToUTF8(key, keyPtr, keyLen);
                        
                        const valueLen = lengthBytesUTF8(value) + 1;
                        const valuePtr = Module._malloc(valueLen);
                        stringToUTF8(value, valuePtr, valueLen);
                        
                        // Call the exported Nim function
                        Module._emscripten_setParam_internal(keyPtr, valuePtr);
                        
                        Module._free(keyPtr);
                        Module._free(valuePtr);
                    } catch (e) {
                        console.error('Error setting param', key, ':', e);
                    }
                }
            }
        }
        
        var Module = {
            waitingForGist: (gistId || demoName || localStorageKey || compressedContent) ? true : false,
            customFontFamily: window.customFontFamily || null,
            customFontSize: window.customFontSize || null,
            canvas: canvas,
            print: function(text) {
                console.log(text);
            },
            printErr: function(text) {
                console.error(text);
                progress.textContent = 'Error: ' + text;
            },
            setStatus: function(text) {
                if (text) {
                    progress.textContent = text;
                } else {
                    loading.classList.add('hidden');
                }
            },
            onRuntimeInitialized: async function() {
                moduleReady = true;
                
                // Parse URL parameters and store them in WASM (before initialization)
                console.log('Parsing URL parameters...');
                parseAndStoreUrlParams();
                
                // Set waiting flag if gist, demo, localStorage, or compressed content is present (must be done before init)
                if (gistId || demoName || localStorageKey || compressedContent) {
                    console.log('Setting wait flag for content before initialization');
                    try {
                        if (typeof Module._emSetWaitingForGist === 'function') {
                            Module._emSetWaitingForGist();
                        } else if (typeof Module.ccall === 'function') {
                            Module.ccall('emSetWaitingForGist', null, [], []);
                        }
                    } catch (e) {
                        console.error('Error calling emSetWaitingForGist:', e);
                    }
                }
                
                // Initialize tstorie (wait for it to complete)
                if (typeof inittstorie === 'function') {
                    await inittstorie();
                } else {
                    console.error('inittstorie function not found. Make sure tstorie-webgl.js is loaded.');
                }
                
                // Initialize shader system if shaders are loaded
                if (shaderNames.length > 0 && shaderReady) {
                    initShaderSystem();
                }
                
                // Try loading content if it's ready
                if (gistId || demoName || localStorageKey || compressedContent) {
                    tryLoadGist();
                } else {
                    Module.setStatus('');
                }
            }
        };
        
        // Fetch gist if specified
        if (gistId) {
            progress.textContent = 'Loading gist ' + gistId + '...';
            
            fetch('https://api.github.com/gists/' + gistId)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Gist not found (HTTP ' + response.status + ')');
                    }
                    return response.json();
                })
                .then(function(gist) {
                    // Find first .md file in gist
                    var mdFile = null;
                    for (var filename in gist.files) {
                        if (filename.endsWith('.md')) {
                            mdFile = gist.files[filename];
                            break;
                        }
                    }
                    
                    if (mdFile) {
                        console.log('Found markdown file in gist:', mdFile.filename, '(' + mdFile.content.length + ' bytes)');
                        gistMarkdown = mdFile.content;
                        gistReady = true;
                        progress.textContent = 'Loaded ' + mdFile.filename + ', starting...';
                        
                        // Try loading gist if module is ready
                        tryLoadGist();
                    } else {
                        throw new Error('No .md file found in gist');
                    }
                })
                .catch(function(error) {
                    console.error('Error loading gist:', error);
                    progress.textContent = 'Error: ' + error.message;
                    gistMarkdown = null;
                });
        }
        
        // Fetch demo from local server if specified
        if (demoName) {
            progress.textContent = 'Loading demo ' + demoName + '...';
            
            // Add .md extension if not present
            var demoFile = demoName.endsWith('.md') ? demoName : demoName + '.md';
            var demoUrl = 'demos/' + demoFile;
            
            fetch(demoUrl)
                .then(function(response) {
                    if (!response.ok) {
                        throw new Error('Demo not found (HTTP ' + response.status + ')');
                    }
                    return response.text();
                })
                .then(function(content) {
                    console.log('Loaded demo file:', demoFile, '(' + content.length + ' bytes)');
                    gistMarkdown = content;
                    gistReady = true;
                    progress.textContent = 'Loaded ' + demoFile + ', starting...';
                    
                    // Try loading demo if module is ready
                    tryLoadGist();
                })
                .catch(function(error) {
                    console.error('Error loading demo:', error);
                    progress.textContent = 'Error loading demo: ' + error.message;
                    gistMarkdown = null;
                });
        }
        
        // Function to load a single shader by name
        function loadSingleShader(shaderName) {
            return new Promise(function(resolve, reject) {
                var localShaderUrl = 'shaders/' + shaderName + '.js';
                console.log('Loading shader:', shaderName, 'from', localShaderUrl);
                
                fetch(localShaderUrl)
                    .then(function(response) {
                        if (!response.ok) {
                            // Local file not found, try loading from Gist
                            console.log('Local shader not found, trying Gist API for:', shaderName);
                            return fetch('https://api.github.com/gists/' + shaderName)
                                .then(function(gistResponse) {
                                    if (!gistResponse.ok) {
                                        throw new Error('Shader "' + shaderName + '" not found locally or in gist (HTTP ' + gistResponse.status + ')');
                                    }
                                    return gistResponse.json();
                                })
                                .then(function(gist) {
                                    // Find first .js file in gist
                                    var jsFile = null;
                                    for (var filename in gist.files) {
                                        if (filename.endsWith('.js')) {
                                            jsFile = gist.files[filename];
                                            break;
                                        }
                                    }
                                    
                                    if (jsFile) {
                                        console.log('Found shader file in gist:', jsFile.filename);
                                        return { name: shaderName, content: jsFile.content, source: 'gist', filename: jsFile.filename };
                                    } else {
                                        throw new Error('No .js file found in shader gist: ' + shaderName);
                                    }
                                });
                        } else {
                            // Local file found, return its content
                            return response.text().then(function(content) {
                                return { name: shaderName, content: content, source: 'local', filename: shaderName + '.js' };
                            });
                        }
                    })
                    .then(resolve)
                    .catch(reject);
            });
        }
        
        // Fetch all shaders if specified
        if (shaderNames.length > 0) {
            const shaderCountText = shaderNames.length === 1 ? '1 shader' : shaderNames.length + ' shaders';
            progress.textContent = 'Loading ' + shaderCountText + ': ' + shaderNames.join('+') + '...';
            console.log('Loading shader chain:', shaderNames);
            
            // Load all shaders in parallel
            Promise.all(shaderNames.map(loadSingleShader))
                .then(function(results) {
                    shaderCodes = results;
                    shaderReady = true;
                    
                    const sources = results.map(r => r.source).join(', ');
                    progress.textContent = 'Loaded ' + shaderCountText + ' from ' + sources;
                    console.log('All shaders loaded successfully:', results.map(r => r.name).join(' ‚Üí '));
                    
                    // Initialize shader system if module is ready
                    if (moduleReady) {
                        initShaderSystem();
                    }
                })
                .catch(function(error) {
                    console.error('Error loading shaders:', error);
                    progress.textContent = 'Shader error: ' + error.message;
                    shaderCodes = [];
                });
        }
    </script>
    
    <!-- Shader system -->
    <script>
        let shaderSystem = null;
        
        function initShaderSystem() {
            // Check window.shaderCodes which is set by front matter bridge
            const codes = window.shaderCodes || shaderCodes;
            if (!codes || codes.length === 0) {
                console.log('Cannot init shader system - no shader code loaded');
                console.log('  window.shaderCodes:', window.shaderCodes);
                console.log('  local shaderCodes:', shaderCodes);
                return;
            }
            
            let canvas = window.canvas || document.getElementById('terminal');
            if (!canvas) {
                console.log('Cannot init shader system - canvas not found');
                return;
            }
            
            try {
                console.log('Initializing multi-shader system with', codes.length, 'shader(s):', codes.map(s => s.name).join(' ‚Üí '));
                console.log('Canvas found:', canvas.id, canvas.width, 'x', canvas.height);
                
                // Store original terminal canvas reference
                const terminalCanvas = canvas;
                
                // Expose globally for PNG export
                window.terminalCanvas = terminalCanvas;
                
                // Get actual rendered dimensions from terminal
                const width = terminalCanvas.width || 800;
                const height = terminalCanvas.height || 600;
                
                console.log('Terminal dimensions:', width, 'x', height);
                
                // Keep terminal rendering to its original canvas
                // We'll sample from it each frame
                
                // Create new WebGL canvas for shader output - fill viewport to eliminate gaps
                const webglCanvas = document.createElement('canvas');
                webglCanvas.id = 'terminal-webgl';
                const dpr = window.devicePixelRatio || 1;
                webglCanvas.width = window.innerWidth * dpr;
                webglCanvas.height = window.innerHeight * dpr;
                webglCanvas.className = terminalCanvas.className;
                webglCanvas.style.position = 'absolute';
                webglCanvas.style.top = '0';
                webglCanvas.style.left = '0';
                webglCanvas.style.width = '100%';
                webglCanvas.style.height = '100%';
                webglCanvas.style.outline = 'none';
                webglCanvas.tabIndex = terminalCanvas.tabIndex || 0;
                
                // Hide terminal canvas but keep it rendering
                terminalCanvas.style.display = 'none';
                
                // Insert WebGL canvas after terminal canvas
                terminalCanvas.parentNode.insertBefore(webglCanvas, terminalCanvas.nextSibling);
                
                // Forward input events from WebGL canvas to terminal canvas
                ['keydown', 'keyup', 'keypress', 'mousedown', 'mouseup', 'mousemove', 'click'].forEach(eventType => {
                    webglCanvas.addEventListener(eventType, function(e) {
                        const clonedEvent = new e.constructor(e.type, e);
                        terminalCanvas.dispatchEvent(clonedEvent);
                    });
                });
                
                // Function to sync WebGL canvas dimensions - use viewport not terminal canvas
                function syncCanvasDimensions() {
                    const dpr = window.devicePixelRatio || 1;
                    const newWidth = window.innerWidth * dpr;
                    const newHeight = window.innerHeight * dpr;
                    
                    // Only resize if dimensions actually changed
                    if (webglCanvas.width !== newWidth || webglCanvas.height !== newHeight) {
                        webglCanvas.width = newWidth;
                        webglCanvas.height = newHeight;
                        console.log('Resized shader canvas to viewport:', newWidth, 'x', newHeight);
                        
                        // Force viewport update on next render
                        if (shaderSystem && shaderSystem.gl) {
                            shaderSystem.gl.viewport(0, 0, newWidth, newHeight);
                        }
                    }
                }
                
                // Watch for window resize events
                window.addEventListener('resize', () => {
                    requestAnimationFrame(syncCanvasDimensions);
                });
                
                // Update canvas reference for shader rendering
                canvas = webglCanvas;
                
                // Create WebGL context from new canvas
                const gl = webglCanvas.getContext('webgl') || webglCanvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL not supported');
                }
                
                // Compile all shader programs
                const shaderPrograms = [];
                
                for (let i = 0; i < codes.length; i++) {
                    const shaderInfo = codes[i];
                    console.log('Compiling shader', i + 1, '/', codes.length, ':', shaderInfo.name);
                    
                    // Create isolated scope for eval to avoid variable conflicts
                    const getShaderConfig = (function() {
                        eval(shaderInfo.content);
                        if (typeof getShaderConfig !== 'function') {
                            throw new Error('Shader "' + shaderInfo.name + '" must export getShaderConfig() function');
                        }
                        return getShaderConfig();
                    })();
                    
                    if (!getShaderConfig.vertexShader || !getShaderConfig.fragmentShader) {
                        throw new Error('Shader "' + shaderInfo.name + '" config must include vertexShader and fragmentShader');
                    }
                    
                    // For shaders after the first, remove Y-flip from vertex shader
                    // The first shader flips to read from terminal canvas correctly
                    // Subsequent shaders read from framebuffers that are already correctly oriented
                    let vertexShader = getShaderConfig.vertexShader;
                    if (i > 0) {
                        // Remove the Y-flip line
                        vertexShader = vertexShader.replace(/vUv\.y\s*=\s*1\.0\s*-\s*vUv\.y\s*;/g, '// Y-flip removed for chained shader');
                    }
                    
                    // Compile vertex and fragment shaders
                    const vertShader = createShader(gl, gl.VERTEX_SHADER, vertexShader);
                    const fragShader = createShader(gl, gl.FRAGMENT_SHADER, getShaderConfig.fragmentShader);
                    
                    const program = gl.createProgram();
                    gl.attachShader(program, vertShader);
                    gl.attachShader(program, fragShader);
                    gl.linkProgram(program);
                    
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        throw new Error('Shader "' + shaderInfo.name + '" program link failed: ' + gl.getProgramInfoLog(program));
                    }
                    
                    // Get attribute and uniform locations
                    const posLocation = gl.getAttribLocation(program, 'position');
                    const timeLocation = gl.getUniformLocation(program, 'time');
                    const resolutionLocation = gl.getUniformLocation(program, 'resolution');
                    const textureLocation = gl.getUniformLocation(program, 'contentTexture');
                    
                    // Get custom uniform locations
                    const customUniforms = getShaderConfig.uniforms || {};
                    const uniformLocations = {};
                    for (const name in customUniforms) {
                        uniformLocations[name] = gl.getUniformLocation(program, name);
                    }
                    
                    shaderPrograms.push({
                        name: shaderInfo.name,
                        program: program,
                        posLocation: posLocation,
                        timeLocation: timeLocation,
                        resolutionLocation: resolutionLocation,
                        textureLocation: textureLocation,
                        customUniforms: customUniforms,
                        uniformLocations: uniformLocations
                    });
                }
                
                console.log('Successfully compiled', shaderPrograms.length, 'shader program(s)');
                
                // Create fullscreen quad (shared by all shaders)
                const positions = new Float32Array([
                    -1, -1,  1, -1,  -1, 1,
                    -1, 1,   1, -1,   1, 1
                ]);
                
                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                
                // Create texture for terminal canvas (input to first shader)
                const terminalTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, terminalTexture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                
                // Create framebuffers for multi-pass rendering
                // We need (N-1) framebuffers for N shaders (last shader renders to screen)
                const framebuffers = [];
                
                function createFramebuffer(w, h) {
                    const fb = gl.createFramebuffer();
                    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
                    
                    const texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
                    
                    if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                        throw new Error('Framebuffer is not complete');
                    }
                    
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                    return { framebuffer: fb, texture: texture };
                }
                
                // Create framebuffers for all but the last shader
                for (let i = 0; i < shaderPrograms.length - 1; i++) {
                    framebuffers.push(createFramebuffer(webglCanvas.width, webglCanvas.height));
                }
                
                console.log('Created', framebuffers.length, 'intermediate framebuffer(s)');
                
                const startTime = Date.now();
                
                // Function to resize framebuffers
                function resizeFramebuffers(w, h) {
                    console.log('Resizing framebuffers to', w, 'x', h);
                    for (let i = 0; i < framebuffers.length; i++) {
                        const fb = framebuffers[i];
                        gl.bindTexture(gl.TEXTURE_2D, fb.texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                    }
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                
                shaderSystem = {
                    gl: gl,
                    shaderPrograms: shaderPrograms,
                    terminalCanvas: terminalCanvas,
                    visibleCanvas: webglCanvas,
                    terminalTexture: terminalTexture,
                    framebuffers: framebuffers,
                    posBuffer: posBuffer,
                    startTime: startTime,
                    animationId: null,
                    lastWidth: webglCanvas.width,
                    lastHeight: webglCanvas.height,
                    resizeFramebuffers: resizeFramebuffers,
                    
                    render: function() {
                        // Check if canvas size changed and resize framebuffers
                        if (webglCanvas.width !== this.lastWidth || webglCanvas.height !== this.lastHeight) {
                            this.lastWidth = webglCanvas.width;
                            this.lastHeight = webglCanvas.height;
                            resizeFramebuffers(webglCanvas.width, webglCanvas.height);
                        }
                        
                        // Update terminal texture from terminal canvas
                        gl.bindTexture(gl.TEXTURE_2D, terminalTexture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, terminalCanvas);
                        
                        // Set viewport to match canvas
                        gl.viewport(0, 0, webglCanvas.width, webglCanvas.height);
                        
                        const time = (Date.now() - startTime) / 1000.0;
                        
                        // Multi-pass rendering: each shader reads from previous output
                        for (let i = 0; i < shaderPrograms.length; i++) {
                            const shader = shaderPrograms[i];
                            const isLastShader = (i === shaderPrograms.length - 1);
                            
                            // Bind framebuffer for this pass (null = render to screen)
                            if (isLastShader) {
                                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                            } else {
                                gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[i].framebuffer);
                            }
                            
                            // Use this shader's program
                            gl.useProgram(shader.program);
                            
                            // Bind input texture (terminal for first shader, previous framebuffer for others)
                            const inputTexture = (i === 0) ? terminalTexture : framebuffers[i - 1].texture;
                            gl.activeTexture(gl.TEXTURE0);
                            gl.bindTexture(gl.TEXTURE_2D, inputTexture);
                            
                            // Set standard uniforms
                            if (shader.timeLocation) {
                                gl.uniform1f(shader.timeLocation, time);
                            }
                            if (shader.resolutionLocation) {
                                gl.uniform2f(shader.resolutionLocation, webglCanvas.width, webglCanvas.height);
                            }
                            if (shader.textureLocation) {
                                gl.uniform1i(shader.textureLocation, 0);
                            }
                            
                            // Set custom uniforms
                            for (const name in shader.customUniforms) {
                                let value = shader.customUniforms[name];
                                const location = shader.uniformLocations[name];
                                if (location) {
                                    // Special handling for cellSize - get live values from terminal
                                    if (name === 'cellSize' && window.terminal) {
                                        value = [window.terminal.charWidth, window.terminal.charHeight];
                                    }
                                    
                                    if (typeof value === 'number') {
                                        gl.uniform1f(location, value);
                                    } else if (Array.isArray(value)) {
                                        if (value.length === 2) {
                                            gl.uniform2f(location, value[0], value[1]);
                                        } else if (value.length === 3) {
                                            gl.uniform3f(location, value[0], value[1], value[2]);
                                        } else if (value.length === 4) {
                                            gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                                        }
                                    }
                                }
                            }
                            
                            // Draw fullscreen quad
                            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                            gl.enableVertexAttribArray(shader.posLocation);
                            gl.vertexAttribPointer(shader.posLocation, 2, gl.FLOAT, false, 0, 0);
                            
                            gl.drawArrays(gl.TRIANGLES, 0, 6);
                        }
                        
                        // Continue render loop
                        this.animationId = requestAnimationFrame(() => this.render());
                    }
                };
                
                // Start continuous render loop
                shaderSystem.render();
                
                console.log('Shader system initialized successfully');
                progress.textContent = '';
            } catch (e) {
                console.error('Failed to initialize shader system:', e);
                progress.textContent = 'Shader initialization error: ' + e.message;
            }
        }
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const info = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error('Shader compile failed: ' + info);
            }
            
            return shader;
        }
    </script>
    
    <!-- Load our WebGL terminal interface first -->
    <script src="tstorie-webgl.js"></script>
    
    <!-- Then load the WASM module -->
    <script src="tstorie.wasm.js" onerror="document.getElementById('container').innerHTML = '<div class=\'error\'><h2>Failed to load WASM module</h2><p>Make sure tstorie.wasm.js exists in the same directory.</p></div>';"></script>
</body>
</html>