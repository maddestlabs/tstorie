<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TStorie WebGPU Noise Demo</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: 'Courier New', monospace;
      background: #000;
      color: #0f0;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 10px;
      text-shadow: 0 0 10px #0f0;
    }
    
    .subtitle {
      text-align: center;
      color: #0a0;
      margin-bottom: 30px;
    }
    
    .info {
      background: #001100;
      border: 1px solid #0f0;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 5px;
    }
    
    .info strong {
      color: #0ff;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }
    
    button {
      background: #002200;
      border: 2px solid #0f0;
      color: #0f0;
      padding: 12px 24px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
    }
    
    button:hover:not(:disabled) {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 20px #0f0;
    }
    
    button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    
    .canvas-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .canvas-wrapper {
      border: 2px solid #0f0;
      background: #001100;
      padding: 10px;
      border-radius: 5px;
    }
    
    .canvas-title {
      text-align: center;
      margin-bottom: 10px;
      color: #0ff;
      font-size: 18px;
      text-transform: uppercase;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      border: 1px solid #0a0;
    }
    
    .stats {
      text-align: center;
      margin-top: 10px;
      color: #0a0;
      font-size: 12px;
    }
    
    .log {
      background: #001100;
      border: 1px solid #0f0;
      padding: 15px;
      max-height: 300px;
      overflow-y: auto;
      font-size: 12px;
      border-radius: 5px;
    }
    
    .log-entry {
      margin-bottom: 5px;
      padding: 3px;
    }
    
    .log-gpu {
      color: #0ff;
    }
    
    .log-cpu {
      color: #ff0;
    }
    
    .log-info {
      color: #0f0;
    }
    
    .log-error {
      color: #f00;
    }
    
    .status {
      display: inline-block;
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 12px;
      margin-left: 10px;
    }
    
    .status.ready {
      background: #002200;
      color: #0f0;
      border: 1px solid #0f0;
    }
    
    .status.busy {
      background: #220;
      color: #ff0;
      border: 1px solid #ff0;
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>‚ö° TStorie WebGPU Compute Shaders ‚ö°</h1>
    <div class="subtitle">Noise Generation: CPU vs GPU</div>
    
    <div class="info">
      <strong>Status:</strong> <span id="webgpu-status">Checking WebGPU...</span><br>
      <strong>Device:</strong> <span id="device-info">-</span><br>
      <strong>Architecture:</strong> Nim ‚Üí WGSL ‚Üí WebGPU Compute Pipeline
    </div>
    
    <div class="controls">
      <button id="btn-terrain" onclick="generateTerrain()">üèîÔ∏è Terrain (Perlin)</button>
      <button id="btn-clouds" onclick="generateClouds()">‚òÅÔ∏è Clouds (Simplex)</button>
      <button id="btn-mountains" onclick="generateMountains()">‚õ∞Ô∏è Mountains (Ridged)</button>
      <button id="btn-ocean" onclick="generateOcean()">üåä Ocean (Smooth)</button>
      <button id="btn-fire" onclick="generateFire()">üî• Fire (Turbulent)</button>
      <button id="btn-cells" onclick="generateCells()">üî≤ Cells (Worley)</button>
      <button id="btn-animate" onclick="toggleAnimation()">‚ñ∂Ô∏è Animate</button>
      <button id="btn-compare" onclick="comparePerformance()">‚ö° CPU vs GPU</button>
    </div>
    
    <div class="canvas-container">
      <div class="canvas-wrapper">
        <div class="canvas-title">CPU Preview (100x100)</div>
        <canvas id="canvas-cpu" width="100" height="100"></canvas>
        <div class="stats" id="stats-cpu">-</div>
      </div>
      
      <div class="canvas-wrapper">
        <div class="canvas-title">GPU Output (512x512)</div>
        <canvas id="canvas-gpu" width="512" height="512"></canvas>
        <div class="stats" id="stats-gpu">-</div>
      </div>
    </div>
    
    <div class="log" id="log">
      <div class="log-entry log-info">[INFO] Ready to generate noise...</div>
    </div>
  </div>
  
  <script src="webgpu_bridge.js"></script>
  <script>
    let isAnimating = false;
    let currentShader = null;
    let animationFrame = 0;
    
    // Logging
    function log(message, type = 'info') {
      const logEl = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry log-${type}`;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logEl.insertBefore(entry, logEl.firstChild);
      
      // Keep only last 50 entries
      while (logEl.children.length > 50) {
        logEl.removeChild(logEl.lastChild);
      }
    }
    
    // Check WebGPU support
    async function checkWebGPU() {
      const statusEl = document.getElementById('webgpu-status');
      const deviceEl = document.getElementById('device-info');
      
      if (!window.webgpuBridge) {
        statusEl.textContent = '‚ùå WebGPU not available';
        statusEl.style.color = '#f00';
        log('WebGPU not available - check browser support', 'error');
        return false;
      }
      
      if (window.webgpuBridge.initialized) {
        statusEl.innerHTML = '‚úÖ WebGPU Ready <span class="status ready">READY</span>';
        statusEl.style.color = '#0f0';
        
        const info = window.webgpuBridge.getDeviceInfo();
        deviceEl.textContent = `${info.vendor || 'Unknown'} ${info.architecture || ''}`.trim();
        
        log('WebGPU initialized successfully', 'info');
        return true;
      } else {
        statusEl.textContent = '‚è≥ Initializing...';
        statusEl.style.color = '#ff0';
        
        // Wait for initialization
        await new Promise(resolve => setTimeout(resolve, 1000));
        return checkWebGPU();
      }
    }
    
    // CPU noise generation (placeholder - would call WASM)
    function generateNoiseCPU(width, height, type, seed) {
      const start = performance.now();
      const canvas = document.getElementById('canvas-cpu');
      const ctx = canvas.getContext('2d');
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;
      
      // Simple noise implementation for demo
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          // Simple hash-based noise
          const hash = ((x * 374761393 + y * 668265263 + seed) ^ (seed * 1274126177)) >>> 0;
          const value = (hash % 65536) / 65535 * 255;
          data[idx] = value;
          data[idx + 1] = value;
          data[idx + 2] = value;
          data[idx + 3] = 255;
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
      const elapsed = performance.now() - start;
      document.getElementById('stats-cpu').textContent = `Generated in ${elapsed.toFixed(2)}ms`;
      log(`[CPU] Generated ${width}x${height} in ${elapsed.toFixed(2)}ms`, 'cpu');
      return elapsed;
    }
    
    // GPU noise generation
    async function generateNoiseGPU(width, height, type, seed) {
      if (!window.webgpuBridge || !window.webgpuBridge.initialized) {
        log('WebGPU not ready', 'error');
        return;
      }
      
      const start = performance.now();
      
      // Example: compile terrain shader
      const shaderName = `${type}_shader`;
      const pipelineName = `${type}_pipeline`;
      const outputName = `${type}_output`;
      const paramsName = `${type}_params`;
      const bindGroupName = `${type}_bindings`;
      
      // For demo, we'll use pre-generated WGSL
      // In real implementation, this would come from Nim's toWGSL()
      const wgslCode = getShaderCode(type, seed);
      
      // Compile shader (if not already)
      if (!window.webgpuBridge.shaderModules.has(shaderName)) {
        log(`[GPU] Compiling ${type} shader...`, 'gpu');
        window.webgpuBridge.compileShader(shaderName, wgslCode);
        window.webgpuBridge.createPipeline(pipelineName, shaderName, 'main');
        
        // Create buffers
        window.webgpuBridge.createBuffer(outputName, width * height * 4, true);
        window.webgpuBridge.createUniformBuffer(paramsName, 16);
        
        // Create bind group
        window.webgpuBridge.createBindGroup(bindGroupName, pipelineName, [
          { binding: 0, bufferName: outputName },
          { binding: 1, bufferName: paramsName }
        ]);
      }
      
      // Update params
      const params = new Uint32Array([width, height, animationFrame, 0]);
      window.webgpuBridge.writeBuffer(paramsName, params);
      
      // Dispatch
      const workgroupsX = Math.ceil(width / 8);
      const workgroupsY = Math.ceil(height / 8);
      window.webgpuBridge.dispatch(pipelineName, bindGroupName, workgroupsX, workgroupsY);
      
      // Read back results
      const output = await window.webgpuBridge.readBuffer(outputName, width * height * 4);
      
      // Draw to canvas
      const canvas = document.getElementById('canvas-gpu');
      const ctx = canvas.getContext('2d');
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;
      
      const values = new Uint32Array(output);
      for (let i = 0; i < values.length; i++) {
        const value = Math.floor((values[i] / 65535) * 255);
        data[i * 4] = value;
        data[i * 4 + 1] = value;
        data[i * 4 + 2] = value;
        data[i * 4 + 3] = 255;
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      const elapsed = performance.now() - start;
      document.getElementById('stats-gpu').textContent = `Generated in ${elapsed.toFixed(2)}ms`;
      log(`[GPU] Generated ${width}x${height} in ${elapsed.toFixed(2)}ms`, 'gpu');
      return elapsed;
    }
    
    // Get shader code for type
    function getShaderCode(type, seed) {
      // This is a placeholder - real implementation would use generated WGSL from Nim
      return `
        @group(0) @binding(0) var<storage, read_write> output: array<u32>;
        @group(0) @binding(1) var<uniform> params: vec4<u32>;
        
        @compute @workgroup_size(8, 8)
        fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
          let width = params.x;
          let height = params.y;
          let offsetX = params.z;
          
          let x = global_id.x;
          let y = global_id.y;
          
          if (x >= width || y >= height) {
            return;
          }
          
          let idx = y * width + x;
          
          // Simple hash-based noise for demo
          let px = x + offsetX;
          let hash = ((px * 374761393u + y * 668265263u + ${seed}u) ^ (${seed}u * 1274126177u));
          output[idx] = hash % 65536u;
        }
      `;
    }
    
    // Generate different noise types
    async function generateTerrain() {
      currentShader = 'terrain';
      generateNoiseCPU(100, 100, 'terrain', 42);
      await generateNoiseGPU(512, 512, 'terrain', 42);
    }
    
    async function generateClouds() {
      currentShader = 'clouds';
      generateNoiseCPU(100, 100, 'clouds', 999);
      await generateNoiseGPU(512, 512, 'clouds', 999);
    }
    
    async function generateMountains() {
      currentShader = 'mountains';
      generateNoiseCPU(100, 100, 'mountains', 777);
      await generateNoiseGPU(512, 512, 'mountains', 777);
    }
    
    async function generateOcean() {
      currentShader = 'ocean';
      generateNoiseCPU(100, 100, 'ocean', 555);
      await generateNoiseGPU(512, 512, 'ocean', 555);
    }
    
    async function generateFire() {
      currentShader = 'fire';
      generateNoiseCPU(100, 100, 'fire', 333);
      await generateNoiseGPU(512, 512, 'fire', 333);
    }
    
    async function generateCells() {
      currentShader = 'cells';
      generateNoiseCPU(100, 100, 'cells', 111);
      await generateNoiseGPU(512, 512, 'cells', 111);
    }
    
    // Animation
    function toggleAnimation() {
      isAnimating = !isAnimating;
      const btn = document.getElementById('btn-animate');
      
      if (isAnimating) {
        btn.textContent = '‚è∏Ô∏è Pause';
        btn.style.background = '#220';
        animate();
      } else {
        btn.textContent = '‚ñ∂Ô∏è Animate';
        btn.style.background = '#002200';
      }
    }
    
    async function animate() {
      if (!isAnimating || !currentShader) return;
      
      animationFrame++;
      await generateNoiseGPU(512, 512, currentShader, 42);
      
      requestAnimationFrame(animate);
    }
    
    // Performance comparison
    async function comparePerformance() {
      log('Starting performance comparison...', 'info');
      
      const sizes = [64, 128, 256, 512];
      const results = [];
      
      for (const size of sizes) {
        log(`Testing ${size}x${size}...`, 'info');
        
        // CPU
        const cpuTime = generateNoiseCPU(size, size, 'test', 42);
        
        // GPU (skip for now - would need proper implementation)
        // const gpuTime = await generateNoiseGPU(size, size, 'test', 42);
        
        results.push({ size, cpuTime });
      }
      
      log('=== Performance Results ===', 'info');
      results.forEach(r => {
        log(`${r.size}x${r.size}: CPU ${r.cpuTime.toFixed(2)}ms`, 'info');
      });
    }
    
    // Initialize
    checkWebGPU();
  </script>
</body>
</html>
