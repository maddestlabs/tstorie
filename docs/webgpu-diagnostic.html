<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGPU Diagnostic</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #000;
      color: #0f0;
    }
    .ok { color: #0f0; }
    .fail { color: #f00; }
    .warn { color: #ff0; }
    pre {
      background: #111;
      padding: 10px;
      border: 1px solid #0f0;
      overflow-x: auto;
    }
    h2 { border-bottom: 1px solid #0f0; padding-bottom: 5px; }
  </style>
</head>
<body>
  <h1>üîç WebGPU Diagnostic Tool</h1>
  <div id="output"></div>

  <script>
    const output = document.getElementById('output');
    
    function print(msg, cls = '') {
      const div = document.createElement('div');
      div.className = cls;
      div.textContent = msg;
      output.appendChild(div);
    }
    
    function section(title) {
      const h2 = document.createElement('h2');
      h2.textContent = title;
      output.appendChild(h2);
    }
    
    async function diagnose() {
      section('1. Browser Environment');
      print(`User Agent: ${navigator.userAgent}`);
      print(`Platform: ${navigator.platform}`);
      print(`Language: ${navigator.language}`);
      print('');
      
      section('2. WebGPU API Check');
      
      // Check if navigator.gpu exists
      if (typeof navigator.gpu === 'undefined') {
        print('‚ùå navigator.gpu is undefined', 'fail');
        print('   WebGPU API not available in this browser', 'fail');
        print('');
        print('Possible reasons:', 'warn');
        print('  ‚Ä¢ Browser too old (need Chrome 113+, Safari 18+)', 'warn');
        print('  ‚Ä¢ WebGPU not enabled in flags', 'warn');
        print('  ‚Ä¢ Running in insecure context (not HTTPS/localhost)', 'warn');
        print('  ‚Ä¢ Browser extension blocking WebGPU', 'warn');
        return;
      }
      
      print('‚úì navigator.gpu exists', 'ok');
      print(`  Type: ${typeof navigator.gpu}`, 'ok');
      print('');
      
      section('3. Security Context');
      print(`isSecureContext: ${window.isSecureContext ? '‚úì' : '‚ùå'}`, 
            window.isSecureContext ? 'ok' : 'fail');
      if (!window.isSecureContext) {
        print('  ‚ö†Ô∏è  WebGPU requires HTTPS or localhost', 'warn');
      }
      print('');
      
      section('4. GPU Adapter Request');
      print('Requesting GPU adapter...');
      
      try {
        const adapter = await navigator.gpu.requestAdapter({
          powerPreference: 'high-performance'
        });
        
        if (!adapter) {
          print('‚ùå requestAdapter() returned null', 'fail');
          print('   No GPU adapter available', 'fail');
          print('');
          print('Possible reasons:', 'warn');
          print('  ‚Ä¢ GPU not supported', 'warn');
          print('  ‚Ä¢ GPU drivers outdated', 'warn');
          print('  ‚Ä¢ GPU blacklisted by browser', 'warn');
          print('  ‚Ä¢ Running in VM/container without GPU access', 'warn');
          return;
        }
        
        print('‚úì GPU Adapter obtained', 'ok');
        print('');
        
        section('5. Adapter Info');
        try {
          const info = await adapter.requestAdapterInfo();
          print(`Vendor: ${info.vendor || 'N/A'}`);
          print(`Architecture: ${info.architecture || 'N/A'}`);
          print(`Device: ${info.device || 'N/A'}`);
          print(`Description: ${info.description || 'N/A'}`);
        } catch (err) {
          print('‚ö†Ô∏è  requestAdapterInfo() not available (older WebGPU implementation)', 'warn');
        }
        print('');
        
        section('6. Adapter Features');
        print(`Features: ${adapter.features.size} available`);
        const features = Array.from(adapter.features);
        if (features.length > 0) {
          features.forEach(f => print(`  ‚Ä¢ ${f}`, 'ok'));
        }
        print('');
        
        section('7. Adapter Limits');
        const limits = adapter.limits;
        print(`maxComputeWorkgroupSizeX: ${limits.maxComputeWorkgroupSizeX}`);
        print(`maxComputeWorkgroupSizeY: ${limits.maxComputeWorkgroupSizeY}`);
        print(`maxComputeWorkgroupSizeZ: ${limits.maxComputeWorkgroupSizeZ}`);
        print(`maxStorageBufferBindingSize: ${limits.maxStorageBufferBindingSize}`);
        print(`maxBufferSize: ${limits.maxBufferSize}`);
        print('');
        
        section('8. Device Request');
        print('Requesting GPU device...');
        
        const device = await adapter.requestDevice();
        
        if (!device) {
          print('‚ùå requestDevice() returned null', 'fail');
          return;
        }
        
        print('‚úì GPU Device obtained', 'ok');
        print(`  Queue: ${device.queue ? '‚úì' : '‚ùå'}`, device.queue ? 'ok' : 'fail');
        print('');
        
        section('9. Simple Compute Shader Test');
        print('Testing basic compute shader compilation...');
        
        try {
          const shaderCode = `
            @group(0) @binding(0) var<storage, read_write> output: array<u32>;
            
            @compute @workgroup_size(1)
            fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
              output[0] = 42u;
            }
          `;
          
          const shaderModule = device.createShaderModule({
            code: shaderCode
          });
          
          print('‚úì Shader module created', 'ok');
          
          const pipeline = device.createComputePipeline({
            layout: 'auto',
            compute: {
              module: shaderModule,
              entryPoint: 'main'
            }
          });
          
          print('‚úì Compute pipeline created', 'ok');
          print('');
          
          section('üéâ Result');
          print('WebGPU is FULLY FUNCTIONAL!', 'ok');
          print('TStorie compute shaders should work.', 'ok');
          
        } catch (err) {
          print(`‚ùå Shader test failed: ${err.message}`, 'fail');
          print('');
          section('Error Details');
          const pre = document.createElement('pre');
          pre.textContent = err.stack || err.message;
          output.appendChild(pre);
        }
        
      } catch (err) {
        print(`‚ùå Error during adapter/device request: ${err.message}`, 'fail');
        print('');
        section('Error Details');
        const pre = document.createElement('pre');
        pre.textContent = err.stack || err.message;
        output.appendChild(pre);
      }
    }
    
    // Run diagnostic
    window.addEventListener('load', () => {
      print('Starting diagnostic...', 'warn');
      print('');
      diagnose();
    });
  </script>
</body>
</html>
