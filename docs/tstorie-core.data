# Procedural Dungeon Generation with Guaranteed Determinism

## The Challenge

Creating a dungeon generator in scripts that produces **identical results** when exported to native requires:

1. ‚úÖ **Isolated RNG** - Same seed = same random sequence
2. ‚úÖ **Integer-only math** - No float drift between implementations
3. ‚úÖ **Identical algorithms** - Same data structures and logic
4. ‚úÖ **Pure functions** - Only use guaranteed-deterministic primitives

## Why Previous Attempts Differed

**[dungen.md](dungen.md)** vs **[dungen_scripted.md](dungen_scripted.md)** produced different dungeons because:

- ‚ùå Native used separate `cells` + `regionMap` arrays
- ‚ùå Scripted stored regions in cell values directly
- ‚ùå Different room validation (clamp vs continue)
- ‚ùå Complexity made exact algorithm matching difficult

## The Solution: Simpler Algorithm + Primitives Only

### Strategy

Use **Binary Space Partitioning (BSP)** - a simpler algorithm that:
- Recursively splits space into rooms
- Uses only procgen primitives
- Easy to port (simple data structures)
- Naturally deterministic

### Key Principles

1. **Use primitives exclusively:**
   - `idiv` instead of `/` (integer division)
   - `clamp` instead of manual if-checks
   - `rand(rng, max)` with isolated RNG
   - No floating point math anywhere

2. **Simple data structures:**
   - `seq[seq[int]]` for grid (works identically in both)
   - Simple integer constants
   - No complex object hierarchies

3. **Identical control flow:**
   - Same number of RNG calls in same order
   - Same iteration patterns
   - Explicit integer operations

## Example: BSP Dungeon Generator

### Algorithm Overview

```
1. Start with entire grid as one partition
2. Recursively split partitions (H or V)
3. Each leaf partition becomes a room
4. Connect rooms with corridors
5. All using isolated RNG + primitives
```

### Implementation Pattern

```nim
# Constants - identical in script and native
const WALL = 0
const FLOOR = 1
const CORRIDOR = 2

# Use isolated RNG
var rng = initRand(seed)

# Grid - seq[seq[int]] works identically
var grid = newSeq[seq[int]](height)
for y in 0..<height:
  grid[y] = newSeq[int](width)
  for x in 0..<width:
    grid[y][x] = WALL

# BSP split using primitives
proc splitPartition(x, y, w, h: int, depth: int, rng: var Rand, grid: var seq[seq[int]]) =
  if depth <= 0 or w < 8 or h < 8:
    # Make a room using primitives
    let roomW = clamp(w - 4, 3, w - 2)
    let roomH = clamp(h - 4, 3, h - 2)
    let roomX = x + idiv(w - roomW, 2)
    let roomY = y + idiv(h - roomH, 2)
    
    # Carve room
    for ry in roomY..<(roomY + roomH):
      for rx in roomX..<(roomX + roomW):
        grid[ry][rx] = FLOOR
    return
  
  # Split horizontally or vertically using RNG
  if rng.rand(1) == 0:
    # Split horizontally - use idiv!
    let splitAt = rng.rand(h div 4, idiv(h * 3, 4))
    splitPartition(x, y, w, splitAt, depth - 1, rng, grid)
    splitPartition(x, y + splitAt, w, h - splitAt, depth - 1, rng, grid)
  else:
    # Split vertically - use idiv!
    let splitAt = rng.rand(w div 4, idiv(w * 3, 4))
    splitPartition(x, y, splitAt, h, depth - 1, rng, grid)
    splitPartition(x + splitAt, y, w - splitAt, h, depth - 1, rng, grid)
```

## Critical Rules for Determinism

### ‚úÖ DO:

1. **Use `idiv` for division:**
   ```nim
   # ‚úÖ Correct
   let half = idiv(width, 2)
   
   # ‚ùå Wrong - float conversion
   let half = width / 2
   ```

2. **Use isolated RNG:**
   ```nim
   # ‚úÖ Correct
   var rng = initRand(seed)
   let x = rng.rand(max)
   
   # ‚ùå Wrong - global RNG
   let x = rand(max)
   ```

3. **Consistent rand() form:**
   ```nim
   # ‚úÖ Correct
   let x = rng.rand(100)  # 0..100 inclusive
   
   # ‚ùå Wrong - different internal behavior
   let x = rng.rand(0, 100)
   ```

4. **Integer-only calculations:**
   ```nim
   # ‚úÖ Correct
   let third = idiv(width, 3)
   let mapped = map(value, 0, 100, 0, width)
   
   # ‚ùå Wrong - float math
   let third = int(width * 0.33)
   ```

5. **Use primitives for common operations:**
   ```nim
   # ‚úÖ Correct
   let clamped = clamp(x, 0, width)
   let dist = manhattanDist(x1, y1, x2, y2)
   
   # ‚ùå Wrong - manual implementation
   let clamped = if x < 0: 0 elif x > width: width else: x
   ```

### ‚ùå DON'T:

1. **Don't use float math:**
   ```nim
   # ‚ùå Will cause drift
   let ratio = width / height
   let scaled = value * 0.5
   ```

2. **Don't use different data structures:**
   ```nim
   # ‚ùå Native might optimize differently
   type ComplexObject = object
     data: Table[string, seq[int]]
   ```

3. **Don't use platform-specific features:**
   ```nim
   # ‚ùå May differ
   import os
   let time = epochTime()
   ```

## Export Workflow

### 1. Develop in Script

```nim
# In your .md file
```nim on:init
var rng = initRand(12345)
var grid = generateDungeon(80, 25, rng)
```

### 2. Test Determinism

Run multiple times with same seed - should always produce identical output.

### 3. Export to Native

When using tstorie's export feature, the generated native Nim code will use the same primitives from `lib/primitives.nim`, guaranteeing identical results.

### 4. Verify

```bash
# Generate dungeon in script with seed 12345
# Export to native
# Run native with seed 12345
# Compare outputs - should be byte-for-byte identical
```

## Complete Working Example

### Simplified BSP Dungeon (Guaranteed Deterministic)

```nim
# This algorithm uses ONLY primitives and works identically
# in both nimini scripts and native Nim

const WALL = 0
const FLOOR = 1

type Rect = object
  x, y, w, h: int

type Room = object
  rect: Rect
  center: tuple[x, y: int]

proc generateBSPDungeon(width, height, seed: int): seq[seq[int]] =
  var rng = initRand(seed)
  
  # Initialize grid
  var grid = newSeq[seq[int]](height)
  for y in 0..<height:
    grid[y] = newSeq[int](width)
    for x in 0..<width:
      grid[y][x] = WALL
  
  # Generate rooms using BSP
  var rooms = newSeq[Room]()
  
  proc splitAndCreateRooms(x, y, w, h, depth: int) =
    if depth <= 0 or w < 10 or h < 10:
      # Create room in this partition
      let minSize = 3
      let roomW = clamp(rng.rand(minSize, w - 4), minSize, w - 2)
      let roomH = clamp(rng.rand(minSize, h - 4), minSize, h - 2)
      let roomX = x + idiv(w - roomW, 2)
      let roomY = y + idiv(h - roomH, 2)
      
      # Carve room
      for ry in roomY..<(roomY + roomH):
        for rx in roomX..<(roomX + roomW):
          if ry >= 0 and ry < height and rx >= 0 and rx < width:
            grid[ry][rx] = FLOOR
      
      # Store room
      rooms.add(Room(
        rect: Rect(x: roomX, y: roomY, w: roomW, h: roomH),
        center: (roomX + idiv(roomW, 2), roomY + idiv(roomH, 2))
      ))
      return
    
    # Split partition - use idiv!
    if rng.rand(1) == 0:
      # Horizontal split
      let minSplit = idiv(h, 4)
      let maxSplit = idiv(h * 3, 4)
      let splitAt = clamp(rng.rand(minSplit, maxSplit), minSplit, maxSplit)
      splitAndCreateRooms(x, y, w, splitAt, depth - 1)
      splitAndCreateRooms(x, y + splitAt, w, h - splitAt, depth - 1)
    else:
      # Vertical split
      let minSplit = idiv(w, 4)
      let maxSplit = idiv(w * 3, 4)
      let splitAt = clamp(rng.rand(minSplit, maxSplit), minSplit, maxSplit)
      splitAndCreateRooms(x, y, splitAt, h, depth - 1)
      splitAndCreateRooms(x + splitAt, y, w - splitAt, h, depth - 1)
  
  # Start BSP
  splitAndCreateRooms(1, 1, width - 2, height - 2, 3)
  
  # Connect rooms with corridors using primitives
  for i in 0..<(rooms.len - 1):
    let r1 = rooms[i]
    let r2 = rooms[i + 1]
    
    # Use manhattan distance primitive
    let dist = manhattanDist(r1.center.x, r1.center.y, r2.center.x, r2.center.y)
    
    # Carve corridor (L-shaped)
    var x = r1.center.x
    var y = r1.center.y
    
    # Horizontal first
    while x != r2.center.x:
      if x < r2.center.x:
        x = x + 1
      else:
        x = x - 1
      if y >= 0 and y < height and x >= 0 and x < width:
        grid[y][x] = FLOOR
    
    # Then vertical
    while y != r2.center.y:
      if y < r2.center.y:
        y = y + 1
      else:
        y = y - 1
      if y >= 0 and y < height and x >= 0 and x < width:
        grid[y][x] = FLOOR
  
  return grid
```

## Verification Strategy

### Test Harness

Create identical test in both environments:

```nim
# Test seed consistency
let seed = 12345
let grid1 = generateBSPDungeon(80, 25, seed)
let grid2 = generateBSPDungeon(80, 25, seed)

# Should be identical
assert grid1 == grid2

# Test different seeds produce different results
let grid3 = generateBSPDungeon(80, 25, 54321)
assert grid1 != grid3
```

### Visual Comparison

```nim
# Generate in script, save to file
# Generate in native, save to file
# Diff the files - should be identical
```

## Benefits of This Approach

1. ‚úÖ **Guaranteed Determinism** - Same seed = same dungeon, always
2. ‚úÖ **Easy to Port** - Simple algorithms, simple data structures
3. ‚úÖ **Fast Native** - Exports to native Nim with zero overhead
4. ‚úÖ **Easy to Debug** - Pure functions, no hidden state
5. ‚úÖ **Composable** - Combine with other procgen primitives
6. ‚úÖ **Testable** - Verify determinism automatically

## Advanced Patterns

### Pattern 1: Layered Generation

```nim
# Base terrain using fractal noise
let terrain = fractalNoise2D(x, y, 4, 100, seed)

# Rooms using BSP with different seed
let roomSeed = intHash(seed, 1)
let rooms = generateRooms(rng.initRand(roomSeed))

# Decorations using hash
let decorSeed = intHash(seed, 2)
let decor = generateDecor(decorSeed)

# All deterministic, all composable
```

### Pattern 2: Procedural Parameters

```nim
# Generate dungeon parameters from seed
let paramSeed = initRand(seed)
let roomCount = paramSeed.rand(5, 15)
let corridorWidth = paramSeed.rand(1, 3)
let decorDensity = paramSeed.rand(10, 50)

# Use parameters consistently
```

### Pattern 3: Multi-Stage with Noise

```nim
# Stage 1: Base layout using BSP
# Stage 2: Add organic feel using cellular automata
let caGrid = cellularAutomata(grid, birthRule, surviveRule)

# Stage 3: Add decorations using noise
for y in 0..<height:
  for x in 0..<width:
    if grid[y][x] == FLOOR:
      let noise = valueNoise2D(x, y, seed)
      if noise > 50000:  # Threshold
        grid[y][x] = DECORATION
```

## Comparison: Before vs After

### Before (Different Results)

```
Native:     Uses native/dungeon_gen.nim with separate regionMap
Scripted:   Uses object-based design with embedded regions
Result:     Different dungeons with same seed ‚ùå
```

### After (Guaranteed Same)

```
Native:     Uses lib/primitives.nim
Scripted:   Uses same primitives via nimini/stdlib/procgen.nim
Result:     Identical dungeons with same seed ‚úÖ
```

## Conclusion

**Yes, it's totally feasible!** The key is:

1. Use **only** the procgen primitives
2. Keep algorithms **simple** and **explicit**
3. Use **isolated RNG** throughout
4. Test **determinism** early and often

The primitives were designed exactly for this use case. By following these patterns, you can develop complex procedural generation in scripts with confidence that native export will produce identical results.

## Next Steps

1. Implement simplified BSP dungeon using primitives
2. Test determinism in script
3. Export to native
4. Verify byte-for-byte identical output
5. Build more complex generators on this foundation

The foundation is solid - build with confidence! üé≤üè∞
---
title: ANSI Art Demo
---

# ANSI Art Support

TStorie now supports `ansi:name` code blocks for embedding ANSI art with colors and styles!

You can also load `.ans` files directly (classic ANSI art files from the BBS era).

```nim on:render
# Standard embedded blocks (with automatic escape sequence conversion)
drawAnsi(0, 2, 3, "grid")

# Show info text
draw(0, 2, 23, "Classic .ANS art")
```

```ansi:grid
[38;2;0;150;200m‚ïî[38;2;255;255;0m‚ïê[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;255;0m‚ïê[38;2;0;150;200m‚ïó[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;150;200m‚ïö[38;2;0;255;255m‚ïê[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïê[38;2;0;150;200m‚ïù[0m
```---
title: ANSI Art Demo
---

# ANSI Art Support

TStorie now supports `ansi:name` code blocks for embedding ANSI art with colors and styles!

You can also load `.ans` files directly (classic ANSI art files from the BBS era).

```nim on:render
# Standard embedded blocks (with automatic escape sequence conversion)
drawAnsi(0, 2, 3, "logo")
drawAnsi(0, 2, 11, "gradient")
drawAnsi(0, 2, 16, "styled")

# Load .ans file (converted from \x1b[ to [ for markdown format)
drawAnsi(0, 2, 24, "amiex")

# Show info text
draw(0, 2, 23, "Classic .ANS file from BBS era -->")
```

## Embedded ANSI Art

Here's some embedded ANSI art with various styles:

```ansi
[38;2;0;217;142m  ‚ñÑ  [0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñÑ‚ñÑ‚ñÑ‚ñÑ   ‚ñÑ                     [0m
[38;2;0;217;142m ‚ñÑ‚ñà‚ñÑ [0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñà     ‚ñÑ‚ñà‚ñÑ  ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ  ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ[0m
[38;2;0;217;142m  ‚ñà  [0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÑ  ‚ñà   ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà[0m
[38;2;0;217;142m  ‚ñà  [0m [1;37m‚ñà[0m [38;2;100;100;100m    ‚ñà  ‚ñà   ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà    [0m
[38;2;0;217;142m  ‚ñÄ‚ñÄ [0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñÄ‚ñÄ‚ñÄ‚ñÄ   ‚ñÄ‚ñÄ  ‚ñÄ‚ñÄ‚ñÄ‚ñÄ ‚ñÄ    ‚ñÄ  ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ[0m
```

```ansi:gradient
[38;5;196m‚ñÄ[38;5;202m‚ñÄ[38;5;208m‚ñÄ[38;5;214m‚ñÄ[38;5;220m‚ñÄ[38;5;226m‚ñÄ[38;5;190m‚ñÄ[38;5;154m‚ñÄ[38;5;118m‚ñÄ[38;5;82m‚ñÄ[38;5;46m‚ñÄ[38;5;47m‚ñÄ[38;5;48m‚ñÄ[38;5;49m‚ñÄ[38;5;50m‚ñÄ[38;5;51m‚ñÄ[38;5;45m‚ñÄ[38;5;39m‚ñÄ[38;5;33m‚ñÄ[38;5;27m‚ñÄ[0m  256 Color Gradient
[38;5;196m‚ñ†[38;5;202m‚ñ†[38;5;208m‚ñ†[38;5;214m‚ñ†[38;5;220m‚ñ†[38;5;226m‚ñ†[38;5;190m‚ñ†[38;5;154m‚ñ†[38;5;118m‚ñ†[38;5;82m‚ñ†[38;5;46m‚ñ†[38;5;47m‚ñ†[38;5;48m‚ñ†[38;5;49m‚ñ†[38;5;50m‚ñ†[38;5;51m‚ñ†[38;5;45m‚ñ†[38;5;39m‚ñ†[38;5;33m‚ñ†[38;5;27m‚ñ†[0m
```

```ansi:styled
[1;31m‚óè[0m [1;33m Bold Red + Bold Yellow[0m
[3;32m‚óè[0m [3;36m Italic Green + Italic Cyan[0m
[4;35m‚óè[0m [4;34m Underline Magenta + Underline Blue[0m
[1;3;4;37m‚óè[0m [1;3;4;37m Bold Italic Underline White[0m
[38;2;255;105;180m‚óè[0m [38;2;255;105;180m RGB Hot Pink[0m
[48;5;18;38;5;226m‚ñà[48;5;19;38;5;227m‚ñà[48;5;20;38;5;228m‚ñà[48;5;21;38;5;229m‚ñà[0m Background + Foreground
```

```ansi:amiex
[255D[6C[0;1;30m‚ñÑ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ  ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ‚ñÑ    ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ  ‚ñÑ    ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ    ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ
   ‚ñÑ ‚ñà‚ñà‚ñà‚ñÄ [0;31m‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ[0;33m‚ñÑ[0;31m‚ñÑ[0;33m‚ñÑ‚ñÑ [0;1;30m‚ñÄ‚ñà‚ñÑ‚ñà‚ñÄ [0;31m‚ñÑ‚ñÑ[0;33m‚ñÑ[0;31m‚ñÑ[0;33m‚ñÑ‚ñÑ [0;1;30m‚ñÄ‚ñà‚ñÑ‚ñÄ [0;31m‚ñÑ‚ñÑ[0;33m‚ñÑ[0;31m‚ñÑ[0;33m‚ñÑ‚ñÑ   [0;31m‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ[0;33m‚ñÑ[0;31m‚ñÑ[0;33m‚ñÑ‚ñÑ [0;1;30m‚ñÄ‚ñà‚ñÑ‚ñÑ
    ‚ñà‚ñà‚ñÄ [0;31m‚ñÑ‚ñÄ ‚ñë‚ñì‚ñí‚ñë[5C[0;1;31m‚ñÄ‚ñÑ [0;1;30m‚ñÄ [0;31m‚ñÑ‚ñÄ‚ñì‚ñë    [0;1;31m‚ñÄ‚ñÑ  [0;31m‚ñÑ‚ñÄ‚ñí‚ñì‚ñë   [0;1;31m‚ñÄ‚ñÑ  [0;31m‚ñë‚ñì‚ñí‚ñë    [0;1;31m‚ñÄ‚ñÑ [0;1;30m‚ñÄ‚ñà‚ñà‚ñÑ  [0;34m¬∑ ‚îÇ  ¬∑
   [0;1;30m‚ñÄ‚ñà‚ñà‚ñå[0;31m‚ñà    ‚ñí‚ñë[8C[0;33m‚ñà [0;31m‚ñÄ  ‚ñí[6C‚ñë[0;33m‚ñà    [0;31m‚ñí[6C[0;33m‚ñÄ‚ñÑ [0;31m‚ñí‚ñë[6C‚ñí[0;33m‚ñì [0;1;30m‚ñà‚ñà[5C[0;1;34m‚îÇ
    [0;1;30m‚ñê‚ñà‚ñå[0;31m‚ñà    ‚ñë[9C‚ñà    ‚ñë[6C‚ñí‚ñì    ‚ñë[6C‚ñë‚ñà ‚ñë[7C‚ñë‚ñí [0;1;30m‚ñê‚ñå[0;34m‚îÄ‚îÄ[0;1;34m‚îÄ‚îÄ[0;1m‚îÄ‚îº‚îÄ[0;1;34m‚îÄ‚îÄ[0;34m‚îÄ‚îÄ
    [0;1;30m‚ñà‚ñà [0;31m‚ñà‚ñë[5C[0;33m‚ñì[7C[0;31m‚ñà[11C‚ñë‚ñí[11C‚ñí‚ñà    ‚ñÑ[0;33m‚ñÑ[0;31m‚ñÑ[0;33m‚ñÑ‚ñÑ[0;1;31m‚ñÑ   [0;1;30m‚ñå¬∑ [0;34m¬∑  [0;1;34m‚îÇ [0;34m¬∑
    [0;1;30m‚ñê‚ñÑ [0;31m‚ñà‚ñí[5C[0;33m‚ñí[6C[0;31m‚ñë‚ñà[12C‚ñë[11C‚ñì‚ñà[5C‚ñë‚ñí   [0;1;31m‚ñë[8C[0;34m‚îÇ
   [0;1;30m¬∑ ‚ñå [0;31m‚ñà‚ñì[5C[0;33m‚ñë[6C[0;31m‚ñí‚ñà[24C‚ñí‚ñà[6C‚ñë  ‚ñë[0;33m‚ñì  [0;1;30m‚ñå [0m¬∑   [0;34m¬∑
    [0m¬∑  [0;31m‚ñà‚ñí[12C‚ñì‚ñà[24C‚ñë‚ñì[9C‚ñí‚ñì [0m¬∑  [0;1m¬∑
    [0;1;30m¬∑ r[0;31m‚ñì‚ñë[12C‚ñí‚ñà[25C‚ñí[9C‚ñì‚ñà   [0m¬∑  [0;1m¬∑
  [0m¬∑   [0;1;30mo[0;31m‚ñí   [0;1;30m¬∑[5C¬∑   [0;31m‚ñë‚ñà[14C[0;32m‚ñÑ‚ñà‚ñà‚ñà‚ñÑ[6C[0;31m‚ñë[9C‚ñí‚ñì [0;1;30m¬∑  ¬∑[0;1m¬∑  ¬∑
   [0m¬∑  [0;1;30my[0;31m‚ñë    [0;1;30m¬∑ ¬∑  [0;33m‚îÄ ‚îÄ‚îÄ [0;31m‚ñì [0;33m‚îÄ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [0;32m‚ñà‚ñà‚ñÄ[0;33m‚îÄ‚îÄ[0;32m‚ñÄ[0;1;33;42m‚ñÄ[1C[0;33m‚îÄ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [0;31m‚ñë‚ñí [0;33m‚îÄ‚îÄ ‚îÄ‚îÄ  ‚îÄ
 [0;1m¬∑  [0m¬∑    [0;1;30m¬∑[7C[0;31m‚ñë ‚ñë‚ñë ‚ñí ‚ñë ‚ñë‚ñë‚ñí‚ñí‚ñí‚ñí‚ñì‚ñÄ [0;32m‚ñà‚ñà‚ñà‚ñÑ  ‚ñÑ  [0;31m‚ñÄ [0;32m‚ñÑ[0;1;33m‚ñÑ [0;31m‚ñÄ‚ñà‚ñì‚ñì‚ñí‚ñí‚ñë‚ñë  ‚ñë ‚ñë‚ñë ‚ñë‚ñë  ‚ñë
   [0;1m¬∑   [0m¬∑    ¬∑    [0;33m‚îÄ ‚îÄ‚îÄ [0;31m‚ñë [0;33m‚îÄ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ [0;32m‚ñà‚ñà‚ñÑ ‚ñÄ[0;1;33m‚ñÄ[0;33m‚îÄ [0;32m‚ñÄ‚ñà‚ñÑ‚ñà‚ñÄ [0;33m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ ‚îÄ‚îÄ  ‚îÄ
[9C[0m¬∑[5C[0;1;30m¬∑   ¬∑[15C[0;32m‚ñÄ‚ñÄ‚ñà‚ñÑ   ‚ñÑ‚ñà‚ñà‚ñÑ[5C[0;33mTOOLZ
[12C[0;1m¬∑[27C[0;32m‚ñÑ‚ñà‚ñÄ ‚ñÄ‚ñà[0;1;33m‚ñÄ

[0m[255D
```

## Advanced Features

ANSI art supports:

- **8-color mode**: Basic ANSI colors (30-37, 90-97)
- **256-color mode**: Extended palette (ESC[38;5;Nm)
- **RGB mode**: True color (ESC[38;2;R;G;Bm)
- **Styles**: Bold, italic, underline, dim
- **Cursor positioning**: For complex layouts
- **.ans files**: Classic ANSI art files from the BBS era (use `skipConversion: true`)

Perfect for terminal-based graphics, logos, and retro ASCII art!

### Using .ans Files

To use classic `.ans` files (which already contain proper escape sequences):

```nim
# Pass 'true' as the 5th parameter to skip escape sequence conversion
drawAnsi(0, 10, 5, "amiex", true)
```

The `skipConversion` flag tells `drawAnsi()` not to convert `[` to `\x1b[` since `.ans` files already have the proper escape codes.
---
title: "ASCII Art Demo"
theme: "alleycat"
---

# ASCII Art Demo

This demo shows ASCII art support using tStorie's content blocks.

```nim on:init
# Load ASCII art into global variables using getContent()
var robotArt = getContent("ascii:robot")
var bannerArt = getContent("ascii:banner")
var frameArt = getContent("ascii:frame")
```

```nim on:render
clear()

# Basic ASCII Art
draw(0, 0, 0, "Basic ASCII Art:")
drawAscii(0, 1, 1, "robot")

# With Style
draw(0, 2, 12, "With Style:")
var style = getStyle("heading")
drawAscii(0, 2, 13, "banner", style)

# Manual processing with pre-loaded globals
draw(0, 40, 2, "Manual (using globals):")
var y = 3
for line in frameArt:
  draw(0, 40, y, line)
  y = y + 1
draw(0, 40, y + 1, "Lines: " & $(len(frameArt)))

# Show loaded art info
draw(0, 40, y + 3, "Loaded art pieces:")
draw(0, 40, y + 4, "  robot: " & $(len(robotArt)) & " lines")
draw(0, 40, y + 5, "  banner: " & $(len(bannerArt)) & " lines")
draw(0, 40, y + 6, "  frame: " & $(len(frameArt)) & " lines")
```

```ascii:robot
    ___
   [o_o]
   |\_/|
  //   \\
 (|     |)
/'\_   _/`\
\___)=(___/
```

```ascii:banner
 ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë
‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë
‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù
```

```ascii:frame
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë               ‚ïë
‚ïë   CONTENT     ‚ïë
‚ïë   GOES HERE   ‚ïë
‚ïë               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

```ascii:symbols
„äÄ „äÅ „äÇ „äÉ „äÑ „äÖ „äÜ „äá „äà „äâ „ää „äã „äå „äç „äé „äè „äê „äë „äí „äì „äî „äï „äñ „äó „äò „äô „äö „äõ „äú „äù „äû „äü „ä† „ä° „ä¢ „ä£ „ä§ „ä• „ä¶ „äß „ä® „ä© „ä™ „ä´ „ä¨ „ä≠ „äÆ „äØ „ä∞ ‚ûÄ ‚ûÅ ‚ûÇ ‚ûÉ ‚ûÑ ‚ûÖ ‚ûÜ ‚ûá ‚ûà ‚ûâ¬∑¬®‚Ä¶¬¶‚îÖ‚îÜ‚ûä ‚ûã ‚ûå ‚ûç ‚ûé ‚ûè ‚ûê ‚ûë ‚ûí ‚ûì Œ± …ê Œ≤ …î Âçê ‚Ñ¢ ¬© ¬Æ ¬ø ¬° ¬Ω ‚Öì ‚Öî ¬º ¬æ ‚Öõ ‚Öú ‚Öù ‚Öû ‚ÑÖ ‚Ññ ‚á® ‚ùù ‚ùû ‚ÑÉ ‚àÉ ‚îà ‚Ñë ‚àß ‚à† ‚à® ‚à© ‚äÇ ‚äÉ ‚à™ ‚ä• ‚àÄ Œû Œì …ô …ò Œµ …ü …• …Ø –∏ Œ∑ ‚Ñµ ‚Ñò ‡πè …π  Å ‚Ñú —è  å  ç Œª ‚Ñì —á ‚àû Œ£ Œ† ‚å• ‚åò ¬¢ ‚Ç¨ ¬£¬• ‚í∂ ‚í∑ ‚í∏ ‚íπ ‚í∫ ‚íª ‚íº ‚íΩ ‚íæ ‚íø ‚ìÄ ‚ìÅ ‚ìÇ ‚ìÉ ‚ìÑ ‚ìÖ ‚ìÜ ‚ìá ‚ìà ‚ìâ ‚ìä ‚ìã ‚ìå ‚ìç ‚ìé ‚ìè ‚ïß ‚ï® ‚ï§ ‚ï• ‚ïô ‚ìê ‚ìë ‚ìí ‚ìì ‚ìî ‚ìï ‚ìñ ‚ìó ‚ìò ‚ìô ‚ìö ‚ìõ ‚ìú ‚ìù ‚ìû ‚ìü ‚ì† ‚ì° ‚ì¢ ‚ì£ ‚ì§ ‚ì• ‚ì¶ ‚ìß ‚ì® ‚ì© ‚ïí ‚ïì ‚ï´ ‚ï™ ‚îò „ÉÑ ‚ôã ÏõÉ Ïú† Œ£ ‚äó ‚ôí ‚ò† ‚òÆ ‚òØ ‚ô† Œ© ‚ô§ ‚ô£ ‚ôß ‚ô• ‚ô° ‚ô¶ ‚ô¢ ‚ôî ‚ôï ‚ôö ‚ôõ ‚òÖ ‚òÜ ‚úÆ ‚úØ ‚òÑ ‚òæ ‚òΩ ‚ôè ‚ïò ‚îå ‚ï¨ ‚òº ‚òÄ ‚òÅ ‚òÇ ‚òÉ ‚òª ‚ò∫ €û €© ‚ô¨ ‚úÑ ‚úÇ ‚úÜ ‚úâ ‚ú¶ ‚úß ‚àû ‚ôÇ ‚ôÄ ‚òø ‚ù§ ‚ù• ‚ù¶ ‚ùß ‚Ñ¢ ¬Æ ¬© ‚úó ‚úò ‚äó ‚ôí ‚ñ¢ ‚ïõ ‚îê ‚îÄ ‚îº ‚ñ≤ ‚ñ≥ ‚ñº ‚ñΩ ‚óÜ ‚óá ‚óã ‚óé ‚óè ‚óØ Œî ‚óï ‚óî  ä œü ·É¶ Âõû ‚Ç™ ‚úì ‚úî ‚úï ‚úñ ‚ò¢ ‚ò£ ‚ò§ ‚ò• ‚ò¶ ‚òß ‚ò® ‚ò© ‚ò™ ‚ò´ ‚ò¨ ‚ò≠ ‚îî ‚î¥ ‚î¨ ‚îú ‚îä‚ï± ‚ï≤ ‚ï≥ ¬Ø ‚Äì ‚Äî ‚â° ·Éª ‚ñë ‚ñí ‚ñì ‚ñ§ ‚ñ• ‚ñ¶ ‚ñß ‚ñ® ‚ñ© ‚ñà ‚ñå ‚ñê ‚ñÄ ‚ñÑ ‚ó† ‚ó° ‚ï≠ ‚ïÆ ‚ïØ ‚ï∞ ‚îÇ ‚î§ ‚ï° ‚ï¢ ‚ïñ ‚ïï ‚ï£ ‚ïë ‚ïù ‚ïú ‚ïû ‚ïü ‚ïö ‚ïî ‚ï© ‚ï¶ ‚ï† ‚ïê { ÔΩ° ^ ‚óï ‚Äø ‚óï ^ ÔΩ° } ( ‚óï ^ ^ ‚óï ) ‚úñ ‚úó ‚úò ‚ôí ‚ô¨ ‚úÑ ‚úÇ ‚úÜ ‚úâ ‚ú¶ ‚úß ‚ô± ‚ô∞ ‚ôÇ ‚ôÄ‚òø ‚ù§ ‚ù• ‚ù¶‚ùß ‚Ñ¢ ¬Æ ¬© ‚ô° ‚ô¶ ‚ô¢ ‚ôî ‚ôï ‚ôö ‚ôõ ‚òÖ ‚òÜ ‚úÆ ‚úØ ‚òÑ ‚òæ ‚òΩ ‚òº ‚òÄ ‚òÅ ‚òÇ ‚òÉ ‚òª ‚ò∫ ‚òπ ‚òÆ €û €© Œµ —ó –∑ ‚òé ‚òè ¬¢ ‚òö ‚òõ ‚òú ‚òù ‚òû ‚òü ‚úç ‚úå ‚ò¢ ‚ò£ ‚ò† ‚òÆ ‚òØ ‚ô† ‚ô§ ‚ô£ ‚ôß ‚ô• ‚ô® ‡πë ‚ùÄ ‚úø œà ‚ôÜ ‚ò™ ‚ò≠ ‚ô™ ‚ô© ‚ô´  ä œü ·É¶ „ÉÑ Âõû ‚Ç™ Âçê ¬© ¬Æ ¬ø ¬° ¬Ω ‚Öì ‚Öî ¬º ¬æ ‚Öõ ‚Öú ‚Öù ‚Öû ‚ÑÖ ‚Ññ ‚á® ‚ùù ‚ùû ‚ÑÉ ‚ó† ‚ó° ‚ï≠ ‚ïÆ‚ïØ‚ï∞ ‚òÖ ‚òÜ ‚äô ¬§ „ä£ ‚òÖ ‚òÜ ‚ôÄ ‚óÜ ‚óá ‚Ñ¢ ‚ïë ‚ñº ‚ïí ‚ñ≤ ‚ó£ ‚ó¢ ‚ó• ‚ñº ‚ñ≥ ‚ñΩ ‚äø ‚ó§ ‚ó• ‚ñ≥ ‚ñ¥ ‚ñµ ‚ñ∂ ‚ñ∑ ‚ñ∏ ‚ñπ ‚ñ∫ ‚ñª ‚ñº ‚ñΩ ‚ñæ ‚ñø ‚óÄ ‚óÅ ‚óÇ ‚óÉ ‚óÑ ‚óÖ ‚ñÜ ‚ñá ‚ñà ‚ñà ‚ñ† ‚ñì Âõû ‚ñ° „Äì ‚â°‚òå ‚ïù‚ïö‚ïî‚ïó‚ï¨ ‚ïê‚ïì‚ï© ‚î†‚î®‚îØ‚î∑‚îè ‚îì‚îó‚îõ‚î≥‚ä• ÔπÉÔπÑ‚îå ‚îê‚îî‚îò‚àü„Äå „Äç‚Üë‚Üì‚Üí ‚Üê‚Üò‚Üô‚ôÄ ‚ôÇ‚îá‚îÖÔπâÔπä ÔπçÔπé‚ï≠‚ïÆ‚ï∞‚ïØ *^_^* ^*^ ^-^ ^_^ ^Ô∏µ^‚àµ‚à¥‚Äñ Ô∏±Ô∏≥Ô∏¥Ôπè ÔπãÔπå‚ôÇ‚ôÄ ‚ô•‚ô°‚òú‚òû‚òé ‚òè‚äô‚óé‚ò∫‚òª ‚ñ∫‚óÑ‚ñß‚ñ® ‚ô®‚óê‚óë‚Üî‚Üï ‚ñ™‚ñ´‚òº‚ô¶‚ñÄ ‚ñÑ‚ñà‚ñå‚ñê ‚ñë‚ñí‚ñ¨‚ô¶‚óä ‚ó¶ ‚òº ‚ô† ‚ô£ ‚ñ£ ‚ñ§‚ñ•‚ñ¶‚ñ© „ÅÉ‚óò‚óô‚óà‚ô´ ‚ô¨‚ô™‚ô©‚ô≠‚ô™ „ÅÆ‚òÜ‚Üí„ÅÇ Ôø°‚ù§ÔΩ°‚óï‚Äø ‚óïÔΩ°‚úé‚úü‡Æê ‚âà‡πë€© €©.. ..€©€©‡πë ‡πë€©€û€©‡πë ‚ú≤‚ùà‚ûπ ~.~‚óï ‚Äø-ÔΩ°‚òÄ‚òÇ‚òÅ „Äê„Äë‚î±‚î≤‚ù£ ‚úö‚ú™‚ú£ ‚ú§‚ú• ‚ú¶‚ùâ ‚ù•‚ù¶‚ùß‚ùÉ ‚ùÇ‚ùÅ‚ùÄ‚úÑ‚ò™ ‚ò£‚ò¢‚ò†‚ò≠‚ôà ‚û∏‚úì‚úî‚úï ‚úñ„äö„äõ *.:ÔΩ° ‚úø*Ôæü‚ÄòÔæüÔΩ• ‚äô¬§„ä£‚òÖ‚òÜ ‚ôÄ‚óÜ‚óá ‚ó£‚ó¢‚ó•‚ñ≤‚ñ≥‚ñΩ‚äø‚ó§ ‚ó•‚ñÜ‚ñá ‚ñà‚ñà‚ñ†‚ñì Âõû‚ñ°„Äì‚â°‚ïù ‚ïö‚ïî‚ïó ‚ï¨‚ïê‚ïì‚ï© ‚î†‚î®‚îØ‚î∑‚îè ‚îì‚îó‚îõ ‚î≥‚ä•ÔπÉÔπÑ ‚îå‚îê‚îî‚îò‚àü „Äå„Äç‚Üë‚Üì ‚Üí ‚Üê ‚Üò ‚Üô‚ôÄ‚ôÇ‚îá‚îÖÔπâ ÔπäÔπçÔπé ‚ï≠‚ïÆ‚ï∞‚ïØ *^_^* ^*^ ^-^ ^_^ ^Ô∏µ^‚àµ ‚à¥‚Äñ Ô∏±Ô∏≥ Ô∏¥ÔπèÔπãÔπå ‚ôÇ‚ôÄ‚ô•‚ô°‚òú ‚òû‚òé‚òè‚äô ‚óé‚ò∫‚òª‚ñ∫‚óÑ ‚ñß‚ñ®‚ô®‚óê‚óë ‚Üî‚Üï‚ñ™‚ñ´ ‚òº‚ô¶‚ñÄ‚ñÑ‚ñà ‚ñå‚ñê‚ñë‚ñí‚ñ¨ ‚ô¶‚óä‚ó¶‚òº ‚ô†‚ô£‚ñ£‚ñ§‚ñ• ‚ñ¶‚ñ©„ÅÉ‚óò‚óô ‚óà‚ô´‚ô¨‚ô™ ‚ô©‚ô≠‚ô™„ÅÆ‚òÜ ‚Üí„ÅÇÔø°‚ù§ÔΩ° ‚óï‚Äø‚óïÔΩ° ‚úé‚úü‡Æê‚âà ‡πë€©€©.. ..€© ‚úâ ‚úç ‚úé ‚úè ‚úê‡πë‚ú≤‚ùà ‚ûπ ~.~‚óï‚Äø-ÔΩ° ‚òÄ‚òÇ‚òÅ„Äê„Äë ‚î±‚î≤‚ù£‚úö ‚ú™‚ú£‚ú§‚ú• ‚ú¶‚ùâ‚ù•‚ù¶ ‚ùß‚ùÉ‚ùÇ‚ùÅ‚ùÄ ‚úÑ‚ò™‚ò£‚ò¢‚ò† ‚ò≠‚ôà‚û∏‚úì‚úî‚úï‚úñ„äö „äõ‚ôß‚ô§‚ôß‚ô°‚ô¨‚ô™*.:ÔΩ°‚úø*Ôæü ‚ÄòÔæüÔΩ• ‚óä‚ô•‚ï†‚ïê‚ïù‚ñ´‚ñ†‡πë¬ª¬´¬∂‡Æê¬©‚Ä† Œµ√Ø–∑‚ô™·É¶‚ô£ ‚ô†‚Ä¢¬± ¬∞‚Ä¢‡∏¥.‚Ä¢‡Æê ‡Æá * √ó ‚óã ‚ñ´ ‚úë ‚úí ‚å® €© ‡πë ‡πë€© €û €© ‚î≠‚îÆ‚îØ‚ôÇ ‚Ä¢ ‚ôÄ ‚óä ¬© ¬§ ‚ñ≤ ‚Üî ‚Ñ¢ ¬Æ ‚òé Œµ —ó –∑ ‚ô® ‚òè ‚òÜ ‚òÖ ‚ñΩ ‚ñ≥ ‚ñ≤ ‚àµ ‚à¥ ‚à∑ ÔºÉ ‚ôÇ ‚ôÄ ‚ô• ‚ô† ‚ô£ ‚òπ ‚ò∫ ‚òª‚îå ‚îç‚îé ‚îè ‚îê ‚îë‚îì ‚ô≠‚ô´‚ô™Ôª¨‡Æê·É¶ ‚Üî‚Üï‚Üò‚Ä¢‚Ä¢‚óè ¬§‚ï¨Ôπå‚ñΩ‚òú‚ô•‚òû ‚ô¨‚úû‚ô•‚ôï‚òØ‚ò≠‚ò†‚òÉ ‚îÄ ‚îÅ ‚îÇ ‚îÉ ‚îÑ ‚îÖ ‚îÜ ‚îá ‚îà ‚îâ ‚îä ‚îã ‚â® ‚â©‚ï®‚ï© ‚ï™ ‚ï´ ‚ï¨‚ïè‚ïê‚âÇ ‚âÉ ‚âÑ ‚âÖ ‚âÜ ‚âá ‚âà ‚ââ ‚âä ‚âã ‚âå ‚âç ‚âé ‚âè ‚âê ‚âë ‚âí ‚âì ‚âî ‚âï ‚âñ ‚âó ‚âò ‚âô ‚âö ‚âõ ‚âú ‚âù ‚âû ‚âü ‚â† ‚â°‚â¢ ‚â£ ‚â§ ‚â• ‚â¶‚âß‚êõ ‚ê° ‚êö ‚êü ‚êò ‚ê† ‚ê§ ‚êã ‚êå ‚êç ‚êé ‚êè ‚êê ‚êë ‚êí ‚êì ‚êî ‚êï ‚êñ ‚êó ‚êô ‚êú ‚êù ‚êû‚ï£ ‚ï§ ‚ï• ‚ï¶ ‚ïß ‚ïó ‚ïò ‚ïô ‚ïö ‚ïõ‚ï° ‚îº ‚îΩ ‚îæ ‚îø ‚ïÄ ‚ïÅ ‚ïÇ ‚ïÉ ‚ïì ‚ïî ‚ïï ‚ïñ ‚ôà ‚ôâ ‚ôä ‚ôã ‚ôå ‚ôç ‚ôé ‚ôè ‚ôê ‚ôë ‚ôí ‚ôì ‚ïÆ ‚ïØ ‚ï∞ ‚ï± ‚ï≤ ‚ï≥ ‚Äü ‚Ä†‚Ä°‚Ä¢‚Ä£‚ñÄ ‚ñÅ ‚ñÇ ‚ñÉ ‚ñÑ ‚ñÖ ‚ñÜ ‚ñá ‚ñà ‚ñâ ‚ñä ‚ñã ‚ñå ‚ñç ‚ñé ‚ñè ‚ñê ‚ñë ‚ñí ‚ñì ‚ñî ‚ñï ‚ñ† ‚ñ° ‚ñ¢ ‚ñ£ ‚ñ§ ‚ñ• ‚ñ¶ ‚ñß ‚ñ® ‚ñ© ‚ñ™ ‚ñ´ ‚ñ¨ ‚ñ≠‚ñÆ‚ñØ‚ï≠ ‚óû ‚óü ‚ó† ‚ó° ‚ó¢ ‚ó£ ‚ôî ‚ôï ‚ôñ ‚ôó ‚ôò ‚ôô ‚ôö ‚ôõ ‚ôù ‚ôû ‚ôü ‚ô† ‚ô° ‚ô¢ ‚ô£ ‚òî ‚òï ‚òñ ‚òó ‚òò ‚òô ‚òä ‚òã ‚òå ‚òç ‚òé ‚òè‚òê ‚ï¥ ‚ïµ ‚ï∂ ‚ï∑ ‚ï∏ ‚ïπ ‚ï∫ ‚ïª ‚ïº ‚ïΩ ‚ïæ ‚ïø ‚ñ∞ ‚ñ± ‚óÜ ‚óá ‚óà ‚óâ ‚óä ‚óã ‚óå ‚óç ‚óé ‚óè ‚óê ‚óë ‚óí ‚óì ‚óî ‚óï ‚óñ ‚óó ‚óò ‚óô ‚óö ‚óõ ‚óú ‚óù ‚ó§ ‚ó• ‚ó¶ ‚óß ‚ó® ‚ó© ‚ó™ ‚ó´ ‚ó¨ ‚ó≠ ‚óÆ ‚óØ‚óΩ ‚óæ ‚óø ‚òÄ ‚òÅ ‚òÇ ‚òÉ ‚òÑ ‚òÖ ‚òÜ ‚òá ‚òà ‚òâ ‚òë ‚òí ‚òì ‚ôÖ ‚ôÜ ‚ôá‚ôú ‚áú ‚áù ‚áû ‚áü ‚á† ‚á°‚á¢‚á£‚òü ‚ò† ‚ò° ‚ò¢ ‚ò£ ‚ò§ ‚ò• ‚ò¶ ‚òß ‚ò® ‚ò© ‚ò™ ‚ò´ ‚ò¨ ‚ò≠ ‚òÆ ‚òØ ‚ò∞ ‚ò± ‚ò≤ ‚ò≥ ‚ò¥ ‚òµ ‚ò∂ ‚ò∑ ‚ò∏ ‚òπ ‚ò∫ ‚òª ‚òº ‚òΩ ‚òæ ‚òø ‚ôÄ ‚ôÅ ‚ôÇ ‚ôÉ ‚ôÑ‚Ñï‚ô§ ‚ô• ‚ô¶ ‚ôß ‚ô® ‚ô© ‚ô™ ‚ô´ ‚ô¨ ‚ô≠ ‚ôÆ ‚ôØ ‚ô∞ ‚ô± ¬¥ ·øæ ‚Äê ‚Äë ‚Äí ‚Äì ‚Äî ‚Äï ‚Äñ ‚Äó ‚Äò ‚Äô ‚Äö ‚Äõ ‚Äú ‚Äù ‚Äû ‚Ñã ‚Ñå ‚Ñç ‚Ñé ‚Ñè ‚Ñê ‚Ñë ‚Ñí ‚Ñì ‚Ñî‚Ä§ ‚Ä• ‚Ä¶ ‚Äß ‚Ä∞ ‚Ä± ‚Ä≤ ‚Ä≥ ‚Ä¥ ‚Äµ ‚Ä∂ ‚Ä∑ ‚Ä∏ ‚Äπ ‚Ä∫ ‚Äª ‚Äº ‚ÄΩ ‚Äæ ‚Äø ‚ÅÄ ‚ÅÅ ‚ÅÇ ‚ÅÉ ‚ÅÑ ‚ÅÖ ‚ÅÜ ‚Åë ‚Åû ‚Ç† ‚Ç° ‚Ç¢ ‚Ç£ ‚Ç§ ‚Ç• ‚Ç¶ ‚Çß ‚Ç® ‚Ç© ‚Ç™ ‚Ç´ ‚Ç¨ ‚Ç≠‚ÇÆ ‚ÇØ ‚ÑÄ ‚ÑÅ ‚ÑÇ ‚ÑÉ ‚ÑÑ ‚ÑÖ ‚ÑÜ ‚Ñá ‚Ñà ‚Ñâ ‚Ñä ‚Ññ ‚Ñó ‚Ñò ‚Ñô ‚Ñö ‚Ñõ ‚Ñú ‚Ñù ‚Ñû ‚Ñü ‚Ñ† ‚Ñ° ‚Ñ¢ ‚Ñ£ ‚Ñ§ ‚Ñ• Œ© ‚Ñß ‚Ñ® ‚Ñ© K √Ö ‚Ñ¨ ‚Ñ≠ ‚ÑÆ ‚ÑØ‚Ñ∞ ‚Ñ± ‚Ñ≤ ‚Ñ≥ ‚Ñ¥ ‚Ñµ ‚Ñ∂ ‚Ñ∑ ‚Ñ∏ ‚Öç ‚Öé ‚Öì ‚Öî ‚Öï ‚Öñ ‚Öó ‚Öò ‚Öô ‚Öö ‚Öõ ‚Öú ‚Öù ‚Öû ‚Öü ‚áç ‚áé ‚â∫ ‚âª ‚âº ‚âΩ ‚âæ ‚âø ‚äÄ ‚àè ‚àê ‚àë ‚àí‚àì‚Å∞ ‚Å± ‚Å≤ ‚Å≥ ‚Å¥ ‚Åµ ‚Å∂ ‚Å∑ ‚Å∏ ‚Åπ ‚Å∫ ‚Åª ‚Åº ‚ÅΩ ‚Åæ ‚Åø ‚ÇÄ ‚ÇÅ ‚ÇÇ ‚ÇÉ ‚ÇÑ ‚ÇÖ ‚ÇÜ ‚Çá ‚Çà ‚Çâ ‚Çä ‚Çã ‚Çå ‚Çç ‚Çé ‚á§ ‚á• ‚á¶ ‚áß ‚á® ‚á© ‚á™ ‚áπ ‚á∫ ‚áª ‚áº ‚áΩ ‚àî ‚Ü∂‚Çê ‚Çë ‚Çí ‚Çì ‚Çî‚Ö† ‚Ö° ‚Ö¢ ‚Ö£ ‚Ö§ ‚Ö• ‚Ö¶ ‚Öß ‚Ö® ‚Ö© ‚Ö™ ‚Ö´ ‚Ö¨ ‚Ö≠ ‚ÖÆ ‚ÖØ ‚Ö∞ ‚Ö± ‚Ö≤ ‚Ö≥ ‚Ö¥ ‚Öµ ‚Ö∂ ‚Ö∑ ‚Ö∏ ‚Öπ ‚Ö∫ ‚Öª ‚Öº ‚ÖΩ ‚Öæ ‚Öø ‚ï¢ ‚Üµ ‚Ü∑‚Üê ‚Üë ‚Üí ‚Üì ‚Üî ‚Üï ‚Üñ ‚Üó ‚Üò ‚Üô ‚Üö ‚Üõ ‚Üú ‚Üù ‚Üû ‚Üü ‚Ü† ‚Ü° ‚Ü¢ ‚Ü£ ‚Ü§ ‚Ü• ‚Ü¶ ‚Üß ‚Ü® ‚Ü© ‚Ü™ ‚Ü´ ‚Ü¨ ‚Ü≠ ‚ÜÆ ‚ÜØ ‚Ü∞ ‚Ü± ‚Ü≤ ‚Ü≥‚Ü¥ Ôø° ‚Ü∏ ‚Üπ ‚Ü∫ ‚Üª ‚Üº ‚ÜΩ ‚Üæ ‚Üø ‚áÄ ‚áÅ ‚áÇ ‚áÉ ‚áÑ ‚áÖ ‚áÜ ‚áá ‚áà ‚áâ ‚áä ‚áã ‚áå‚áè ‚áê ‚áë ‚áí ‚áì ‚áî ‚áï ‚áñ ‚áó ‚áò ‚áô ‚áö ‚áõ ‚àΩ‚àæ‚ä£ ‚ä§‚á´ ‚á¨ ‚á≠ ‚áÆ ‚áØ ‚á∞ ‚á± ‚á≤ ‚á≥ ‚á¥ ‚áµ ‚á∂ ‚á∑ ‚á∏ ‚áæ ‚áø ‚àÄ ‚àÅ ‚àÇ ‚àÉ ‚àÑ ‚àÖ ‚àÜ ‚àá ‚àà ‚àâ ‚àä ‚àã ‚àå ‚àç ‚àé ‚óô ‚ñ§‚ñ•‚ñ¶‚ñß‚ñ® ‚ñ© ‚ô§ ‚ôß‚ô°‚àï ‚àñ ‚àó ‚àò ‚àô ‚àö ‚àõ ‚àú ‚àù ‚àû ‚àü ‚à† ‚à° ‚à¢ ‚à£ ‚à§ ‚à• ‚à¶ ‚àß ‚à® ‚à© ‚à™ ‚à´ ‚à¨ ‚à≠ ‚àÆ ‚àØ ‚à∞ ‚à± ‚à≤ ‚à≥ ‚à¥ ‚àµ ‚à∂ ‚à∑ ‚à∏ ‚àπ ‚à∫ ‚àª ‚àº ‚àø ‚âÄ ‚âÅ ‚â™ ‚â´ ‚â¨ ‚â≠ ‚âÆ ‚âØ ‚â∞ ‚â± ‚â≤ ‚â≥ ‚â¥ ‚âµ ‚â∂ ‚â∑ ‚â∏ ‚âπ ‚Åá ‚Åà ‚Åâ ‚Äº ‚ÄΩ ‚Åá ‚Åà ‚Åâ ‚Äº ‚ÄΩ ‚Ñ¢ ¬© ¬Æ‚çò ‚çô ‚ô¨ ‚ô≠ ‚ôÆ ‚ôØ‚ô∞‚ô±‚äÅ ‚äÇ ‚äÉ ‚äÑ ‚äÖ ‚äÜ ‚äá ‚äà ‚äâ ‚ää ‚äã ‚äå ‚äç ‚äé ‚äè ‚äê ‚äë ‚äí ‚äì ‚äî ‚äï ‚äñ ‚äó ‚äò ‚äô ‚äö ‚äõ ‚äú ‚äù ‚äû ‚äü ‚ä† ‚ä° ‚ä¢‚ä•‚åï‚åñ ‚ä¶ ‚äß ‚ä® ‚ä© ‚ä™ ‚ä´ ‚ä¨ ‚ä≠ ‚äÆ ‚äØ ‚ä∞ ‚ä± ‚ä≤ ‚ä≥ ‚ä¥ ‚äµ ‚ä∂ ‚ä∑ ‚ä∏ ‚äπ ‚ä∫ ‚äª ‚îå ‚îç ‚îé ‚îè ‚îê ‚îë ‚îí ‚îì‚ãü ‚ã† ‚ã° ‚ã¢ ‚ã£ ‚åì‚åî‚äº ‚äΩ ‚äæ ‚äø ‚ãÄ ‚ãÅ ‚ãÇ ‚ãÉ ‚ãÑ ‚ãÖ ‚ãÜ ‚ãá ‚ãà ‚ãâ ‚ãä ‚ãã ‚ãå ‚ãç ‚ãé ‚ãè ‚ãê ‚ãë ‚ãí ‚ãì ‚ãî ‚ãï ‚ãñ ‚ãó ‚ãò ‚ãô ‚ãö ‚ãõ ‚ãú ‚ãù ‚ãû ‚ô§ ‚ô•‚ô¶‚ôß‚ô® ‚ã§ ‚ã• ‚ã¶ ‚ãß ‚ã® ‚ã© ‚ã™ ‚ã´ ‚ã¨ ‚óê ‚óë ‚ò¢ ‚äó ‚äô ‚óò‚ùÉ ‚ùÇ ‚óã ‚óé ‚óè ‚óØ ‚óï ‚óî ‚îÑ ‚îÖ ‚îÜ ‚îá ‚îà ‚îâ ‚îä ‚îã ‚ô© ‚ô™ ‚ô´ ‚ôú ‚ôù‚ã≠ ‚ãÆ ‚ãØ ‚ã∞ ‚ã± ‚ã≤ ‚ã≥ ‚ã¥ ‚ãµ ‚ã∂ ‚ã∑ ‚ã∏ ‚ãπ ‚ã∫ ‚ãª ‚ãº ‚ãΩ ‚ãæ ‚ãø ‚åÄ ‚åÅ ‚åÇ ‚åÉ ‚åÑ ‚åÖ ‚åÜ ‚åá ‚åà ‚åâ ‚åä ‚åã ‚åå ‚åç‚Äì „Å± ‚åé ‚åê ‚åë‚åí‚ôî ‚ôï ‚åó ‚åò ‚åô ‚åö ‚åõ ‚åú ‚ñë ‚ñí ‚ñì ‚ñî ‚ñï ¬™ ‚ÜÄ ‚ÜÅ ‚ÜÇ ‚ÜÉ ‚ÜÑ ‚ÜÖ‚çö ‚êã ‚ê¢ ‚ê£ ‚îÄ ‚îÅ ‚îÇ ‚îÉ ‚åæ ‚åø ‚çÄ ‚çÅ‚ôû ‚ôü ‚ô† ‚ô° ‚ô¢‚ô£‚åù ‚åû ‚åü ‚å† ‚å° ‚å¢ ‚å£ ‚å§ ‚å• ‚å¶ ‚åß ‚å® „Äà „Äâ ‚å´ ‚å¨ ‚å≠ ‚åÆ ‚åØ ‚å∞ ‚å± ‚å≤ ‚å≥ ‚å¥ ‚åµ ‚å∂ ‚å∑ ‚å∏ ‚åπ ‚å∫ ‚åª ‚åº ‚åΩ ‚çÇ ‚çÉ ‚çÑ ‚çÖ ‚çÜ ‚çá ‚çà ‚çâ ‚çä ‚çã ‚çå ‚çç ‚çé ‚çè ‚çê ‚çë ‚çí ‚çì ‚çî ‚çï ‚çñ ‚çó ‚ôé ‚ôè ‚ôê ‚ôë ‚ôí ‚ôì ‚ôñ ‚ôó ‚ôò ‚ôô‚ôö‚ôõÈ†π ‚Äì Ë°ô ‚Äì Êµ≥ ‚Äì Êµ§ ‚Äì Êê∞ ‚Äì ÁÖ§ ‚Äì Ê¥≥ ‚Äì Ê©± ‚Äì Ê©± ‚Äì ÁÖ™ ‚Äì „ç± ‚Äì ÁÖ± ‚Äì Îëª ‚Äì Áù§ ‚Äì „åπ ‚Äì Ê•§ ‚Äì „Å± ‚Äì - Ê§π‚Äì Áï± ‚Äì ÁÖµ ‚Äì Áî∞ ‚Äì „Å§ ‚Äì ÁÖµ ‚Äì Ïóå ‚Äì Â´† ‚Äì ÏØ¶ ‚Äì Ê°à ‚Äì Ëøé ‚Äì ÊòØ ‚Äì Âæû ‚Äì ‰∫ã ‚Äì Á∂≤ ‚Äì È†Å ‚Äì Ë®≠ ‚Äì Ë®à ‚Äì Á∞°
```---
title: "TStorie Audio Node Demo"
author: "Maddest Labs"
targetFPS: 60
---

# Web Audio Node Graph Demo

Test TStorie's procedural audio system!

Press keys to create sounds:
- **1-8** - Play musical scale (C major)
- **Q** - Quick beep (440Hz)
- **W** - Laser sweep  
- **E** - Sawtooth tone
- **Space** - Jump sound effect

```nim on:init
# Track what sound is playing for display
var lastSound = "none"
var soundTimer = 0.0
var frameTime = 1.0 / 60.0
```

```nim on:render
clear()

# Title
draw(0, 2, 2, "TStorie Procedural Audio Demo")
draw(0, 2, 3, "==============================")
draw(0, 2, 4, "(Pure code-generated sounds)")

# Instructions
var y = 6
draw(0, 2, y, "Procedural audio system:")
y = y + 2
draw(0, 4, y, "[1-8] Musical scale (sine waves)")
y = y + 1
draw(0, 4, y, "[Q] Quick beep (440Hz)")
y = y + 1
draw(0, 4, y, "[W] Laser effect")
y = y + 1
draw(0, 4, y, "[E] Sawtooth tone")
y = y + 1
draw(0, 4, y, "[Space] Jump sound")

# Show what just played
y = y + 3
if soundTimer > 0.0:
  soundTimer = soundTimer - frameTime
  draw(0, 2, y, "Playing: " & lastSound)
else:
  draw(0, 2, y, "Press keys to create sounds...")

# Info
y = y + 2
draw(0, 2, y, "How it works:")
draw(0, 4, y + 1, "Sounds generated in real-time from code")
draw(0, 2, y + 3, "No audio files needed!")
```

```nim on:input
if event.type == "text":
  var ch = event.text
  
  # Musical scale (C major) - using simple tones
  if ch == "1":
    audioPlayTone(261.63, 0.3, "sine", 0.3)  # C4
    lastSound = "C4 (261.63 Hz)"
    soundTimer = 1.0
  elif ch == "2":
    audioPlayTone(293.66, 0.3, "sine", 0.3)  # D4
    lastSound = "D4 (293.66 Hz)"
    soundTimer = 1.0
  elif ch == "3":
    audioPlayTone(329.63, 0.3, "sine", 0.3)  # E4
    lastSound = "E4 (329.63 Hz)"
    soundTimer = 1.0
  elif ch == "4":
    audioPlayTone(349.23, 0.3, "sine", 0.3)  # F4
    lastSound = "F4 (349.23 Hz)"
    soundTimer = 1.0
  elif ch == "5":
    audioPlayTone(392.00, 0.3, "sine", 0.3)  # G4
    lastSound = "G4 (392.00 Hz)"
    soundTimer = 1.0
  elif ch == "6":
    audioPlayTone(440.00, 0.3, "sine", 0.3)  # A4
    lastSound = "A4 (440.00 Hz)"
    soundTimer = 1.0
  elif ch == "7":
    audioPlayTone(493.88, 0.3, "sine", 0.3)  # B4
    lastSound = "B4 (493.88 Hz)"
    soundTimer = 1.0
  elif ch == "8":
    audioPlayTone(523.25, 0.3, "sine", 0.3)  # C5
    lastSound = "C5 (523.25 Hz)"
    soundTimer = 1.0
  
  # Quick beep
  elif ch == "q" or ch == "Q":
    audioPlayBleep(440.0, 0.3)
    lastSound = "Quick beep"
    soundTimer = 1.0
  
  # Sweep effects - different waveforms
  elif ch == "w" or ch == "W":
    audioPlayLaser(0.4)
    lastSound = "Laser sweep up"
    soundTimer = 1.0
  
  elif ch == "e" or ch == "E":
    audioPlayTone(800.0, 0.3, "sawtooth", 0.4)
    lastSound = "Sawtooth tone"
    soundTimer = 1.0

elif event.type == "keydown" and event.key == "Space":
  # Play a game sound effect
  audioPlayJump(0.4)
  lastSound = "Jump sound"
  soundTimer = 1.0
```

---

## Features Demonstrated

This example shows:

1. **Built-in Audio Functions** - Ready-to-use sound effects
2. **Game Sound Effects** - Jump, landing, hit, power-up, laser
3. **Musical Tones** - Generate specific frequencies (notes)
4. **Instant Playback** - No latency, sounds play immediately
5. **Simple API** - Just call the function, no setup needed

## Under the Hood

The audio system uses:

- **Pure Nim synthesis** - No external dependencies
- **Multiple waveforms** - Sine, square, sawtooth, triangle, noise
- **ADSR envelopes** - Professional sound shaping
- **Frequency sweeps** - For dynamic effects like jumps
- **Web Audio API** - Native browser support (WASM)
- **Procedural generation** - Sounds created in code, not files

## Available Audio Functions

TStorie provides these audio functions in markdown files:

- `audioPlayJump(volume)` - Jump sound effect
- `audioPlayLanding(volume)` - Landing sound effect  
- `audioPlayHit(volume)` - Hit/damage sound effect
- `audioPlayPowerUp(volume)` - Power-up sound effect
- `audioPlayLaser(volume)` - Laser sound effect
- `audioPlayBleep(frequency, volume)` - Simple beep tone
- `audioPlayTone(frequency, duration, waveform, volume)` - Custom tone
  - Waveforms: "sine", "square", "sawtooth", "triangle", "noise"

All volume parameters are optional and default to sensible values (0.35-0.5).

## Next Steps

Once you've tested the basics, you can:

1. Use `audioPlayTone()` for custom sound effects with different waveforms
2. Experiment with frequencies and durations to create unique sounds
3. Build interactive games with audio feedback
4. Create music sequencers using the tone functions
---
title: "Bloxes Proof-of-Concept"
author: "Maddest Labs"
minWidth: 28
minHeight: 12
theme: "outrun"
emoji: "‚¨õ‚¨úüî≤üò∂üü®‚ùé"
hideHeadings: "true"
---

# Intro
‚†Ä
```lvl
#####
#   #
# O #
# . #
# @ #
#####
```
‚†Ä
- [Next Level](#two_boxes) | [?](#instructions)

# Two Boxes
‚†Ä
```lvl
#######
#  .  #
# O O #
#  .  #
#  @  #
#######
```
‚†Ä
- [Next Level](#the_corridor) | [?](#instructions)

# The Corridor
‚†Ä
```lvl
########
###    #
### OO #
### .  #
#  .@ ##
#    ###
########
```

- [Next Level](#cross_pattern) | [?](#instructions)

# Cross Pattern
‚†Ä
```lvl
#########
####.####
### O####
##  O  ##
# .@O.  #
## .O   #
####O ###
####.####
#########
```

- [Restart](#intro) | [?](#instructions)

# Instructions
```nim on:enter
contentClear()
contentWrite("-" & playerChar & " You are the player")
contentWrite("-" & boxChar & " Push bloxes onto goals")
contentWrite("-" & goalChar & " Goal markers")
contentWrite("-" & boxOnGoalChar & " Blox on goal")
contentWrite("-" & wallChar & " Walls")
```
‚†Ä
- You can only push bloxes, not pull them
- You cannot push two bloxes at once
- Get all bloxes onto the goal markers to win!
‚†Ä
- [Play Level 1](#intro)

```nim on:init
# Initialize canvas system
initCanvas(0)

# Debug state
var lastMouseX = -1
var lastMouseY = -1
var lastBufferX = -1
var lastBufferY = -1
var lastGridX = -1
var lastGridY = -1

# Game state
var playerX = 0
var playerY = 0
var boxes = []  # Each box is [x, y]
var goals = []  # Each goal is [x, y]
var walls = []  # Each wall is [x, y]
var levelWidth = 0
var levelHeight = 0
var moveCount = 0
var gameWon = false
var nextMoveDX = 0
var nextMoveDY = 0
var currentLevelData = ""

# Emoji characters from front matter
var emptyChar = "‚¨õ"
var wallChar = "‚¨ú"
var boxChar = "üî≤"
var playerChar = "üò∂"
var goalChar = "üü®"
var boxOnGoalChar = "‚ùé"

# Load emoji from front matter if defined
if len(emoji) > 0:
  # Parse emoji string (each emoji can be multiple bytes)
  var emojiList = []
  var i = 0
  while i < len(emoji):
    var b = ord(emoji[i])
    
    var charLen = 1
    # Detect UTF-8 character length based on first byte
    if b < 128:
      charLen = 1
    elif b >= 192 and b < 224:
      charLen = 2
    elif b >= 224 and b < 240:
      charLen = 3
    elif b >= 240:
      charLen = 4
    
    var endIdx = i + charLen
    if endIdx > len(emoji):
      endIdx = len(emoji)
    
    var ch = ""
    var j = i
    while j < endIdx:
      ch = ch & emoji[j]
      j = j + 1
    
    emojiList = emojiList + [ch]
    i = endIdx
  
  # Assign emoji to variables (order: empty, wall, box, player, goal, boxOnGoal)
  if len(emojiList) > 0:
    emptyChar = emojiList[0]
  if len(emojiList) > 1:
    wallChar = emojiList[1]
  if len(emojiList) > 2:
    boxChar = emojiList[2]
  if len(emojiList) > 3:
    playerChar = emojiList[3]
  if len(emojiList) > 4:
    goalChar = emojiList[4]
  if len(emojiList) > 5:
    boxOnGoalChar = emojiList[5]

# Parse level from string
proc parseLevel(levelData: string) =
  boxes = []
  goals = []
  walls = []
  playerX = 0
  playerY = 0
  moveCount = 0
  gameWon = false
  
  if len(levelData) > 0:
    var lines = splitLines(levelData)
    levelHeight = len(lines)
    levelWidth = 0
    
    var y = 0
    while y < len(lines):
      var line = lines[y]
      if len(line) > levelWidth:
        levelWidth = len(line)
      
      var x = 0
      while x < len(line):
        var ch = ""
        if x < len(line):
          ch = ch & line[x]
        
        if ch == "@":
          playerX = x
          playerY = y
        elif ch == "O":
          boxes = boxes + [[x, y]]
        elif ch == ".":
          goals = goals + [[x, y]]
        elif ch == "#":
          walls = walls + [[x, y]]
        
        x = x + 1
      y = y + 1

# Check if position has a wall
proc hasWall(x: int, y: int): bool =
  if x < 0 or y < 0 or x >= levelWidth or y >= levelHeight:
    return true
  var i = 0
  while i < len(walls):
    if walls[i][0] == x and walls[i][1] == y:
      return true
    i = i + 1
  return false

# Check if position has a box
proc hasBox(x: int, y: int): bool =
  # Bounds check first
  if x < 0 or y < 0 or x >= levelWidth or y >= levelHeight:
    return false
  var i = 0
  while i < len(boxes):
    if boxes[i][0] == x and boxes[i][1] == y:
      return true
    i = i + 1
  return false

# Get box index at position
proc getBoxIndex(x: int, y: int): int =
  var i = 0
  while i < len(boxes):
    if boxes[i][0] == x and boxes[i][1] == y:
      return i
    i = i + 1
  return -1

# Check if position is a goal
proc isGoal(x: int, y: int): bool =
  var i = 0
  while i < len(goals):
    if goals[i][0] == x and goals[i][1] == y:
      return true
    i = i + 1
  return false

# Check if all boxes are on goals
proc checkWin(): bool =
  var i = 0
  while i < len(boxes):
    if not isGoal(boxes[i][0], boxes[i][1]):
      return false
    i = i + 1
  return true

# Try to move player
proc tryMove(dx: int, dy: int): bool =
  if gameWon:
    return false
  
  var newX = playerX + dx
  var newY = playerY + dy
  
  # Check wall collision
  if hasWall(newX, newY):
    return false
  
  # Check box collision
  if hasBox(newX, newY):
    var boxNewX = newX + dx
    var boxNewY = newY + dy
    
    # Can't push box into wall or another box
    if hasWall(boxNewX, boxNewY) or hasBox(boxNewX, boxNewY):
      return false
    
    # Move the box
    var boxIdx = getBoxIndex(newX, newY)
    boxes[boxIdx] = [boxNewX, boxNewY]
  
  # Move player
  playerX = newX
  playerY = newY
  moveCount = moveCount + 1
  
  # Check win
  gameWon = checkWin()
  
  return true

# Calculate simple pathfinding (BFS) to target - returns true and sets nextMoveDX/nextMoveDY
proc findPath(targetX: int, targetY: int): bool =
  if gameWon:
    return false
  
  # BFS to find shortest path
  var queueX = []
  var queueY = []
  var queueFirstMoveX = []
  var queueFirstMoveY = []
  var visited = []
  
  queueX = queueX + [playerX]
  queueY = queueY + [playerY]
  queueFirstMoveX = queueFirstMoveX + [0]
  queueFirstMoveY = queueFirstMoveY + [0]
  
  while len(queueX) > 0:
    # Dequeue first element
    var cx = queueX[0]
    var cy = queueY[0]
    var firstMoveX = queueFirstMoveX[0]
    var firstMoveY = queueFirstMoveY[0]
    
    var newQueueX = []
    var newQueueY = []
    var newFirstMoveX = []
    var newFirstMoveY = []
    var i = 1
    while i < len(queueX):
      newQueueX = newQueueX + [queueX[i]]
      newQueueY = newQueueY + [queueY[i]]
      newFirstMoveX = newFirstMoveX + [queueFirstMoveX[i]]
      newFirstMoveY = newFirstMoveY + [queueFirstMoveY[i]]
      i = i + 1
    queueX = newQueueX
    queueY = newQueueY
    queueFirstMoveX = newFirstMoveX
    queueFirstMoveY = newFirstMoveY
    
    # Check if reached target
    if cx == targetX and cy == targetY:
      nextMoveDX = firstMoveX
      nextMoveDY = firstMoveY
      return true
    
    # Check if visited
    var visitKey = $cx & "," & $cy
    var alreadyVisited = false
    var j = 0
    while j < len(visited):
      if visited[j] == visitKey:
        alreadyVisited = true
      j = j + 1
    
    if not alreadyVisited:
      visited = visited + [visitKey]
      
      # Try all 4 directions: up, down, left, right
      # Up
      var nx = cx + 0
      var ny = cy + -1
      if not hasWall(nx, ny) and not hasBox(nx, ny):
        var moveX = 0
        var moveY = -1
        if firstMoveX == 0 and firstMoveY == 0:
          moveX = 0
          moveY = -1
        else:
          moveX = firstMoveX
          moveY = firstMoveY
        queueX = queueX + [nx]
        queueY = queueY + [ny]
        queueFirstMoveX = queueFirstMoveX + [moveX]
        queueFirstMoveY = queueFirstMoveY + [moveY]
      
      # Down
      nx = cx + 0
      ny = cy + 1
      if not hasWall(nx, ny) and not hasBox(nx, ny):
        var moveX = 0
        var moveY = 1
        if firstMoveX == 0 and firstMoveY == 0:
          moveX = 0
          moveY = 1
        else:
          moveX = firstMoveX
          moveY = firstMoveY
        queueX = queueX + [nx]
        queueY = queueY + [ny]
        queueFirstMoveX = queueFirstMoveX + [moveX]
        queueFirstMoveY = queueFirstMoveY + [moveY]
      
      # Left
      nx = cx + -1
      ny = cy + 0
      if not hasWall(nx, ny) and not hasBox(nx, ny):
        var moveX = -1
        var moveY = 0
        if firstMoveX == 0 and firstMoveY == 0:
          moveX = -1
          moveY = 0
        else:
          moveX = firstMoveX
          moveY = firstMoveY
        queueX = queueX + [nx]
        queueY = queueY + [ny]
        queueFirstMoveX = queueFirstMoveX + [moveX]
        queueFirstMoveY = queueFirstMoveY + [moveY]
      
      # Right
      nx = cx + 1
      ny = cy + 0
      if not hasWall(nx, ny) and not hasBox(nx, ny):
        var moveX = 1
        var moveY = 0
        if firstMoveX == 0 and firstMoveY == 0:
          moveX = 1
          moveY = 0
        else:
          moveX = firstMoveX
          moveY = firstMoveY
        queueX = queueX + [nx]
        queueY = queueY + [ny]
        queueFirstMoveX = queueFirstMoveX + [moveX]
        queueFirstMoveY = queueFirstMoveY + [moveY]
  
  nextMoveDX = 0
  nextMoveDY = 0
  return false

# Handle mouse/touch click to move player
proc handleClick(clickX: int, clickY: int): bool =
  if gameWon:
    return false
  
  # Store for debug display
  lastBufferX = clickX
  lastBufferY = clickY
  
  # Coordinates are already buffer-relative!
  # Each emoji takes 2 character cells width
  var gridX = clickX / 2
  var gridY = clickY
  
  # Store for debug display
  lastGridX = gridX
  lastGridY = gridY
  
  # Validate grid position
  if gridX < 0 or gridX >= levelWidth or gridY < 0 or gridY >= levelHeight:
    return false
  
  # If clicking on current player position, do nothing
  if gridX == playerX and gridY == playerY:
    return false
  
  # If clicking on a wall, do nothing
  if hasWall(gridX, gridY):
    return false
  
  # If clicking on a box, try to push it
  if hasBox(gridX, gridY):
    # Check if player is adjacent to the box
    var dx = gridX - playerX
    var dy = gridY - playerY
    var isAdjacent = false
    var pushDirX = 0
    var pushDirY = 0
    
    if dx == 0 and dy == 1:
      isAdjacent = true
      pushDirX = 0
      pushDirY = 1
    elif dx == 0 and dy == -1:
      isAdjacent = true
      pushDirX = 0
      pushDirY = -1
    elif dy == 0 and dx == 1:
      isAdjacent = true
      pushDirX = 1
      pushDirY = 0
    elif dy == 0 and dx == -1:
      isAdjacent = true
      pushDirX = -1
      pushDirY = 0
    
    if isAdjacent:
      # Try to push the box
      return tryMove(pushDirX, pushDirY)
    else:
      # Player needs to move adjacent to box first
      # Try each adjacent position around the box in order
      
      # Check position to the left of box
      var adjX = gridX - 1
      var adjY = gridY
      if not hasWall(adjX, adjY) and not hasBox(adjX, adjY):
        if findPath(adjX, adjY):
          return tryMove(nextMoveDX, nextMoveDY)
      
      # Check position to the right of box
      adjX = gridX + 1
      adjY = gridY
      if not hasWall(adjX, adjY) and not hasBox(adjX, adjY):
        if findPath(adjX, adjY):
          return tryMove(nextMoveDX, nextMoveDY)
      
      # Check position above box
      adjX = gridX
      adjY = gridY - 1
      if not hasWall(adjX, adjY) and not hasBox(adjX, adjY):
        if findPath(adjX, adjY):
          return tryMove(nextMoveDX, nextMoveDY)
      
      # Check position below box
      adjX = gridX
      adjY = gridY + 1
      if not hasWall(adjX, adjY) and not hasBox(adjX, adjY):
        if findPath(adjX, adjY):
          return tryMove(nextMoveDX, nextMoveDY)
      
      return false
  
  # Find path to clicked position and move player directly there
  if findPath(gridX, gridY):
    # Move player directly to the clicked position
    playerX = gridX
    playerY = gridY
    moveCount = moveCount + 1
    gameWon = checkWin()
    return true
  
  return false
```

```nim on:input
# Handle input
if event.type == "mouse":
  # Extract coordinates to local variables
  var mouseX = event.x
  var mouseY = event.y
  var mouseAction = event.action
  
  # Store for debug display
  lastMouseX = mouseX
  lastMouseY = mouseY
  
  if mouseAction == "press":
    # Check if we're on a level section (has lvl code blocks)
    var levelBlocks = getCurrentSectionCodeBlocks("lvl")
    
    if len(levelBlocks) > 0:
      # Method 1: Use buffer-relative coordinates (automatically calculated by tstorie)
      # bufferX/bufferY are relative to the content buffer, perfect for games!
      if event.bufferX >= 0 and event.bufferY >= 0:
        var handled = handleClick(event.bufferX, event.bufferY)
        if handled:
          return true
      
      # Method 2 (alternative): Use the eventToGrid helper for even simpler code:
      # var grid = eventToGrid(event, 2, 1)  # cellWidth=2 (emoji width), cellHeight=1
      # if grid.valid:
      #   handleClick(grid.x, grid.y)
      
      # Fallback: try handling as canvas navigation
      var handled = canvasHandleMouse(mouseX, mouseY, 0, true)
      return handled
    
    # If not handled by game, let canvas handle link navigation
    var handled = canvasHandleMouse(mouseX, mouseY, 0, true)
    return handled
  return true

elif event.type == "text":
  var key = event.text
  
  # Movement
  if key == "w" or key == "W":
    if tryMove(0, -1):
      return true
  elif key == "s" or key == "S":
    if tryMove(0, 1):
      return true
  elif key == "a" or key == "A":
    if tryMove(-1, 0):
      return true
  elif key == "d" or key == "D":
    if tryMove(1, 0):
      return true
  
  # Restart
  elif key == "r" or key == "R":
    parseLevel(currentLevelData)
    return true
  
  return false

elif event.type == "key":
  if event.action == "press":
    var handled = canvasHandleKey(event.keyCode, 0)
    return handled
  return false

return false
```

```nim on:render
# Check if current section has level data
var levelBlocks = getCurrentSectionCodeBlocks("lvl")
if len(levelBlocks) > 0:
  # Load level if changed
  var idx = getCurrentSectionIndex()
  var newLevelData = getCodeBlockText(idx, "lvl")
  
  # Check against stored level or treat empty as new
  if levelWidth == 0:
    # First time loading - parse immediately
    currentLevelData = newLevelData
    parseLevel(currentLevelData)
  elif newLevelData != currentLevelData:
    # Level changed
    currentLevelData = newLevelData
    parseLevel(currentLevelData)
  
  # Render game
  contentClear()
  
  # Render each row
  var y = 0
  while y < levelHeight:
    var row = ""
    var x = 0
    while x < levelWidth:
      var cell = emptyChar
      
      # Check what's at this position
      if hasWall(x, y):
        cell = wallChar
      elif playerX == x and playerY == y:
        cell = playerChar
      elif hasBox(x, y):
        if isGoal(x, y):
          cell = boxOnGoalChar
        else:
          cell = boxChar
      elif isGoal(x, y):
        cell = goalChar
      
      row = row & cell
      x = x + 1
    
    contentWrite(row)
    y = y + 1
  
  # Status line
  contentWrite("‚†Ä")
  var status = "Moves: " & $moveCount
  if gameWon:
    status = status & "„ÄÄ‚òÖ WIN ‚òÖ"
  contentWrite(status)
  contentWrite("WASD: Move | R: Restart")

# Render canvas
canvasRender()
```

```nim on:update
canvasUpdate()
```
---
title: "Canvas Metadata Test"
theme: "catppuccin"
minWidth: 60
---

```nim on:init
# Initialize canvas system with all sections
# Start at section 1 (Introduction - section 0 is code blocks)
initCanvas(1)
```

```nim on:input
# Handle keyboard and mouse input for canvas navigation
if event.type == "key":
  if event.action == "press":
    # Pass key events to canvas system
    var handled = canvasHandleKey(event.keyCode, 0)
    if handled:
      return true
  return false

elif event.type == "mouse":
  if event.action == "press":
    # Pass mouse events to canvas system
    var handled = canvasHandleMouse(event.x, event.y, event.button, true)
    if handled:
      return true
  return false

return false
```

```nim on:update
canvasUpdate()
```

```nim on:render
# Clear screen and render canvas
clear()
canvasRender()
```

# Introduction

This demo tests the new canvas metadata features:
- Custom section width and height
- Non-navigable sections for visual decorations

Navigate with arrow keys or click links below.

[Go to Regular Section](#regular-section)
[Go to Large Art Section](#large-art)
[Try to go to Decoration](#decoration) (should not work - it's not navigable)

# Regular Section

This is a normal section with default dimensions (60x20).

It can be navigated to via links and arrow keys.

[Go to Wide Section](#wide-section)
[Back to Introduction](#introduction)

# Wide Section {"width": "100"}

This section has a custom width of 100 characters!

It's much wider than the default 60 characters, so it can display more content on a single line without wrapping.

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore.

[Go to Tall Section](#tall-section)
[Back to Regular](#regular-section)

# Tall Section {"height": "40"}

This section has a custom height of 40 lines!

Normally sections are only 20 lines tall.

Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
Line 11
Line 12
Line 13
Line 14
Line 15
Line 16
Line 17
Line 18
Line 19
Line 20
Line 21
Line 22
Line 23
Line 24
Line 25
Line 26
Line 27
Line 28
Line 29
Line 30

Much more content fits!

[Go to Large Art](#large-art)
[Back to Wide](#wide-section)

# Large Art Section {"width": "120", "height": "50"}

This section is both wide (120) AND tall (50).

Perfect for large ASCII art or content displays!

```ascii:large-frame
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                                                                                                ‚ïë
‚ïë                                         LARGE CONTENT AREA                                                     ‚ïë
‚ïë                                                                                                                ‚ïë
‚ïë                              This section can hold much more content                                           ‚ïë
‚ïë                              than a standard-sized section!                                                    ‚ïë
‚ïë                                                                                                                ‚ïë
‚ïë                              Width: 120 characters                                                             ‚ïë
‚ïë                              Height: 50 lines                                                                  ‚ïë
‚ïë                                                                                                                ‚ïë
‚ïë                                                                                                                ‚ïë
‚ïë                                                                                                                ‚ïë
‚ïë                                                                                                                ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
```

[Back to Introduction](#introduction)

# Decoration (Non-Navigable) {"x": "150", "y": "5", "width": "50", "height": "30", "navigable": "false"}

This section is positioned off to the side and is NOT navigable.

You cannot reach it via arrow keys or link clicks!

It's perfect for visual decorations that shouldn't interrupt the flow of navigation.

```ascii:decoration-art
    ‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ
    ‚îÇ   DECORATION        ‚îÇ
    ‚îÇ                     ‚îÇ
    ‚îÇ   This is a         ‚îÇ
    ‚îÇ   non-interactive   ‚îÇ
    ‚îÇ   visual element    ‚îÇ
    ‚îÇ                     ‚îÇ
    ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ
```

Even if you try to link to it, navigation will fail because navigable=false.

# Another Regular Section

Back to normal content flow.

The decoration section to the right (if you pan there) won't interrupt keyboard navigation.

[Go to Custom Position](#custom-pos)
[Back to Introduction](#introduction)

# Custom Position Section {"x": "200", "y": "50", "width": "80", "height": "25"}

This section is positioned at a specific coordinate (200, 50) with custom dimensions.

You CAN navigate here because it doesn't have `navigable: false`.

Combine with non-navigable for full control:
- Use regular sections for story/gameplay flow
- Use non-navigable sections for visual decorations, borders, backgrounds

[Back to Introduction](#introduction)
---
title: "Canvas Editor Demo"
author: "Maddest Labs"
minWidth: 80
minHeight: 24
theme: "catppuccin"
---

```nim on:init
# Canvas Editor - Visual Node Graph Editor
# 
# Controls:
# - Left mouse on empty: Pan the canvas
# - Shift + Left mouse on node: Select and drag nodes
# - Middle mouse: Alternative panning (desktop)
# - Left click on node: Select node
# - Long press (hold 500ms): Context menu (future)
# - Arrow keys: Navigate viewport
# - Shift+click: Multi-select nodes
# - Delete: Remove selected nodes
# - A: Select all nodes
# - Escape: Deselect all
# - Home: Reset camera to origin

# Create node editor
var editor = newNodeEditor(termWidth, termHeight)

# Create some sample nodes for demonstration
var node1 = newEditorNode()
setNodePosition(node1, 10, 5)
setNodeSize(node1, 25, 8)
editor.addNode(node1)

var node2 = newEditorNode()
setNodePosition(node2, 50, 5)
setNodeSize(node2, 25, 8)
editor.addNode(node2)

var node3 = newEditorNode()
setNodePosition(node3, 30, 20)
setNodeSize(node3, 25, 8)
editor.addNode(node3)

# Connect nodes to show dataflow
editor.connectNodes(node1, node3)
editor.connectNodes(node2, node3)

# Variables for context menu and long-press
var showContextMenu = false
var contextMenuX = 0
var contextMenuY = 0
var longPressStartTime = 0.0
var longPressActive = false
var longPressThreshold = 0.5  # 500ms
var lastMouseX = 0
var lastMouseY = 0
```

```nim on:input
# Handle keyboard and mouse input for node editor
# The editor's built-in handlers manage most interactions

if event.type == "key":
  # Use named key constants (much clearer than magic numbers!)
  var keyStr = ""
  
  if event.keyCode == KEY_UP:
    keyStr = "Up"
  elif event.keyCode == KEY_DOWN:
    keyStr = "Down"
  elif event.keyCode == KEY_LEFT:
    keyStr = "Left"
  elif event.keyCode == KEY_RIGHT:
    keyStr = "Right"
  elif event.keyCode == KEY_ESCAPE:
    keyStr = "Escape"
  elif event.keyCode == KEY_DELETE or event.keyCode == KEY_BACKSPACE:
    keyStr = "Delete"
  
  # Pass to editor's key handler
  if keyStr != "":
    var handled = editorHandleKeyPress(editor, keyStr)
    if handled:
      return true

elif event.type == "text":
  # Handle text input for letter keys
  if event.text == "a" or event.text == "A":
    var handled = editorHandleKeyPress(editor, event.text)
    if handled:
      return true

elif event.type == "mouse":
  # Hide context menu on any mouse press
  if event.action == "press":
    showContextMenu = false
  
  # Convert button string to int (1=left, 2=middle, 3=right)
  var buttonInt = 0
  if event.button == "left":
    buttonInt = 1
  elif event.button == "middle":
    buttonInt = 2
  elif event.button == "right":
    buttonInt = 3
  
  # Check for shift modifier
  var shiftPressed = false
  var i = 0
  while i < len(event.mods):
    if event.mods[i] == "shift":
      shiftPressed = true
    i = i + 1
  
  if event.action == "press":
    # Start long-press tracking
    longPressStartTime = getTime()
    longPressActive = true
    showContextMenu = false
    lastMouseX = event.x
    lastMouseY = event.y
    
    var handled = editorHandleMouseDown(editor, event.x, event.y, buttonInt, shiftPressed, getTotalTime())
    if handled:
      return true
  
  elif event.action == "release":
    # Cancel long-press tracking
    longPressActive = false
    
    var handled = editorHandleMouseUp(editor, event.x, event.y, buttonInt, getTotalTime())
    if handled:
      return true

elif event.type == "mouse_move":
  var handled = editorHandleMouseMove(editor, event.x, event.y)
  if handled:
    return true

return false
```

```nim on:render
clear()

# Render the nodes first
var nodes = editorRenderSimple(editor)
for i in 0..<len(nodes):
  var node = nodes[i]
  var x = node[0]
  var y = node[1]
  var w = node[2]
  var h = node[3]
  var selected = node[4]
  
  # Determine color based on selection
  var style = defaultStyle()
  if selected:
    style.fg = rgb(255, 255, 255)
    style.bg = rgb(50, 50, 150)
    style.bold = true
  else:
    style.fg = rgb(200, 200, 200)
    style.bg = rgb(40, 40, 40)
  
  # Draw box borders
  var topLine = "‚îå"
  var midFill = ""
  var botLine = "‚îî"
  var dx = 1
  while dx < w - 1:
    topLine = topLine & "‚îÄ"
    midFill = midFill & " "
    botLine = botLine & "‚îÄ"
    dx = dx + 1
  topLine = topLine & "‚îê"
  botLine = botLine & "‚îò"
  
  draw(0, x, y, topLine, style)
  
  var dy = 1
  while dy < h - 1:
    draw(0, x, y + dy, "‚îÇ" & midFill & "‚îÇ", style)
    dy = dy + 1
  
  draw(0, x, y + h - 1, botLine, style)

# Draw context menu if active
if showContextMenu:
  var menuStyle = defaultStyle()
  menuStyle.fg = rgb(255, 255, 255)
  menuStyle.bg = rgb(60, 60, 60)
  
  var menuX = contextMenuX
  var menuY = contextMenuY
  
  draw(0, menuX, menuY, "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê", menuStyle)
  draw(0, menuX, menuY + 1, "‚îÇ Add Node       ‚îÇ", menuStyle)
  draw(0, menuX, menuY + 2, "‚îÇ Delete Node    ‚îÇ", menuStyle)
  draw(0, menuX, menuY + 3, "‚îÇ Properties...  ‚îÇ", menuStyle)
  draw(0, menuX, menuY + 4, "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò", menuStyle)

# Draw help text
var helpStyle = defaultStyle()
helpStyle.fg = rgb(150, 150, 150)
helpStyle.dim = true

draw(0, 2, termHeight - 4, "Left mouse: Pan | Shift+Left on node: Drag | Long press: Context menu", helpStyle)
draw(0, 2, termHeight - 3, "Arrow keys: Navigate | A: Select all | Escape: Deselect | Delete: Remove", helpStyle)

# Show camera position
var infoStyle = defaultStyle()
infoStyle.fg = rgb(200, 200, 100)
var camX = getEditorCameraX(editor)
var camY = getEditorCameraY(editor)
var camInfo = "Camera: (" & str(int(camX)) & ", " & str(int(camY)) & ")"
draw(0, termWidth - len(camInfo) - 2, 1, camInfo, infoStyle)

# Show node count and selection
var nodeCount = getEditorNodeCount(editor)
var selectedCount = getEditorSelectedCount(editor)
var nodeInfo = "Nodes: " & str(nodeCount) & " | Selected: " & str(selectedCount)
draw(0, termWidth - len(nodeInfo) - 2, 2, nodeInfo, infoStyle)

# Show time for debugging
var fps = 60
if deltaTime > 0.0:
  fps = int(1.0 / deltaTime)
var timeInfo = "Time: " & str(int(getTime() * 1000)) & "ms | FPS: " & str(fps)
draw(0, 2, 1, timeInfo, infoStyle)
```

```nim on:update
# Update camera position using real deltaTime (frame-independent!)
editorUpdateCamera(editor, deltaTime)

# Check for long-press (if mouse is still held down)
if longPressActive:
  var currentTime = getTime()
  if currentTime - longPressStartTime >= longPressThreshold:
    # Long press threshold reached!
    showContextMenu = true
    contextMenuX = lastMouseX
    contextMenuY = lastMouseY
    longPressActive = false  # Prevent retriggering
```

# üé® Canvas Editor - Visual Node Graph System

Welcome to the **Canvas Editor** - a generic visual node editor framework for TStorie!

This editor provides an intuitive way to create, connect, and manipulate nodes in a spatial graph.

## ‚ú® Features

### Edit-Focused Design

The canvas editor is designed from the ground up for **efficient editing**:

- **Middle mouse button** for instant canvas panning
- **Arrow keys** override canvas.nim defaults for viewport navigation
- **Smooth camera** interpolation for fluid movement
- **Multi-select** with Shift+click for batch operations

### Node Operations

- ‚úÖ **Create nodes** programmatically (interactive creation coming soon)
- ‚úÖ **Select nodes** with left mouse click
- ‚úÖ **Drag nodes** to reposition them
- ‚úÖ **Multi-select** with Shift+click
- ‚úÖ **Delete nodes** with Delete or Backspace key
- ‚úÖ **Connect nodes** to show dataflow relationships

### Navigation

- **Arrow keys**: Pan viewport (10 cells per press by default)
- **Middle mouse drag**: Smooth panning
- **Home key**: Reset camera to origin (0, 0)
- **Smooth interpolation**: Camera moves fluidly to targets

## üéØ Use Cases

### Markdown Section Editing

The immediate use case is **spatial markdown editing**:

```nim
# Load markdown sections as visual nodes
var sections = getSections()
editor.loadMarkdownSections(sections)

# Users can then:
# - Rearrange sections spatially
# - See connections between linked sections
# - Edit section content in-place
```

### Dataflow Graph Editing (Future)

The same editor will support **visual graph programming**:

```nim
# Load graph.nim nodes as visual nodes
var graph = newGraph()
editor.loadGraph(graph)

# Users can then:
# - Create processing nodes visually
# - Connect nodes to define dataflow
# - See data flowing through the graph
# - Export back to graph.nim structures
```

### More Possibilities

- **Audio graphs** - Visual Web Audio-style node editing
- **Shader graphs** - Material/effect composition
- **Procedural generation** - Visual workflow building
- **State machines** - Visual behavior design

## üèóÔ∏è Architecture

### Generic Core

The editor uses **polymorphic nodes**:

```nim
type
  EditorNode* = ref object of RootObj
    id*, x*, y*: int
    width*, height*: int
    selected*, hovered*: bool
```

Specialized nodes inherit from this base:

```nim
type
  MarkdownSectionNode* = ref object of EditorNode
    section*: Section
    contentLines*: seq[string]
  
  GraphProcessNode* = ref object of EditorNode
    graphNode*: Node
    nodeKind*: NodeKind
```

### Viewport System

Reuses proven patterns from `canvas.nim`:

- Camera with smooth interpolation
- World ‚Üî Screen coordinate conversion
- Viewport clipping for performance

### Connection Rendering

ASCII art connections with right-angle routing:

```
Node 1 ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ
          ‚îî‚îÄ‚Üí Node 3
          ‚îå‚îÄ‚Üó
Node 2 ‚îÄ‚îÄ‚îÄ‚îò
```

## üöÄ Implementation Status

‚úÖ **Phase 1: Core Editor** (Complete)
- Viewport navigation and camera
- Node selection and dragging
- Connection rendering
- Multi-select support

üöß **Phase 2: Node Editing** (In Progress)
- Create/delete nodes interactively
- Property panels for editing
- Undo/redo system

üìã **Phase 3: Markdown Specialization** (Planned)
- Edit section content
- Preview rendering
- Save back to markdown

üìã **Phase 4: Graph Specialization** (Planned)
- Visual dataflow editing
- Connection type checking
- Export to graph.nim

## üéì Technical Details

### Coordinate Systems

- **World space**: Infinite 2D grid (terminal cells)
- **Screen space**: Visible viewport (0 to termWidth/Height)
- **Conversion**: `screenToWorld()` and `worldToScreen()`

### Mouse Button Handling

```nim
type MouseButton = enum
  mbNone, mbLeft, mbMiddle, mbRight

# Left: Select and drag nodes
# Middle: Pan canvas (edit-focused!)
# Right: Reserved for context menus
```

### Drag States

```nim
type DragState = enum
  dsNone
  dsDraggingNode
  dsDraggingConnection
  dsPanningMiddleMouse
```

### Keyboard Overrides

The editor **overrides canvas.nim key handling** for arrow keys:

```nim
proc handleKeyPress*(editor: NodeEditor, key: string): bool =
  case key
  of "Up", "ArrowUp":
    editor.panCamera(0, -editor.arrowKeyPanSpeed)
    return true  # Prevents canvas.nim from handling
  # ... etc
```

## üí° Design Philosophy

### 90% Code Reuse

The same editor core works for:
- Markdown sections
- Dataflow graphs  
- Audio nodes
- Shader graphs
- Anything spatial!

### Consistent UX

Same interactions across all node types:
- Pan with middle mouse
- Select with left mouse
- Navigate with arrows
- Connect by dragging

### Progressive Enhancement

Start simple, add features incrementally:
1. Basic nodes and connections ‚úÖ
2. Interactive creation üöß
3. Specialized rendering üìã
4. Domain-specific features üìã

## üîß Try It Yourself!

This demo shows the basic editor in action. Try:

1. **Left-click nodes** to select them
2. **Drag selected nodes** around
3. **Middle-mouse drag** to pan the canvas
4. **Press arrow keys** to navigate
5. **Press Home** to return to origin

The editor is fully functional and ready for integration!

---

*For implementation details, see `/lib/canvased.nim` and `CANVAS_EDITOR.md`*
---
title: "Depths Beckon"
author: "Maddest Labs"
theme: "coffee"
shaders: "ruledlines+sand+lightnight+gradualblur"
font: "Courier+Prime"
---

```nim on:init
# Canvas-based Interactive Fiction using Nimini
# The Depths of Khel-Daran - A dungeon adventure

# Track player state with simple variables
var hasTorch = false
var hasKey = false
var hasAmulet = false
var hasEssence = false
var hasWeapon = false
var visitedLibrary = false
var torchQuality = "dim"

# Bug effect tracking
var bugTimer = 0.0
var bugSpawnInterval = 3.0  # Spawn bugs every 3 seconds

# Initialize canvas system with all sections
# Start at section 1 (entrance - section 0 is the code blocks)
initCanvas(1)

# Initialize bug particle system
var bgStyle = getStyle("default")
var bgR = int(bgStyle.bg.r)
var bgG = int(bgStyle.bg.g)
var bgB = int(bgStyle.bg.b)
var fgR = int(bgStyle.fg.r)
var fgG = int(bgStyle.fg.g)
var fgB = int(bgStyle.fg.b)

particleInit("bugs", 50)
particleSetBackgroundColor("bugs", bgR, bgG, bgB)

# Configure base bug settings
particleSetEmitRate("bugs", 0.0)  # Manual emission only
particleSetChars("bugs", "o0@‚óè")  # Bug head characters
particleSetColorRange("bugs", fgR, fgG, fgB, fgR, fgG, fgB)  # Use theme foreground color

# Enable trails for segmented body
particleSetTrailEnabled("bugs", true)
particleSetTrailLength("bugs", 4)  # 4-segment body
particleSetTrailSpacing("bugs", 0.8)  # Tight spacing
particleSetTrailFade("bugs", false)  # Solid body segments
particleSetTrailChars("bugs", "/\\.-|*")  # Random body segment chars

# Short lifetime - bugs disappear after crossing
particleSetLifeRange("bugs", 3.0, 5.0)

# Light turbulence for slight wobble
particleSetTurbulence("bugs", 3.0)
particleSetDamping("bugs", 0.98)

# Initialize bug splat particle system
particleInit("splat", 50)  # More particles for bigger splats
particleSetBackgroundColor("splat", bgR, bgG, bgB)
particleSetEmitRate("splat", 0.0)  # Manual only
particleSetChars("splat", "X*+#.:,`")  # Splat characters with debris
particleSetColorRange("splat", fgR, fgG, fgB, fgR, fgG, fgB)  # Same color as bugs
particleSetLifeRange("splat", 1.5, 2.5)  # Fade after 1.5-2.5 seconds
particleSetFadeOut("splat", true)  # Fade to nothing
particleSetVelocityRange("splat", -15.0, -15.0, 15.0, 15.0)  # Wider spread for debris
particleSetGravity("splat", 0.0)
particleSetDamping("splat", 0.75)  # Slow down quickly
```

```nim on:input
# Handle keyboard and mouse input for canvas navigation

if event.type == "key":
  if event.action == "press":
    # Pass key events to canvas system
    var handled = canvasHandleKey(event.keyCode, 0)
    if handled:
      return true
  return false

elif event.type == "mouse":
  if event.action == "press":
    # Check if we clicked on a bug!
    var hitBug = particleCheckHit("bugs", event.x, event.y, 2.0)
    if hitBug:
      # Spawn splat particles at click location
      particleSetEmitterPos("splat", float(event.x), float(event.y))
      particleEmit("splat", rand(10) + 12)  # 12-21 particles for bigger splat
  
  # Pass mouse release events to canvas system for link navigation
  if event.action == "release":
    var handled = canvasHandleMouse(event.x, event.y, event.button, false)
    if handled:
      return true
  
  return false

return false
```

```nim on:render
clear()
canvasRender()

# Render bugs behind text (layer 0 = behind canvas content)
particleRender("bugs", 0)

# Render splats on top of bugs but still behind text
particleRender("splat", 0)

# Top border with cracks
var x = 0
while x < termWidth:
  var char = "‚îÄ"
  # Add random cracks and branches
  if x % 7 == 3:
    char = "‚ïå"
  elif x % 11 == 5:
    char = "‚î¨"
  elif x % 13 == 2:
    char = "‚ï•"
  elif x % 17 == 8:
    char = "‚î¥"
  draw(0, x, 0, char)
  x = x + 1

# Bottom border with cracks
x = 0
while x < termWidth:
  var char = "‚îÄ"
  # Different crack pattern on bottom
  if x % 8 == 2:
    char = "‚ïå"
  elif x % 12 == 7:
    char = "‚î¥"
  elif x % 15 == 4:
    char = "‚ï®"
  elif x % 19 == 11:
    char = "‚î¨"
  draw(0, x, termHeight - 1, char)
  x = x + 1

# Left border with vertical cracks
var y = 1
while y < termHeight - 1:
  var char = "‚îÇ"
  # Add cracks and branches
  if y % 6 == 2:
    char = "‚ïé"
  elif y % 9 == 4:
    char = "‚îú"
  elif y % 13 == 7:
    char = "‚ïû"
  elif y % 16 == 10:
    char = "‚î§"
  draw(0, 0, y, char)
  y = y + 1

# Right border with vertical cracks
y = 1
while y < termHeight - 1:
  var char = "‚îÇ"
  # Different crack pattern on right
  if y % 7 == 3:
    char = "‚ïé"
  elif y % 10 == 5:
    char = "‚î§"
  elif y % 14 == 8:
    char = "‚ï°"
  elif y % 17 == 11:
    char = "‚îú"
  draw(0, termWidth - 1, y, char)
  y = y + 1

# Corner pieces - weathered and broken
draw(0, 0, 0, "‚ïî")
draw(0, termWidth - 1, 0, "‚ïó")
draw(0, 0, termHeight - 1, "‚ïö")
draw(0, termWidth - 1, termHeight - 1, "‚ïù")

# Add some additional crack details
# Top left area cracks
if termWidth > 10:
  draw(0, 5, 0, "‚îØ")
  draw(0, 5, 1, "‚ïΩ")
  
# Top right area cracks
if termWidth > 10:
  draw(0, termWidth - 6, 0, "‚îØ")
  draw(0, termWidth - 6, 1, "‚ïΩ")

# Bottom left area cracks
if termHeight > 5:
  draw(0, 4, termHeight - 1, "‚î∑")
  draw(0, 4, termHeight - 2, "‚ïø")

# Bottom right area cracks
if termWidth > 10 and termHeight > 5:
  draw(0, termWidth - 7, termHeight - 1, "‚î∑")
  draw(0, termWidth - 7, termHeight - 2, "‚ïø")
```

```nim on:update
canvasUpdate()

# Update bug particles
particleUpdate("bugs", deltaTime)

# Update splat particles
particleUpdate("splat", deltaTime)

# Bug spawning timer
bugTimer += deltaTime
if bugTimer >= bugSpawnInterval:
  bugTimer = 0.0
  
  # Randomly select which edge to spawn from (0=top, 1=right, 2=bottom, 3=left)
  var edge = rand(4)
  
  # Spawn position and velocity depend on edge
  # Random arc direction for variety
  var arcDir = float(rand(2) * 2 - 1)  # -1 or 1 (arc up or down)
  var gravityStrength = 12.0 + float(rand(10))  # 12-21 for varied arc curves
  
  if edge == 0:
    # Spawn from TOP edge, move downward with random arc
    var spawnX = float(rand(termWidth - 4) + 2)
    particleSetEmitterPos("bugs", spawnX, 1.0)
    # Move down and either left or right
    var horizontalDir = float(rand(3) - 1) * 40.0  # -40, 0, or 40
    particleSetVelocityRange("bugs", horizontalDir - 15.0, 80.0, horizontalDir + 15.0, 80.0)
    particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
    
  elif edge == 1:
    # Spawn from RIGHT edge, move leftward with random arc
    var spawnY = float(rand(termHeight - 4) + 2)
    particleSetEmitterPos("bugs", float(termWidth - 2), spawnY)
    particleSetVelocityRange("bugs", -80.0, -15.0, -80.0, 15.0)
    particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
    
  elif edge == 2:
    # Spawn from BOTTOM edge, move upward with random arc
    var spawnX = float(rand(termWidth - 4) + 2)
    particleSetEmitterPos("bugs", spawnX, float(termHeight - 2))
    var horizontalDir = float(rand(3) - 1) * 40.0
    particleSetVelocityRange("bugs", horizontalDir - 15.0, -80.0, horizontalDir + 15.0, -80.0)
    particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
    
  else:
    # Spawn from LEFT edge, move rightward with random arc
    var spawnY = float(rand(termHeight - 4) + 2)
    particleSetEmitterPos("bugs", 1.0, spawnY)
    particleSetVelocityRange("bugs", 80.0, -15.0, 80.0, 15.0)
    particleSetGravity("bugs", gravityStrength * arcDir)  # Random arc direction
  
  # Emit 1 bug at a time for individual randomization
  particleEmit("bugs", 1)
  
  # Vary spawn interval for natural randomness
  bugSpawnInterval = 2.0 + (float(rand(100)) / 80.0) * 2.5  # 2.0-4.5 seconds
```

# entrance
‚†Ä
You stand before the ancient ruins of **Khel-Daran**, a fortress swallowed by time and shadow. The stone archway before you exhales cold, stale air. Moss clings to the weathered pillars, and somewhere deep within, you hear the faint echo of water dripping.
‚†Ä
Your torch flickers in the darkness. The adventure begins here.
‚†Ä
**What do you do?**
‚†Ä
- [Enter the ruins](#hall-of-statues)  
- [Examine the entrance more carefully](#entrance-examine)  
- [Light a better torch](#prepare-torch)

# entrance_examine {"hidden": true, "removeAfterVisit": "true"}
‚†Ä
You take a moment to inspect the entrance more carefully. Ancient runes are carved into the archway, worn smooth by centuries of wind and rain. You can barely make out what appears to be a warning:
‚†Ä
*"Beware the guardian of the depths. Only the wise may pass."*
‚†Ä
Beside the entrance, you notice an old iron sconce. It's empty, but appears functional.
‚†Ä
- [Enter the ruins](#hall-of-statues)  
- [Take the sconce](#take-sconce)  
- [Go back](#entrance)

# prepare_torch {"hidden": true, "removeAfterVisit": "true"}
‚†Ä
You take time to properly prepare your torch, wrapping it with oil-soaked cloth from your pack. The flame burns brighter now, casting long shadows across the ancient stone.
‚†Ä
*You feel more confident with better light.*
‚†Ä
- [Enter the ruins](#hall-of-statues)  
- [Return to the entrance](#entrance)

```nim on:enter
hasTorch = true
torchQuality = "bright"
```

# hall_of_statues {"hidden": true}
‚†Ä
You step into a vast hall supported by crumbling pillars. **Three stone statues** stand guard, each depicting a different warrior from a forgotten age. Their hollow eyes seem to follow you as you move.
‚†Ä
Passages branch off in three directions:
- To the **north**, you hear the sound of rushing water
- To the **east**, a faint blue glow emanates from the darkness  
- To the **west**, you smell something acrid and unpleasant
‚†Ä
The main entrance lies behind you.
‚†Ä
- [Go north toward the water](#underground-river)  
- [Go east toward the blue glow](#crystal-chamber)  
- [Go west toward the smell](#alchemist-lab)  
- [Examine the statues](#examine-statues)  
- [Return to entrance](#entrance)

# examine_statues {"hidden": true}
‚†Ä
You approach the statues carefully. Each warrior is carved in exquisite detail:
‚†Ä
The **first statue** holds a sword pointed downward, its face serene.  
The **second statue** clutches a shield, face twisted in rage.  
The **third statue** bears a broken chain, face sorrowful.
‚†Ä
At the base of the third statue, you notice something glinting in the torchlight.
‚†Ä
- [Take the glinting object](#find-key)  
- [Return to the hall](#hall-of-statues)

# find_key {"hidden": true, "removeAfterVisit": "true"}
‚†Ä
You reach down and pick up a small, tarnished **brass key**. It's surprisingly heavy for its size, and covered in the same ancient runes you saw at the entrance.
‚†Ä
*This might unlock something important.*
‚†Ä
[Return to the hall](#hall-of-statues)

```nim on:enter
hasKey = true
```

# underground_river {"hidden": true}
‚†Ä
The passage opens into a cavern split by a **rushing underground river**. The water is black as ink and moves with frightening speed. A narrow stone bridge crosses the chasm, but it looks ancient and unstable.
‚†Ä
On the far side, you can see a doorway carved into the rock.
‚†Ä
- [Cross the bridge carefully](#cross-bridge)  
- [Search for another way](#search-riverbank)  
- [Return to the hall](#hall-of-statues)

# cross_bridge {"hidden": true}
‚†Ä
You step onto the stone bridge. It groans under your weight, and small chunks of stone crumble into the dark water below. Halfway across, you freeze as a loud **CRACK** echoes through the cavern.
‚†Ä
But the bridge holds. Barely.
‚†Ä
You make it to the other side, heart pounding.
‚†Ä
- [Enter the carved doorway](#treasure-vault)  
- [Go back across (carefully)](#underground-river)

# search_riverbank {"hidden": true}
‚†Ä
You search along the riverbank, looking for another way across. Behind a fallen column, you discover an old rope tied to an iron ring. Following it up, you see it leads to a natural rock shelf that crosses above the river.
‚†Ä
A safer path, if you're willing to climb.
‚†Ä
- [Take the high route](#treasure-vault)  
- [Just use the bridge](#cross-bridge)  
- [Go back](#underground-river)

# crystal_chamber {"hidden": true}
‚†Ä
You follow the blue glow into a chamber filled with **luminescent crystals** growing from the walls and ceiling. They pulse with an eerie inner light, casting everything in shades of azure and violet.
‚†Ä
In the center of the room stands a stone pedestal. Resting atop it is a beautiful **silver amulet**, set with a matching blue crystal.
‚†Ä
The chamber has two other exits: one to the north and one continuing east.
‚†Ä
- [Take the amulet](#take-amulet)  
- [Go north](#library)  
- [Continue east](#guardian-chamber)  
- [Return to the hall](#hall-of-statues)

# take_amulet {"hidden": true, "removeAfterVisit": "true"}
‚†Ä
You reach for the amulet. The moment your fingers touch the cold silver, the crystals around you **flare brilliantly**. You feel a surge of warmth spread through your body.
‚†Ä
*The amulet pulses with protective magic.*
‚†Ä
- [Go north](#library)  
- [Continue east](#guardian-chamber)  
- [Return to crystal chamber](#crystal-chamber)

```nim on:enter
hasAmulet = true
```

# library {"hidden": true}
‚†Ä
You enter what must have once been a library. Ancient books line rotting shelves, most crumbling to dust. In the center of the room, a single tome rests on a reading stand, somehow preserved.
‚†Ä
You open the book. The pages are filled with riddles and wisdom of the ancients. One passage catches your eye:
‚†Ä
*"The guardian seeks not strength, but humility. The warrior who bows is greater than one who strikes."*
‚†Ä
- [Study more of the book](#library)  
- [Go south](#crystal-chamber)  
- [Go back to the hall](#hall-of-statues)

```nim on:enter
visitedLibrary = true
```

# alchemist_lab {"hidden": true}
‚†Ä
The acrid smell leads you to an old laboratory. Broken glass and ceramic vessels litter the floor. Strange stains mark the walls. Whatever happened here, it wasn't pleasant.
‚†Ä
Among the debris, you find a workbench with several intact bottles. One contains a glowing green liquid labeled *"Essence of Light"* in faded script.
‚†Ä
- [Take the essence](#take-essence)  
- [Search the room more carefully](#search-lab)  
- [Return to the hall](#hall-of-statues)

# take_essence {"hidden": true, "removeAfterVisit": "true"}
‚†Ä
You carefully pocket the glowing essence. It feels warm through the glass.
‚†Ä
*This might prove useful.*
‚†Ä
- [Search the room](#search-lab)  
- [Return to the hall](#hall-of-statues)

```nim on:enter
hasEssence = true
```

# search_lab {"hidden": true, "removeAfterVisit": "true"}
‚†Ä
Searching more carefully, you find the alchemist's journal beneath some rubble. The final entry reads:
‚†Ä
*"My experiments with the guardian have failed. It cannot be destroyed, only understood. I leave this place to whatever fate awaits. May those who follow be wiser than I."*
‚†Ä
- [Return to the laboratory](#alchemist-lab)  
- [Go to the hall](#hall-of-statues)

# guardian_chamber {"hidden": true}
‚†Ä
You enter a vast circular chamber. At its center stands a towering figure of **living stone**‚Äîthe Guardian of Khel-Daran. Its eyes glow with ancient intelligence.
‚†Ä
The Guardian speaks, its voice like grinding boulders:

*"Who dares disturb my eternal vigil? Prove your worth, or be destroyed!"*
‚†Ä
Three pedestals surround the guardian, each marked with a symbol: **Sword**, **Shield**, and **Chains**.
‚†Ä
- [Place an offering on the Sword pedestal](#guardian-fail)  
- [Place an offering on the Shield pedestal](#guardian-fail)  
- [Place an offering on the Chains pedestal](#guardian-success)  
- [Attack the guardian](#guardian-attack)  
- [Try to reason with the guardian](#guardian-reason)

# guardian_attack {"hidden": true}
‚†Ä
You draw your weapon and charge at the stone guardian. It doesn't even move.

Your blade strikes the living stone and **shatters**. The guardian's fist comes down like a falling boulder. Everything goes dark.
‚†Ä
*Perhaps violence wasn't the answer.*
‚†Ä
- [Try again?](#guardian-chamber)

# guardian_reason {"hidden": true}
‚†Ä
You lower your weapon and address the guardian with respect:

"I seek not to conquer, but to understand. I come in peace."
‚†Ä
The guardian tilts its massive head, considering. Then it speaks:
‚†Ä
*"Wisdom... rare among your kind. But words alone are insufficient. Show me you understand the truth of strength."*
‚†Ä
- [Place something on a pedestal](#guardian-chamber)

# guardian_fail {"hidden": true}
‚†Ä
You place your offering on the pedestal. The guardian's eyes flare **angry red**.

*"You understand nothing! Strength and defense are the tools of the proud. True power lies in freedom and sacrifice!"*

The chamber begins to shake violently.
‚†Ä
- [Run back](#crystal-chamber)  
- [Try a different pedestal](#guardian-chamber)

# guardian_success {"hidden": true}
‚†Ä
You approach the pedestal marked with broken chains and bow your head. The gesture of **humility and understanding** resonates through the chamber.
‚†Ä
The guardian's eyes shift from threatening red to a calm **golden glow**.
‚†Ä
*"You comprehend the ancient wisdom. Strength is nothing without the wisdom to bind it. You may pass."*
‚†Ä
The guardian steps aside, revealing a passage to the **Treasure Vault**.
‚†Ä
- [Enter the vault](#treasure-vault)

```nim on:enter
if visitedLibrary:
  draw(0, h-1, 0, w, 1, "Your knowledge from the library helped you understand!", "AlignCenter", "AlignTop", "WrapNone")
```

- [Enter the vault](#treasure-vault)

# treasure_vault {"hidden": true}
‚†Ä
You enter the fabled treasure vault of Khel-Daran. Gold coins spill across the floor, gems glitter in the light of your torch, and ancient weapons line the walls.
‚†Ä
But your eyes are drawn to the center of the room, where a magnificent **sword** rests on an altar, bathed in a beam of light from above. This is the legendary **Blade of Khel-Daran**, said to have defended these lands centuries ago.
‚†Ä
The inscription on the altar reads:
*"To those who brave the depths with wisdom and courage, this is your reward."*
‚†Ä
**Congratulations! You have completed the adventure!**
‚†Ä
- [Take the sword and leave](#victory)  
- [Explore the vault more](#treasure-vault)  
- [Return to the guardian](#guardian-chamber)

# victory {"hidden": true}
‚†Ä
You lift the Blade of Khel-Daran from its altar. The weapon feels perfectly balanced in your hand, and seems to **hum with ancient power**.
‚†Ä
As you make your way back through the dungeon, you notice the guardian watching you with what might be... respect? The stone colossus bows its head slightly as you pass.
‚†Ä
Emerging into the daylight, you shield your eyes against the sun. The ruins of Khel-Daran stand behind you, their secrets revealed.
‚†Ä
**Your adventure is complete! You are victorious!**
‚†Ä
*The legend of Khel-Daran will be told for generations.*
‚†Ä
[Explore more endings?](#hall-of-statues)

# take_sconce {"hidden": true, "removeAfterVisit": "true"}
‚†Ä
You remove the iron sconce from the wall. It's heavier than it looks and has a wicked pointed end. In a pinch, this could serve as a makeshift weapon.
‚†Ä
*Might be useful in the dark.*
‚†Ä
- [Continue to the ruins](#hall-of-statues)  
- [Go back](#entrance-examine)

```nim on:enter
hasWeapon = true
```
---
title: "Layer Compositing Tutorial"
minWidth: 60
minHeight: 18
theme: "neotopia"
---

# Understanding Layers and Compositing

This tutorial demonstrates how the layer system works in TStorie. Layers allow you to organize your drawing into separate buffers that composite together.

```nim on:init
# ===================================================================
# Understanding Layer Z-Order
# ===================================================================
# Layers composite from LOW z-value to HIGH z-value
# - Lower z values are drawn FIRST (background)
# - Higher z values are drawn LAST (foreground)

# Create named layers with explicit z-order
addLayer("background", 1)  # z=1, drawn after default layer
addLayer("middle", 2)      # z=2, drawn after background
addLayer("overlay", 3)     # z=3, drawn on top of all

# Layer visibility toggles
var showBackground = true
var showMiddle = true
var showOverlay = true

# Animation
var time = 0.0

var message = "Space: Toggle layers | Watch the animated overlay on 'overlay' layer"
```

```nim on:render
# ===================================================================
# Render
# ===================================================================
clear(0)

let w = termWidth
let h = termHeight

# Title
fillBox("default", 0, 0, w, 3, "‚ïê", getStyle("primary"))
drawLabel("default", w div 2 - 15, 1, "LAYER COMPOSITING TUTORIAL", getStyle("warning"))

# Instructions panel
drawPanel("default", 2, 5, 40, 25, "How Layers Work", "double")

drawLabel("default", 4, 7, "Layers composite by z-order:", getStyle("info"))
drawLabel("default", 4, 8, "‚Ä¢ Lower z = drawn first (back)", getStyle("dim"))
drawLabel("default", 4, 9, "‚Ä¢ Higher z = drawn last (front)", getStyle("dim"))

drawLabel("default", 4, 11, "This demo has 4 layers:", getStyle("success"))
drawLabel("default", 4, 13, "'default' (z=0):", getStyle("dim"))
drawLabel("default", 6, 14, "UI and instructions", getStyle("dim"))
drawLabel("default", 4, 16, "'background' (z=1):", getStyle("dim"))
drawLabel("default", 6, 17, "Background grid pattern", getStyle("dim"))
drawLabel("default", 4, 19, "'middle' (z=2):", getStyle("dim"))
drawLabel("default", 6, 20, "Static content boxes", getStyle("dim"))
drawLabel("default", 4, 22, "'overlay' (z=3):", getStyle("dim"))
drawLabel("default", 6, 23, "Animated foreground text", getStyle("dim"))

drawLabel("default", 4, 25, "Layer Count: " & str(getLayerCount()), getStyle("info"))

# Controls
drawLabel("default", 4, 27, "Space: Toggle layers", getStyle("warning"))
drawLabel("default", 4, 28, "1-3: Toggle individual layers", getStyle("warning"))

# ===================================================================
# BACKGROUND LAYER - (z=1, drawn FIRST after default)
# ===================================================================
if showBackground:
  # Clear layer with transparent background
  clear("background", true)
  
  # Draw a grid pattern
  var gx = 44
  while gx < 88:
    var gy = 5
    while gy < 30:
      if gx mod 4 == 0 and gy mod 2 == 0:
        drawLabel("background", gx, gy, "¬∑", getStyle("dim"))
      gy = gy + 1
    gx = gx + 1
  
  # Border for the demo area
  drawBox("background", 44, 5, 44, 25, getStyle("border"), "single")
  drawLabel("background", 46, 5, "[ background layer ]", getStyle("dim"))

# ===================================================================
# MIDDLE LAYER - (z=2, drawn SECOND)
# ===================================================================
if showMiddle:
  # Clear layer with transparent background
  clear("middle", true)
  
  # Draw static content boxes
  fillBox("middle", 50, 8, 15, 5, "‚ñí", getStyle("info"))
  drawBox("middle", 50, 8, 15, 5, getStyle("border"), "double")
  drawLabel("middle", 52, 10, "Static Box 1", getStyle("text"))
  
  fillBox("middle", 68, 15, 15, 5, "‚ñë", getStyle("success"))
  drawBox("middle", 68, 15, 15, 5, getStyle("border"), "rounded")
  drawLabel("middle", 70, 17, "Static Box 2", getStyle("text"))

# ===================================================================
# OVERLAY LAYER - (z=3, drawn THIRD on top of all)
# ===================================================================
if showOverlay:
  # Clear layer with transparent background
  clear("overlay", true)
  
  # Animated box that moves and changes size
  var centerX = 66
  var centerY = 15
  var boxWidth = 10 + int(sin(time * 2.0) * 3.0)
  var boxHeight = 6 + int(cos(time * 2.0) * 2.0)
  
  var boxX = centerX - int(boxWidth / 2)
  var boxY = centerY - int(boxHeight / 2)
  
  # Draw with bold border and solid fill
  fillBox("overlay", boxX, boxY, boxWidth, boxHeight, "‚ñà", getStyle("warning"))
  drawBox("overlay", boxX, boxY, boxWidth, boxHeight, getStyle("border"), "bold")
  drawLabel("overlay", boxX + 2, boxY + 2, "Overlay", getStyle("text"))
  drawLabel("overlay", boxX + 2, boxY + 3, "on top!", getStyle("dim"))

# ===================================================================
# Layer Status (on default layer)
# ===================================================================
drawPanel("default", 2, 31, 86, 3, "Layer Status", "single")
drawLabel("default", 4, 32, if showBackground: "[‚úì] background (z=1)" else: "[ ] background (z=1)", 
         if showBackground: getStyle("success") else: getStyle("dim"))
drawLabel("default", 30, 32, if showMiddle: "[‚úì] middle (z=2)" else: "[ ] middle (z=2)", 
         if showMiddle: getStyle("success") else: getStyle("dim"))
drawLabel("default", 56, 32, if showOverlay: "[‚úì] overlay (z=3)" else: "[ ] overlay (z=3)", 
         if showOverlay: getStyle("success") else: getStyle("dim"))

# Footer
fillBox("default", 0, h - 2, w, 2, " ", getStyle("default"))
drawLabel("default", 2, h - 1, message, getStyle("warning"))
```

```nim on:update
# Advance animation time
time = time + 0.05
```

```nim on:input
if event.type == "key":
  let keyCode = event.keyCode
  
  # Space - Cycle through layer visibility
  if keyCode == 32:
    if showBackground and showMiddle and showOverlay:
      showOverlay = false
      message = "'overlay' hidden - see static middle layer content"
    elif showBackground and showMiddle and not showOverlay:
      showMiddle = false
      message = "'middle' hidden - only background visible now"
    elif showBackground and not showMiddle and not showOverlay:
      showBackground = false
      message = "All layers hidden - only UI remains"
    else:
      showBackground = true
      showMiddle = true
      showOverlay = true
      message = "All layers visible - watch layer compositing in action!"
    return true
  
  # Number keys - Toggle individual layers
  if keyCode == 49:  # '1'
    showBackground = not showBackground
    message = "'background' layer: " & (if showBackground: "ON" else: "OFF")
    return true
  elif keyCode == 50:  # '2'
    showMiddle = not showMiddle
    message = "'middle' layer: " & (if showMiddle: "ON" else: "OFF")
    return true
  elif keyCode == 51:  # '3'
    showOverlay = not showOverlay
    message = "'overlay' layer: " & (if showOverlay: "ON" else: "OFF")
    return true
  
  return false

return false
```

## Key Concepts

### String-Based Layer API (Recommended)
**Use named layers for clarity and maintainability!**

```nim
# Create layers with explicit names and z-order
addLayer("background", 1)
addLayer("middle", 2)
addLayer("overlay", 3)

# Draw using layer names (no more guessing what layer 1 or 2 means!)
drawLabel("background", x, y, "text", style)
fillBox("overlay", x, y, w, h, "‚ñà", style)

# The default layer always exists
drawLabel("default", x, y, "UI", style)
```

### Legacy Numeric API (Still Supported)
You can still use numeric indices for backwards compatibility:

```nim
# Draws to layer by index - auto-creates with z=index
drawLabel(1, x, y, "text", style)  # Creates layer with z=1
fillBox(2, x, y, w, h, "‚ñà", style) # Creates layer with z=2
```

However, **string names are clearer** than remembering what layer 1, 2, or 3 represent!

### Z-Order (Important!)
- **Lower z values = drawn FIRST (background)**
- **Higher z values = drawn LAST (foreground)**
- Example: z=0 ‚Üí z=1 ‚Üí z=2 means 0 is bottom, 2 is top

### Transparency
```nim
# Clear with transparent background (lets lower layers show through)
clear(layer, true)

# Clear with solid background (blocks lower layers)
clear(layer, false)
```

### Layer Management Functions

```nim
# Create layers with names and custom z-order
addLayer("myLayer", 15)         # z=15, very high
addLayer("hud", 100)            # z=100, always on top

# Layer management
removeLayer("myLayer")          # Delete a layer
setLayerVisible("myLayer", false)  # Hide without deleting
getLayerCount()                  # Get total number of layers
```

### Drawing to Layers
All drawing functions accept a layer parameter (string name or int index):
- `drawLabel("layer", x, y, text, style)`
- `fillBox("layer", x, y, w, h, char, style)`
- `drawBox("layer", x, y, w, h, style, borderType)`
- `drawPanel("layer", x, y, w, h, title, borderType)`
- `clear("layer", transparent)`

**Tip:** Use string names for all layer operations to make your code self-documenting!

Press **Space** to see how layers composite!
---
title: "Manual Drawing & Compositing Demo"
minWidth: 60
minHeight: 18
theme: "neotopia"
---

# Drawing API Showcase

This demo showcases the drawing system including box styles, fill operations, and various drawing primitives.

```nim on:init
# ===================================================================
# State Management
# ===================================================================
var animFrame = 0
var rotation = 0.0

# Moving shapes for demo
var circle1X = 45.0
var circle1Y = 10.0
var circle1DirX = 0.3
var circle1DirY = 0.2

var circle2X = 50.0
var circle2Y = 12.0
var circle2DirX = -0.25
var circle2DirY = 0.15

# Box style cycling
var currentBoxStyle = 0
var boxStyles = @["single", "double", "rounded", "bold", "ascii"]
var boxStyleNames = @["Single Line", "Double Line", "Rounded", "Bold", "ASCII"]

# Fill pattern
var fillPattern = 0
var fillPatterns = @["‚ñà", "‚ñì", "‚ñí", "‚ñë", "‚ñ†", "‚óè", "‚óÜ", "‚ñ™"]

# Message
var message = "B: Change box style | F: Change fill pattern | Arrow keys: Move red circle"
```

```nim on:render
# ===================================================================
# Render
# ===================================================================
clear()

let w = termWidth
let h = termHeight

# Title banner
fillBox(0, 0, 0, w, 3, "‚ïê", getStyle("primary"))
drawLabel(0, w div 2 - 12, 1, "DRAWING API SHOWCASE", getStyle("warning"))

# Decorative corners
drawLabel(0, 0, 0, "‚ïî", getStyle("primary"))
drawLabel(0, w - 1, 0, "‚ïó", getStyle("primary"))
drawLabel(0, 0, 2, "‚ïö", getStyle("primary"))
drawLabel(0, w - 1, 2, "‚ïù", getStyle("primary"))

# Draw a grid background using dots
var gx = 0
while gx < w:
  var gy = 5
  while gy < h - 3:
    if gx mod 10 == 0 or gy mod 5 == 0:
      drawLabel(0, gx, gy, "¬∑", getStyle("dim"))
    gy = gy + 1
  gx = gx + 1

# ===================================================================
# Box Styles Gallery
# ===================================================================
drawPanel(0, 2, 5, 30, 18, "Box Styles Gallery", boxStyles[currentBoxStyle])

var styleY = 7
var idx = 0
while idx < len(boxStyles):
  let style = boxStyles[idx]
  let name = boxStyleNames[idx]
  let isCurrent = idx == currentBoxStyle
  
  drawBox(0, 4, styleY, 12, 3, getStyle("border"), style)
  drawLabel(0, 17, styleY + 1, name, if isCurrent: getStyle("success") else: getStyle("default"))
  
  styleY = styleY + 3
  idx = idx + 1

# ===================================================================
# Fill Patterns
# ===================================================================
drawPanel(0, 35, 5, 30, 12, "Fill Patterns", "double")

# Large filled rectangle with current pattern
let patternChar = fillPatterns[fillPattern]
fillBox(0, 37, 7, 26, 5, patternChar, getStyle("primary"))
drawLabel(0, 39, 8, "Current: " & patternChar, getStyle("warning"))

# Gradient-like effect using different fill patterns
var px = 37
var pidx = 0
while pidx < 4:
  fillBox(0, px, 13, 5, 3, fillPatterns[pidx], getStyle("info"))
  px = px + 6
  pidx = pidx + 1
drawLabel(0, 37, 12, "Density Gradient:", getStyle("dim"))

# ===================================================================
# Animated Circles
# ===================================================================
drawPanel(0, 35, 18, 30, 10, "Animated Shapes", "rounded")

let cx1 = int(circle1X)
let cy1 = int(circle1Y)

drawLabel(0, cx1, cy1 - 2, "‚ñÄ", getStyle("danger"))
drawLabel(0, cx1 - 1, cy1 - 1, "‚ñÑ‚ñà‚ñÄ", getStyle("danger"))
drawLabel(0, cx1 - 1, cy1, "‚ñà‚óè‚ñà", getStyle("danger"))
drawLabel(0, cx1 - 1, cy1 + 1, "‚ñÄ‚ñà‚ñÑ", getStyle("danger"))
drawLabel(0, cx1, cy1 + 2, "‚ñÑ", getStyle("danger"))

let cx2 = int(circle2X)
let cy2 = int(circle2Y)

drawLabel(0, cx2, cy2 - 2, "‚ñÄ", getStyle("success"))
drawLabel(0, cx2 - 1, cy2 - 1, "‚ñÑ‚ñà‚ñÄ", getStyle("success"))
drawLabel(0, cx2 - 1, cy2, "‚ñà‚óè‚ñà", getStyle("success"))
drawLabel(0, cx2 - 1, cy2 + 1, "‚ñÄ‚ñà‚ñÑ", getStyle("success"))
drawLabel(0, cx2, cy2 + 2, "‚ñÑ", getStyle("success"))

drawLabel(0, 37, 26, "Red: " & str(cx1) & "," & str(cy1), getStyle("danger"))
drawLabel(0, 54, 26, "Grn: " & str(cx2) & "," & str(cy2), getStyle("success"))

# ===================================================================
# Drawing Primitives
# ===================================================================
drawPanel(0, 68, 5, 30, 23, "Drawing Primitives", "single")

# Horizontal line
var hx = 70
while hx < 96:
  drawLabel(0, hx, 8, "‚îÄ", getStyle("info"))
  hx = hx + 1
drawLabel(0, 70, 7, "Horizontal Line", getStyle("dim"))

# Vertical line
var vy = 10
while vy < 20:
  drawLabel(0, 70, vy, "‚îÇ", getStyle("success"))
  vy = vy + 1
drawLabel(0, 72, 10, "Vertical", getStyle("dim"))

# Diagonal patterns
var dx = 0
while dx < 8:
  drawLabel(0, 80 + dx, 10 + dx, "‚ï±", getStyle("danger"))
  drawLabel(0, 88 + dx, 10 + dx, "‚ï≤", getStyle("warning"))
  dx = dx + 1
drawLabel(0, 82, 9, "Diagonals", getStyle("dim"))

# Small filled boxes with patterns
var bx = 70
var bpidx = 0
while bpidx < 4:
  fillBox(0, bx, 20, 4, 3, fillPatterns[bpidx + 4], getStyle("default"))
  drawBox(0, bx, 20, 4, 3, getStyle("border"), "single")
  bx = bx + 5
  bpidx = bpidx + 1
drawLabel(0, 70, 19, "Pattern Samples:", getStyle("dim"))

# API list
drawLabel(0, 70, 24, "APIs Used:", getStyle("info"))
drawLabel(0, 70, 25, "‚Ä¢ drawPanel()", getStyle("dim"))
drawLabel(0, 70, 26, "‚Ä¢ drawBox()", getStyle("dim"))

# ===================================================================
# Controls Panel
# ===================================================================
drawPanel(0, 2, 24, 30, 7, "Controls", "rounded")
drawLabel(0, 4, 26, "B: Change Box Style", getStyle("info"))
drawLabel(0, 4, 27, "F: Change Fill Pattern", getStyle("info"))
drawLabel(0, 4, 28, "Arrows: Move Red Circle", getStyle("info"))

# ===================================================================
# Stats Panel
# ===================================================================
drawPanel(0, 2, 32, 30, 8, "Statistics", "double")
drawLabel(0, 4, 34, "Frame: " & str(animFrame), getStyle("info"))
drawLabel(0, 4, 35, "Rotation: " & str(int(rotation)), getStyle("info"))
drawLabel(0, 4, 36, "Box Style: " & boxStyleNames[currentBoxStyle], getStyle("info"))
drawLabel(0, 4, 37, "Fill Pattern: " & fillPatterns[fillPattern], getStyle("info"))

# ===================================================================
# API Reference
# ===================================================================
drawPanel(0, 35, 29, 63, 11, "Available Drawing APIs", "single")
drawLabel(0, 37, 31, "‚Ä¢ fillBox(layer, x, y, w, h, char, style)", getStyle("dim"))
drawLabel(0, 37, 32, "‚Ä¢ drawBox(layer, x, y, w, h, style, borderType)", getStyle("dim"))
drawLabel(0, 37, 33, "‚Ä¢ drawPanel(layer, x, y, w, h, title, borderType)", getStyle("dim"))
drawLabel(0, 37, 34, "‚Ä¢ drawLabel(layer, x, y, text, style)", getStyle("dim"))
drawLabel(0, 37, 35, "‚Ä¢ getStyle(name) - Get themed color style", getStyle("dim"))
drawLabel(0, 37, 36, "‚Ä¢ clear() - Clear the display buffer", getStyle("dim"))
drawLabel(0, 37, 37, "‚Ä¢ termWidth / termHeight - Get dimensions", getStyle("dim"))

# Footer message bar
fillBox(0, 0, h - 2, w, 2, " ", getStyle("default"))
drawLabel(0, 2, h - 1, message, getStyle("warning"))
```

```nim on:update
# ===================================================================
# Animation Update
# ===================================================================
animFrame = animFrame + 1
rotation = rotation + 2.0
if rotation >= 360.0:
  rotation = 0.0

# Update circle 1 position
circle1X = circle1X + circle1DirX
circle1Y = circle1Y + circle1DirY

# Bounce off boundaries (within the animated shapes panel)
if circle1X < 37.0 or circle1X > 62.0:
  circle1DirX = -circle1DirX
if circle1Y < 20.0 or circle1Y > 26.0:
  circle1DirY = -circle1DirY

# Update circle 2 position
circle2X = circle2X + circle2DirX
circle2Y = circle2Y + circle2DirY

# Bounce off boundaries
if circle2X < 37.0 or circle2X > 62.0:
  circle2DirX = -circle2DirX
if circle2Y < 20.0 or circle2Y > 26.0:
  circle2DirY = -circle2DirY
```

```nim on:input
# ===================================================================
# Input Handling
# ===================================================================
if event.type == "key":
  let keyCode = event.keyCode
  
  # B - Change box style
  if keyCode == 98 or keyCode == 66:  # 'b' or 'B'
    currentBoxStyle = (currentBoxStyle + 1) mod len(boxStyles)
    message = "Box style: " & boxStyleNames[currentBoxStyle]
    return true
  
  # F - Change fill pattern
  if keyCode == 102 or keyCode == 70:  # 'f' or 'F'
    fillPattern = (fillPattern + 1) mod len(fillPatterns)
    message = "Fill pattern: " & fillPatterns[fillPattern]
    return true
  
  # Arrow keys - Manual control of circle 1
  if keyCode == 10000:  # Up
    circle1Y = circle1Y - 1.0
    if circle1Y < 20.0:
      circle1Y = 20.0
    message = "Red circle moved up"
    return true
  elif keyCode == 10001:  # Down
    circle1Y = circle1Y + 1.0
    if circle1Y > 26.0:
      circle1Y = 26.0
    message = "Red circle moved down"
    return true
  elif keyCode == 10002:  # Left
    circle1X = circle1X - 1.0
    if circle1X < 37.0:
      circle1X = 37.0
    message = "Red circle moved left"
    return true
  elif keyCode == 10003:  # Right
    circle1X = circle1X + 1.0
    if circle1X > 62.0:
      circle1X = 62.0
    message = "Red circle moved right"
    return true
  
  return false

elif event.type == "mouse":
  # Click to move circle 1
  if event.action == "press":
    let mx = event.x
    let my = event.y
    
    # If clicked in the animated shapes panel
    if mx >= 37 and mx < 63 and my >= 20 and my < 27:
      circle1X = float(mx)
      circle1Y = float(my)
      message = "Red circle teleported to click position"
      return true
  
  return false

return false
```

## Features Demonstrated

### Drawing APIs
- `fillBox()` - Fill rectangular areas with any character pattern
- `drawBox()` - Draw boxes with various border styles  
- `drawPanel()` - Draw titled panels with borders
- `drawLabel()` - Draw text and single characters at any position
- `getStyle()` - Get themed color styles (primary, success, danger, info, warning, dim, etc.)
- `clear()` - Clear the display buffer
- `termWidth` / `termHeight` - Get terminal dimensions

### Box Styles
- **Single line** (`single`) - ‚îå‚îÄ‚îê‚îÇ‚îî‚îò
- **Double line** (`double`) - ‚ïî‚ïê‚ïó‚ïë‚ïö‚ïù
- **Rounded** (`rounded`) - ‚ï≠‚îÄ‚ïÆ‚îÇ‚ï∞‚ïØ  
- **Bold** (`bold`) - Thicker lines
- **ASCII** (`ascii`) - +-+|| (fallback)

### Fill Patterns
Multiple density levels and shapes: ‚ñà ‚ñì ‚ñí ‚ñë ‚ñ† ‚óè ‚óÜ ‚ñ™

### Interactive Controls
- **B**: Cycle through box styles
- **F**: Cycle through fill patterns
- **Arrow Keys**: Manually move the red circle
- **Mouse Click**: Teleport red circle to click position within the panel

All drawing happens on layer 0, with automatic theme-aware styling!
---
title: "Dungeon Generator - Native Edition"
author: "High-performance procedural dungeon using native Nim"
theme: solardark
shader: sand+grid+paper+lightsway
fontsize: 24
---

# Dungeon Generator

Press **R** to regenerate with a new random seed.

**Performance:** Native Nim implementation (~100x faster than interpreted)

```nim on:init
# Global state
var dungeon # Will hold pointer to DungeonGenerator
var width = termWidth - 1
var height = termHeight - 5
var seedValue = 0

# Initialize dungeon
proc initDungeon() =
  # Check if seed was provided via parameter (URL or command-line)
  var hasSeedParam = hasParam("seed")
  var seedParam = getParam("seed")
  
  if hasSeedParam == true and len(seedParam) > 0:
    seedValue = getParamInt("seed", 0)
    if seedValue <= 0:
      seedValue = rand(0, 999999)
  else:
    seedValue = rand(0, 999999)
  
  # Create native dungeon generator
  dungeon = newDungeonGenerator(width, height, seedValue)
  
  # Generate complete dungeon instantly (native is FAST!)
  generate(dungeon)

# Initialize on startup
initDungeon()
```

```nim on:update
width = termWidth - 1
height = termHeight - 5
```

```nim on:render
# Draw the dungeon
clear()

# Render the dungeon
for y in 0..<height:
  for x in 0..<width:
    var cellType = getCellAt(dungeon, x, y)
    var ch = dungeonGetCellChar(cellType)
    draw(0, x, y, ch)

# Show status
var steps = getStep(dungeon)
draw(0, 0, height + 1, "Seed: " & str(seedValue) & "  Steps: " & str(steps) & "  (Native Nim - Instant!)")
draw(0, 0, height + 2, "Press R or click/touch anywhere to regenerate")
```

```nim on:input
# Handle keyboard input
if event.type == "text":
  var key = event.text
  if key == "r" or key == "R":
    initDungeon()
    return true
  return false

# Handle mouse/touch input
elif event.type == "mouse":
  if event.action == "press":
    initDungeon()
    return true

return false
```
---
title: "Dungeon Generator - Nimini Edition"
author: "Procedural dungeon using nimini scripting with isolated RNG"
minWidth: 80
minHeight: 20
---

# Dungeon Generator

Press **R** to regenerate with a new random seed.

**Features:** Room-based dungeon with smart corridor connections and door placement!

```nim on:init

# Constants - identical in script and native
const WALL = 0
const FLOOR = 1
const DOOR = 2
const CORRIDOR = 3

# Global state
var grid: seq
var rooms: seq
var width = termWidth - 1
var height = termHeight - 5
var seedValue = 0

# Configuration
var maxRoomSize = 9
var minRoomSize = 4
var roomAttempts = 60

# Simple Rect structure using seq
proc makeRect(x: int, y: int, w: int, h: int): seq =
  var r = newSeq(4)
  r[0] = x
  r[1] = y
  r[2] = w
  r[3] = h
  return r

proc getRectX(r: seq): int =
  return r[0]

proc getRectY(r: seq): int =
  return r[1]

proc getRectW(r: seq): int =
  return r[2]

proc getRectH(r: seq): int =
  return r[3]

proc getRectCenterX(r: seq): int =
  return r[0] + idiv(r[2], 2)

proc getRectCenterY(r: seq): int =
  return r[1] + idiv(r[3], 2)

# Check if two rooms overlap (with buffer)
proc roomsOverlap(r1: seq, r2: seq): bool =
  var buffer = 3
  var r1Right = getRectX(r1) + getRectW(r1) + buffer
  var r1Bottom = getRectY(r1) + getRectH(r1) + buffer
  var r2Right = getRectX(r2) + getRectW(r2) + buffer
  var r2Bottom = getRectY(r2) + getRectH(r2) + buffer
  
  var r1Left = getRectX(r1) - buffer
  var r1Top = getRectY(r1) - buffer
  var r2Left = getRectX(r2) - buffer
  var r2Top = getRectY(r2) - buffer
  
  if r1Left >= r2Right or r2Left >= r1Right:
    return false
  if r1Top >= r2Bottom or r2Top >= r1Bottom:
    return false
  
  return true

# Get cell type
proc getCell(x: int, y: int): int =
  if y >= 0 and y < height and x >= 0 and x < width:
    var row = grid[y]
    return row[x]
  return WALL

# Set cell type
proc setCell(x: int, y: int, cellType: int) =
  if y >= 0 and y < height and x >= 0 and x < width:
    var row = grid[y]
    row[x] = cellType

# Generate dungeon with rooms and corridors
proc generateDungeon(w: int, h: int, seed: int): seq =
  var rng = initRand(seed)
  
  # Initialize grid - all walls
  var g = newSeq(h)
  for y in 0..<h:
    var row = newSeq(w)
    for x in 0..<w:
      row[x] = WALL
    g[y] = row
  
  grid = g
  rooms = newSeq(0)
  
  # Try to place rooms
  for attempt in 0..<roomAttempts:
    var roomW = rng.rand(maxRoomSize - minRoomSize) + minRoomSize
    var roomH = rng.rand(maxRoomSize - minRoomSize) + minRoomSize
    
    if roomW >= w - 4 or roomH >= h - 4:
      continue
    
    var roomX = rng.rand(w - roomW - 3) + 1
    var roomY = rng.rand(h - roomH - 3) + 1
    
    var newRoom = makeRect(roomX, roomY, roomW, roomH)
    
    # Check overlap with existing rooms
    var overlaps = false
    for i in 0..<len(rooms):
      var existingRoom = rooms[i]
      if roomsOverlap(newRoom, existingRoom):
        overlaps = true
        break
    
    if overlaps:
      continue
    
    # Add room
    add(rooms, newRoom)
    
    # Carve room
    var endY = roomY + roomH
    var endX = roomX + roomW
    for ry in roomY..<endY:
      for rx in roomX..<endX:
        setCell(rx, ry, FLOOR)
  
  # Connect rooms with corridors
  var roomCount = len(rooms)
  if roomCount > 1:
    for i in 0..<roomCount-1:
      var room1 = rooms[i]
      var room2 = rooms[i + 1]
      
      var x1 = getRectCenterX(room1)
      var y1 = getRectCenterY(room1)
      var x2 = getRectCenterX(room2)
      var y2 = getRectCenterY(room2)
      
      # Random corridor style (L or inverted L)
      if rng.rand(1) == 0:
        # Horizontal first
        var x = x1
        while x != x2:
          if getCell(x, y1) == WALL:
            setCell(x, y1, CORRIDOR)
          
          if x < x2:
            x = x + 1
          else:
            x = x - 1
        
        # Then vertical
        var y = y1
        while y != y2:
          if getCell(x2, y) == WALL:
            setCell(x2, y, CORRIDOR)
          
          if y < y2:
            y = y + 1
          else:
            y = y - 1
      else:
        # Vertical first
        var y = y1
        while y != y2:
          if getCell(x1, y) == WALL:
            setCell(x1, y, CORRIDOR)
          
          if y < y2:
            y = y + 1
          else:
            y = y - 1
        
        # Then horizontal
        var x = x1
        while x != x2:
          if getCell(x, y2) == WALL:
            setCell(x, y2, CORRIDOR)
          
          if x < x2:
            x = x + 1
          else:
            x = x - 1
  
  # Place doors at room entrances
  if roomCount > 0:
    for i in 0..<roomCount:
      var room = rooms[i]
      var rx = getRectX(room)
      var ry = getRectY(room)
      var rw = getRectW(room)
      var rh = getRectH(room)
      
      # Check around perimeter for corridor connections
      var endY = ry + rh
      var endX = rx + rw
      
      # Check each side of the room for adjacent corridors
      for py in ry..<endY:
        # Check left side (one tile outside room)
        if getCell(rx - 1, py) == CORRIDOR:
          setCell(rx - 1, py, DOOR)
        
        # Check right side (one tile outside room)
        if getCell(endX, py) == CORRIDOR:
          setCell(endX, py, DOOR)
      
      for px in rx..<endX:
        # Check top side (one tile outside room)
        if getCell(px, ry - 1) == CORRIDOR:
          setCell(px, ry - 1, DOOR)
        
        # Check bottom side (one tile outside room)
        if getCell(px, endY) == CORRIDOR:
          setCell(px, endY, DOOR)
  
  return g

# Initialize dungeon with isolated RNG!
proc initDungeon() =
  # Check if seed was provided via parameter (URL or command-line)
  var hasSeedParam = hasParam("seed")
  var seedParam = getParam("seed")
  
  if hasSeedParam and len(seedParam) > 0:
    seedValue = getParamInt("seed", 0)
    if seedValue <= 0:
      seedValue = rand(0, 999999)
  else:
    seedValue = rand(0, 999999)
  
  # Generate complete dungeon - instant and deterministic!
  grid = generateDungeon(width, height, seedValue)

initDungeon()

```

```nim on:update
# No incremental generation needed - dungeon generates instantly!
```

```nim on:render
# Draw the dungeon
clear()

for y in 0..<height:
  var row = grid[y]
  for x in 0..<width:
    var cell = row[x]
    var ch = " "
    
    if cell == WALL:
      ch = "#"
    elif cell == FLOOR:
      ch = "¬∑"
    elif cell == DOOR:
      ch = "+"
    elif cell == CORRIDOR:
      ch = "¬∑"
    
    draw(0, x, y, ch)

# Show info
draw(0, 0, height + 1, "Seed: " & str(seedValue) & " - Room-based with Smart Doors")
draw(0, 0, height + 2, "Press R or click/touch to regenerate | Same seed = Same dungeon! (Export-safe)")
draw(0, 0, height + 3, "Rooms: " & str(len(rooms)) & " | Doors placed at corridor entrances")
```

```nim on:input
# Handle keyboard input
if event.type == "text":
  var key = event.text
  if key == "r" or key == "R":
    initDungeon()
    return true
  return false

# Handle mouse/touch input
elif event.type == "mouse":
  if event.action == "press":
    initDungeon()
    return true

return false
```
---
title: "t|Storie Editor"
theme: "neotopia"
editorX: 0
editorY: 2
dropTarget: true
shaders: "invert+ruledlines+paper+lightnight"
fontsize: 16
---

# t|Storie Text Editor

File size increase: use a Google font

A fully-featured text editor with Unicode support, gap buffer optimization, and minimap visualization!

```nim on:init
# ===================================================================
# State Management
# ===================================================================

# Track frame times for FPS display
var frameStartTime = getTime()
var lastFrameTime = frameStartTime
var displayFps = 60

# Load initial content from URL parameter if provided
var initialContent = @[""]
let contentParam = getParam("load")
var currentFileName = "untitled"
var isSaved = 1
var lastSaveTime = ""

if contentParam != "":
  # Content will be loaded from browser:key or decode:xxx by tstorie itself
  # We just initialize with current content
  add(initialContent, "# Loading...")
else:
  # Default template
  add(initialContent, "")

var editor = newEditor(initialContent)

# Try to restore auto-saved content if no URL parameter provided
if contentParam == "":
  let autoSaved = localStorage_getItem("__autosave__")
  if autoSaved != "" and autoSaved != "#":
    editor = newEditor(autoSaved)
    statusMessage = "Restored auto-saved content (Ctrl+S to save)"
    lastAutoSaveContent = autoSaved

# Focus system: 0=editor, 1=menu, 2=dialog
var focusedComponent = 0

# Menu state
var activeMenu = ""
var hoveredMenuItem = -1

# Dialog state
var showHelp = 0
var showSaveDialog = 0
var showLoadDialog = 0
var showShareDialog = 0
var showLoadGistDialog = 0
var showSaveGistDialog = 0

# Dialog data
var statusMessage = "Ready - Click File menu or use Ctrl+S/O/E shortcuts"
var saveFileName = ""
var shareUrl = ""
var shareUrlReady = 0
var pasteInProgress = 0
var lastPasteCheck = ""
var gistIdInput = ""
var gistDescription = ""
var gistResultUrl = ""
var savedFiles: seq[string] = @[]
var loadSelection = 0

# Selection state
var hasSelection = 0
var selStartLine = 0
var selStartCol = 0
var selEndLine = 0
var selEndCol = 0

# Mouse drag state
var mousePressed = 0
var isDraggingScrollbar = 0
var isDraggingMinimap = 0
var isDraggingText = 0
var dragStartX = 0
var dragStartY = 0

# Auto-save state
var autoSaveTimer = 0
var autoSaveInterval = 180  # Auto-save every 180 frames (~3 seconds at 60fps)
var lastAutoSaveContent = ""

# Statistics
var keyPressCount = 0
var lastKeyCode = 0

# Helper: Clear selection
proc clearSelection() =
  hasSelection = 0

# Helper: Find previous word boundary
proc findPrevWord(line: string, col: int): int =
  if col <= 0:
    return 0
  var pos = col - 1
  # Skip spaces backward
  while pos > 0 and line[pos] == ' ':
    pos = pos - 1
  # Skip word backward
  while pos > 0 and line[pos] != ' ':
    pos = pos - 1
  if line[pos] == ' ' and pos < col - 1:
    pos = pos + 1
  return pos

# Helper: Find next word boundary
proc findNextWord(line: string, col: int): int =
  if col >= len(line):
    return len(line)
  var pos = col
  # Skip current word forward
  while pos < len(line) and line[pos] != ' ':
    pos = pos + 1
  # Skip spaces forward
  while pos < len(line) and line[pos] == ' ':
    pos = pos + 1
  return pos

# Helper: Get selected text
proc getSelectedText(): string =
  if hasSelection == 0:
    return ""
  
  var result = ""
  if selStartLine == selEndLine:
    # Single line selection
    let line = editorGetLine(editor, selStartLine)
    let startCol = min(selStartCol, selEndCol)
    let endCol = max(selStartCol, selEndCol)
    return line[startCol..<endCol]
  else:
    # Multi-line selection
    let startL = min(selStartLine, selEndLine)
    let endL = max(selStartLine, selEndLine)
    let startC = if selStartLine < selEndLine: selStartCol else: selEndCol
    let endC = if selStartLine < selEndLine: selEndCol else: selStartCol
    
    for i in startL..endL:
      let line = editorGetLine(editor, i)
      if i == startL:
        result = result & line[startC..<len(line)]
      elif i == endL:
        result = result & "\n" & line[0..<endC]
      else:
        result = result & "\n" & line
  
  return result

# Helper: Delete selected text
proc deleteSelection() =
  if hasSelection == 0:
    return
  
  # Move cursor to start of selection
  let startL = min(selStartLine, selEndLine)
  let endL = max(selStartLine, selEndLine)
  let startC = if selStartLine < selEndLine: selStartCol else: selEndCol
  let endC = if selStartLine < selEndLine: selEndCol else: selStartCol
  
  editorSetCursor(editor, startL, startC)
  
  # Delete character by character (simple approach)
  if startL == endL:
    # Single line
    for i in 0..<(endC - startC):
      editorDelete(editor)
  else:
    # Multi-line - delete to end of first line, then delete lines, then chars on last line
    let firstLineLen = len(editorGetLine(editor, startL))
    for i in startC..<firstLineLen:
      editorDelete(editor)
    
    # Delete newline and merge with next line
    if endL > startL:
      editorDelete(editor)
    
    # Delete middle lines
    for i in (startL+1)..<endL:
      let lineLen = len(editorGetLine(editor, startL))
      for j in 0..<lineLen:
        editorDelete(editor)
      if i < endL - 1:
        editorDelete(editor)  # newline
    
    # Delete chars on last line
    for i in 0..<endC:
      editorDelete(editor)
  
  clearSelection()

# Helper: Update saved files list
proc refreshFileList() =
  let jsonStr = localStorage_list()
  savedFiles = @[]
  var i = 0
  var currentKey = ""
  var inKey = 0
  while i < len(jsonStr):
    let ch = jsonStr[i]
    if ch == '"' and i > 0 and jsonStr[i-1] != '\\':
      if inKey:
        if currentKey == "key":
          i = i + 1
          while i < len(jsonStr) and jsonStr[i] != '"':
            i = i + 1
          i = i + 1
          var filename = ""
          while i < len(jsonStr) and jsonStr[i] != '"':
            filename = filename & $jsonStr[i]
            i = i + 1
          if filename != "" and filename != "__temp_run__":
            savedFiles = savedFiles & @[filename]
        currentKey = ""
        inKey = 0
      else:
        inKey = 1
        currentKey = ""
        i = i + 1
        while i < len(jsonStr) and jsonStr[i] != '"':
          currentKey = currentKey & $jsonStr[i]
          i = i + 1
    i = i + 1

refreshFileList()
```

```nim on:ondrop
# Handle dropped files
let droppedFileName = getDroppedFileName()
let droppedData = getDroppedFileData()

# Convert binary data to text (assuming UTF-8)
let droppedText = droppedData

# Load into editor
editor = newEditor(droppedText)
currentFileName = droppedFileName
isSaved = 1
editorClearModified(editor)
lastAutoSaveContent = droppedText

# Update status
statusMessage = "‚úì Loaded '" & droppedFileName & "' (" & str(len(droppedText)) & " bytes)"

# Close any open dialogs
showLoadDialog = 0
showSaveDialog = 0
showLoadGistDialog = 0
showSaveGistDialog = 0
showShareDialog = 0
showHelp = 0
activeMenu = ""
focusedComponent = 0
```

```nim on:render
# ===================================================================
# Render
# ===================================================================
clear()

let w = termWidth
let h = termHeight

# Calculate responsive editor dimensions
let editorW = w - 1  # Full width with margins
let editorH = h - 7   # Full height minus title, status bar, and margins

# Title bar
let titleText = "t|"
drawLabel(0, 0, 1, titleText, getStyle("info"))

# Draw the main editor on layer 0
drawEditor(0, editorX, editorY, editorW, editorH, editor, 1, hasSelection, selStartLine, selStartCol, selEndLine, selEndCol)

# Auto-save logic (runs every frame)
autoSaveTimer = autoSaveTimer + 1
if autoSaveTimer >= autoSaveInterval:
  autoSaveTimer = 0
  let currentContent = editorGetText(editor)
  if currentContent != lastAutoSaveContent:
    let success = localStorage_setItem("__autosave__", currentContent)
    if success:
      lastAutoSaveContent = currentContent
      lastSaveTime = "auto-saved"

# Status bar (automatically positioned at bottom)
let statusY = h - 5
drawPanel(0, 0, statusY, w - 1, 5, "Status", "single")

# Get cursor info
let cursor = editorGetCursor(editor)
let cursorLine = cursor["line"]
let cursorCol = cursor["col"]
let lineCount = editorLineCount(editor)
let isModified = editorIsModified(editor)
let scroll = editorGetScroll(editor)
let scrollX = scroll["scrollX"]
let scrollY = scroll["scrollY"]

# Status line 1: Cursor position and scroll
let modStr = if isModified: " [MODIFIED]" else: ""
let scrollInfo = if scrollX > 0 or scrollY > 0: " | Scroll X:" & str(scrollX) & " Y:" & str(scrollY) else: ""
let posInfo = "Line " & str(cursorLine + 1) & ", Col " & str(cursorCol + 1) & " | Total: " & str(lineCount) & " lines" & modStr & scrollInfo
drawLabel(0, 7, statusY + 1, posInfo, getStyle("info"))

# Status line 2: Current message
drawLabel(0, 7, statusY + 2, statusMessage, getStyle("default"))

# Status line 3: Mouse/drag state
let dragInfo = "Mouse: (" & str(mouseX) & "," & str(mouseY) & ") | Pressed: " & str(mousePressed) & " | DragStart: (" & str(dragStartX) & "," & str(dragStartY) & ") | Dragging: " & str(isDraggingText)
drawLabel(0, 7, statusY + 3, dragInfo, getStyle("warning"))

# Check for async paste completion
if pasteInProgress:
  let pastedText = pasteFromClipboard()
  if pastedText != "" and pastedText != lastPasteCheck:
    # Parse lines - handle \r\n, \n, \r, and literal \n
    # Process the text directly without byte-by-byte iteration to preserve Unicode
    var lines: seq[string] = @[]
    var currentLine = ""
    var i = 0
    var lineCount = 0
    
    # Split by different newline types while preserving unicode characters
    # Instead of iterating byte-by-byte, we build the string until we hit newlines
    while i < len(pastedText):
      # Check for literal backslash-n (escaped newline as text)
      if i + 1 < len(pastedText) and pastedText[i] == '\\' and pastedText[i + 1] == 'n':
        add(lines, currentLine)
        lineCount = lineCount + 1
        currentLine = ""
        i = i + 2  # Skip both \ and n
        continue
      
      let code = ord(pastedText[i])
      
      # Check for actual newlines
      if code == 13:  # \r
        add(lines, currentLine)
        lineCount = lineCount + 1
        currentLine = ""
        # Check for \r\n combo and skip both
        if i + 1 < len(pastedText) and ord(pastedText[i + 1]) == 10:
          i = i + 2
        else:
          i = i + 1
        continue
      elif code == 10:  # \n
        add(lines, currentLine)
        lineCount = lineCount + 1
        currentLine = ""
        i = i + 1
        continue
      else:
        # Add the character directly without converting - preserves Unicode
        currentLine = currentLine & pastedText[i..<i+1]
      i = i + 1
    
    # Add the last line
    if currentLine != "" or len(lines) > 0:
      add(lines, currentLine)
    
    # Insert lines
    for j in 0..<len(lines):
      let line = lines[j]
      # Insert the line text (even if empty)
      editorInsertText(editor, line)
      # Insert newline between lines (but not after the last one)
      if j < len(lines) - 1:
        editorInsertNewline(editor)
    
    statusMessage = "‚úì Pasted " & str(len(lines)) & " lines"
    isSaved = 0
    pasteInProgress = 0
    lastPasteCheck = ""

# ===================================================================
# Layer 1 - Menus and Dialogs (drawn on top of editor)
# ===================================================================
# Clear layer 1 with transparency so editor shows through
clear(1, true)

# Menu bar on layer 1
let menuY = 1
let menuStyle = getStyle("default")
let menuActiveStyle = getStyle("info")
let menuHoverStyle = getStyle("warning")
let fileMenuX = 4
let editMenuX = fileMenuX + 8
let viewMenuX = editMenuX + 8
let helpMenuX = viewMenuX + 8

drawLabel(1, fileMenuX, menuY, "File", if activeMenu == "file": menuActiveStyle else: menuStyle)
drawLabel(1, editMenuX, menuY, "Edit", if activeMenu == "edit": menuActiveStyle else: menuStyle)
drawLabel(1, viewMenuX, menuY, "View", if activeMenu == "view": menuActiveStyle else: menuStyle)
drawLabel(1, helpMenuX, menuY, "Help", if activeMenu == "help": menuActiveStyle else: menuStyle)

# Menu dropdowns on layer 1
if activeMenu == "file":
  let menuW = 30
  let menuH = 10
  let menuDropX = fileMenuX
  let menuDropY = menuY + 1
  drawPanel(1, menuDropX, menuDropY, menuW, menuH, "", "single")
  
  # Menu items (track bounds for click detection)
  # Item 0: Save
  drawLabel(1, menuDropX + 2, menuDropY + 1, "Save (Ctrl+S)", if hoveredMenuItem == 0: menuHoverStyle else: getStyle("default"))
  # Item 1: Open
  drawLabel(1, menuDropX + 2, menuDropY + 2, "Open (Ctrl+O)", if hoveredMenuItem == 1: menuHoverStyle else: getStyle("default"))
  # Separator
  drawLabel(1, menuDropX + 2, menuDropY + 3, "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", getStyle("comment"))
  # Item 2: Share URL
  drawLabel(1, menuDropX + 2, menuDropY + 4, "Share URL (Ctrl+E)", if hoveredMenuItem == 2: menuHoverStyle else: getStyle("default"))
  # Separator
  drawLabel(1, menuDropX + 2, menuDropY + 5, "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", getStyle("comment"))
  # Item 3: Load Gist
  drawLabel(1, menuDropX + 2, menuDropY + 6, "Load Gist (Ctrl+G)", if hoveredMenuItem == 3: menuHoverStyle else: getStyle("default"))
  # Item 4: Save as Gist
  drawLabel(1, menuDropX + 2, menuDropY + 7, "Save as Gist", if hoveredMenuItem == 4: menuHoverStyle else: getStyle("default"))
  
elif activeMenu == "view":
  let menuW = 25
  let menuH = 4
  let menuDropX = viewMenuX
  let menuDropY = menuY + 1
  drawPanel(1, menuDropX, menuDropY, menuW, menuH, "", "single")
  # Item 0: Toggle Help
  drawLabel(1, menuDropX + 2, menuDropY + 1, "Toggle Help (F1)", if hoveredMenuItem == 0: menuHoverStyle else: getStyle("default"))
  
elif activeMenu == "help":
  let menuW = 25
  let menuH = 4
  let menuDropX = helpMenuX
  let menuDropY = menuY + 1
  drawPanel(1, menuDropX, menuDropY, menuW, menuH, "", "single")
  # Item 0: Shortcuts
  drawLabel(1, menuDropX + 2, menuDropY + 1, "Shortcuts (F1)", if hoveredMenuItem == 0: menuHoverStyle else: getStyle("default"))

# ===================================================================
# Dialogs on layer 1 (on top of everything)
# ===================================================================

# Save Dialog
if showSaveDialog:
  let dialogW = 60
  let dialogH = 10
  let dialogX = (w - dialogW) div 2
  let dialogY = (h - dialogH) div 2
  
  drawPanel(1, dialogX, dialogY, dialogW, dialogH, "üíæ Save to Browser", "double")
  drawLabel(1, dialogX + 2, dialogY + 2, "Enter filename (without extension):", getStyle("info"))
  drawLabel(1, dialogX + 2, dialogY + 4, " > " & saveFileName & "_", getStyle("default"))
  drawLabel(1, dialogX + 2, dialogY + 6, "Press Enter to save, Esc to cancel", getStyle("comment"))
  drawLabel(1, dialogX + 2, dialogY + 7, "Saved to localStorage in your browser", getStyle("comment"))

# Load Dialog  
if showLoadDialog:
  let dialogW = 70
  let dialogH = min(20, h - 10)
  let dialogX = (w - dialogW) div 2
  let dialogY = (h - dialogH) div 2
  
  drawPanel(1, dialogX, dialogY, dialogW, dialogH, "üìÇ Load from Browser", "double")
  drawLabel(1, dialogX + 2, dialogY + 2, "Saved documents in localStorage:", getStyle("info"))
  
  if len(savedFiles) == 0:
    drawLabel(1, dialogX + 2, dialogY + 4, "(No saved documents found)", getStyle("comment"))
    drawLabel(1, dialogX + 2, dialogY + 6, "Save a document first with Ctrl+S", getStyle("comment"))
  else:
    var yPos = dialogY + 4
    var idx = 0
    while idx < len(savedFiles) and yPos < dialogY + dialogH - 3:
      let fileEntry = savedFiles[idx]
      let prefix = if idx == loadSelection: "> " else: "  "
      let style = if idx == loadSelection: getStyle("info") else: getStyle("default")
      drawLabel(1, dialogX + 4, yPos, prefix & str(idx + 1) & ". " & fileEntry, style)
      yPos = yPos + 1
      idx = idx + 1
  
  drawLabel(1, dialogX + 2, dialogY + dialogH - 2, "Arrow keys + Enter to load, Esc to cancel", getStyle("comment"))

# Share Dialog
if showShareDialog:
  # Check if URL generation is complete (only checks a boolean flag - efficient!)
  if shareUrlReady == 0:
    let readyStr = checkShareUrlReady()
    if readyStr == "true":
      shareUrlReady = 1
      shareUrl = getShareUrl()
      let copiedStr = checkShareUrlCopied()
      if copiedStr == "true":
        statusMessage = "‚úì Share URL copied to clipboard!"
      else:
        statusMessage = "Share URL generated (clipboard failed)"
  
  let dialogW = min(80, w - 10)
  let dialogH = 14
  let dialogX = (w - dialogW) div 2
  let dialogY = (h - dialogH) div 2
  
  drawPanel(1, dialogX, dialogY, dialogW, dialogH, "üîó Share via URL", "double")
  drawLabel(1, dialogX + 2, dialogY + 2, "Shareable URL generated:", getStyle("info"))
  
  if shareUrlReady:
    drawLabel(1, dialogX + 2, dialogY + 4, "Copy this URL to share:", getStyle("comment"))
    let urlMaxLen = dialogW - 6
    var urlLine = shareUrl
    var urlY = dialogY + 5
    while len(urlLine) > 0 and urlY < dialogY + dialogH - 3:
      let chunk = if len(urlLine) > urlMaxLen: urlLine[0..<urlMaxLen] else: urlLine
      drawLabel(1, dialogX + 3, urlY, chunk, getStyle("default"))
      urlLine = if len(urlLine) > urlMaxLen: urlLine[urlMaxLen..<len(urlLine)] else: ""
      urlY = urlY + 1
    
    drawLabel(1, dialogX + 2, dialogY + dialogH - 3, "‚úì URL copied to clipboard!", getStyle("success"))
  else:
    drawLabel(1, dialogX + 2, dialogY + 4, "Generating...", getStyle("comment"))
  
  drawLabel(1, dialogX + 2, dialogY + dialogH - 2, "Press Esc to close", getStyle("comment"))

# Load from Gist Dialog
if showLoadGistDialog:
  let dialogW = 70
  let dialogH = 12
  let dialogX = (w - dialogW) div 2
  let dialogY = (h - dialogH) div 2
  
  drawPanel(1, dialogX, dialogY, dialogW, dialogH, "üì• Load from GitHub Gist", "double")
  drawLabel(1, dialogX + 2, dialogY + 2, "Enter Gist ID or URL:", getStyle("info"))
  drawLabel(1, dialogX + 2, dialogY + 4, " > " & gistIdInput & "_", getStyle("default"))
  drawLabel(1, dialogX + 2, dialogY + 6, "Examples:", getStyle("comment"))
  drawLabel(1, dialogX + 4, dialogY + 7, "abc123def456", getStyle("comment"))
  drawLabel(1, dialogX + 4, dialogY + 8, "https://gist.github.com/user/abc123def456", getStyle("comment"))
  drawLabel(1, dialogX + 2, dialogY + 10, "Press Enter to load, Esc to cancel", getStyle("comment"))

# Save to Gist Dialog
if showSaveGistDialog:
  let dialogW = 70
  let dialogH = 14
  let dialogX = (w - dialogW) div 2
  let dialogY = (h - dialogH) div 2
  
  drawPanel(1, dialogX, dialogY, dialogW, dialogH, "üì§ Save as GitHub Gist", "double")
  
  if gistResultUrl == "":
    drawLabel(1, dialogX + 2, dialogY + 2, "Description (optional):", getStyle("info"))
    drawLabel(1, dialogX + 2, dialogY + 4, " > " & gistDescription & "_", getStyle("default"))
    drawLabel(1, dialogX + 2, dialogY + 6, "Filename: " & currentFileName & ".md", getStyle("comment"))
    drawLabel(1, dialogX + 2, dialogY + 8, "This will create a public gist", getStyle("comment"))
    drawLabel(1, dialogX + 2, dialogY + 9, "(No API key required)", getStyle("comment"))
    drawLabel(1, dialogX + 2, dialogY + 11, "Press Enter to create, Esc to cancel", getStyle("comment"))
  else:
    drawLabel(1, dialogX + 2, dialogY + 2, "‚úì Gist created successfully!", getStyle("success"))
    drawLabel(1, dialogX + 2, dialogY + 4, "URL:", getStyle("info"))
    drawLabel(1, dialogX + 4, dialogY + 5, gistResultUrl, getStyle("default"))
    drawLabel(1, dialogX + 2, dialogY + 7, "Press Esc to close", getStyle("comment"))

# Help panel (toggle with F1) on layer 1
if showHelp:
  let helpX = w div 2 - 35
  let helpY = h div 2 - 12
  drawPanel(1, helpX, helpY, 70, 24, "‚å® Keyboard Shortcuts", "double")
  
  drawLabel(1, helpX + 2, helpY + 2, "File Operations:", getStyle("info"))
  drawLabel(1, helpX + 4, helpY + 3, "Ctrl+S - Save to browser storage", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 4, "Ctrl+O - Open from browser storage", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 5, "Ctrl+E - Share via compressed URL", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 6, "Ctrl+G - Load from GitHub Gist", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 7, "Ctrl+Shift+S - Save as GitHub Gist", getStyle("default"))
  
  drawLabel(1, helpX + 2, helpY + 9, "Navigation:", getStyle("info"))
  drawLabel(1, helpX + 4, helpY + 10, "Arrow Keys - Move cursor", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 11, "Ctrl+Left/Right - Move by word", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 12, "Home/End - Start/end of line", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 13, "Ctrl+Home/End - Start/end of file", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 14, "Page Up/Down - Scroll page", getStyle("default"))
  
  drawLabel(1, helpX + 2, helpY + 16, "Selection:", getStyle("info"))
  drawLabel(1, helpX + 4, helpY + 17, "Shift+Arrows - Select text", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 18, "Ctrl+Shift+Left/Right - Select by word", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 19, "Ctrl+A - Select all text", getStyle("default"))
  
  drawLabel(1, helpX + 2, helpY + 21, "Editing:", getStyle("info"))
  drawLabel(1, helpX + 4, helpY + 22, "Type - Insert text", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 23, "Backspace - Delete before cursor", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 24, "Delete - Delete at/selection", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 25, "Enter - New line", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 26, "Tab - Insert spaces", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 27, "Ctrl+C - Copy selection/document", getStyle("default"))
  drawLabel(1, helpX + 4, helpY + 28, "Ctrl+V - Paste from clipboard", getStyle("default"))
  
  drawLabel(1, helpX + 20, helpY + 30, "Press F1 or Esc to close help", getStyle("warning"))
```

```nim on:input
# ===================================================================
# Input Handling
# ===================================================================
if event.type == "key":
  let keyCode = event.keyCode
  let key = event.key
  let ctrl = if contains(event.mods, "ctrl"): 1 else: 0
  let shift = if contains(event.mods, "shift"): 1 else: 0
  lastKeyCode = keyCode
  
  # ===== Dialog Input Handling (dialogs have priority) =====
  
  # Save dialog
  if showSaveDialog:
    if keyCode == KEY_ESCAPE:  # Esc
      showSaveDialog = 0
      saveFileName = ""
      focusedComponent = 0
      statusMessage = "Save cancelled"
      return true
    elif keyCode == KEY_RETURN:  # Enter
      if saveFileName != "":
        let content = editorGetText(editor)
        let success = localStorage_setItem(saveFileName, content)
        if success:
          currentFileName = saveFileName
          isSaved = 1
          editorClearModified(editor)
          statusMessage = "‚úì Saved as '" & saveFileName & "' to browser storage"
          refreshFileList()
          # Clear auto-save since user explicitly saved
          discard localStorage_delete("__autosave__")
          lastAutoSaveContent = content
        else:
          statusMessage = "‚úó Failed to save to browser storage"
        showSaveDialog = 0
        saveFileName = ""
        return true
    elif keyCode == KEY_BACKSPACE:  # Backspace
      if len(saveFileName) > 0:
        saveFileName = saveFileName[0..<len(saveFileName) - 1]
      return true
    return true
  
  # Load dialog
  if showLoadDialog:
    if keyCode == KEY_ESCAPE:  # Esc
      showLoadDialog = 0
      loadSelection = 0
      focusedComponent = 0
      statusMessage = "Load cancelled"
      return true
    elif keyCode == KEY_UP:  # Up arrow
      if loadSelection > 0:
        loadSelection = loadSelection - 1
      return true
    elif keyCode == KEY_DOWN:  # Down arrow
      if loadSelection < len(savedFiles) - 1:
        loadSelection = loadSelection + 1
      return true
    elif keyCode == KEY_RETURN:  # Enter
      if loadSelection >= 0 and loadSelection < len(savedFiles):
        let filename = savedFiles[loadSelection]
        statusMessage = "Loading '" & filename & "'..."
        showLoadDialog = 0
        loadSelection = 0
        let loadUrl = "?load=browser:" & filename
        navigateTo(loadUrl)
        return true
    return true
  
  # Share dialog
  if showShareDialog:
    if keyCode == KEY_ESCAPE:  # Esc
      showShareDialog = 0
      shareUrl = ""
      shareUrlReady = 0
      focusedComponent = 0
      statusMessage = "Share dialog closed"
      return true
    return true
  
  # Load from Gist dialog
  if showLoadGistDialog:
    if keyCode == KEY_ESCAPE:  # Esc
      showLoadGistDialog = 0
      gistIdInput = ""
      focusedComponent = 0
      statusMessage = "Load from Gist cancelled"
      return true
    elif keyCode == KEY_RETURN:  # Enter
      if gistIdInput != "":
        # Extract gist ID from URL if needed
        var gistId = gistIdInput
        # Check if it's a URL by looking for "gist.github.com"
        var isUrl = 0
        var checkPos = 0
        let pattern = "gist.github.com"
        while checkPos <= len(gistId) - len(pattern):
          var matches = 1
          var j = 0
          while j < len(pattern):
            if gistId[checkPos + j] != pattern[j]:
              matches = 0
              break
            j = j + 1
          if matches:
            isUrl = 1
            break
          checkPos = checkPos + 1
        
        if isUrl:
          # Extract ID from URL (last part after /)
          var parts: seq[string] = @[]
          var current = ""
          var i = 0
          while i < len(gistId):
            if gistId[i] == '/':
              if current != "":
                parts = parts & @[current]
              current = ""
            else:
              current = current & $gistId[i]
            i = i + 1
          if current != "":
            parts = parts & @[current]
          if len(parts) > 0:
            gistId = parts[len(parts) - 1]
        
        statusMessage = "Loading gist " & gistId & "..."
        showLoadGistDialog = 0
        gistIdInput = ""
        let loadUrl = "?load=gist:" & gistId
        navigateTo(loadUrl)
        return true
    elif keyCode == KEY_BACKSPACE:  # Backspace
      if len(gistIdInput) > 0:
        gistIdInput = gistIdInput[0..<len(gistIdInput) - 1]
      return true
    return true
  
  # Save to Gist dialog
  if showSaveGistDialog:
    if keyCode == KEY_ESCAPE:  # Esc
      showSaveGistDialog = 0
      gistDescription = ""
      gistResultUrl = ""
      focusedComponent = 0
      statusMessage = "Save to Gist cancelled"
      return true
    elif keyCode == KEY_RETURN and gistResultUrl == "":  # Enter (only if not showing result)
      let content = editorGetText(editor)
      let filename = currentFileName & ".md"
      let desc = if gistDescription == "": "TStorie document: " & currentFileName else: gistDescription
      
      # Create gist using gist API
      let result = gist_create(desc, filename, content)
      if result != "":
        gistResultUrl = result
        statusMessage = "‚úì Gist created successfully!"
        let copied = copyToClipboard(gistResultUrl)
      else:
        statusMessage = "‚úó Failed to create gist"
        showSaveGistDialog = 0
        gistDescription = ""
      return true
    elif keyCode == KEY_BACKSPACE and gistResultUrl == "":  # Backspace (only for description input)
      if len(gistDescription) > 0:
        gistDescription = gistDescription[0..<len(gistDescription) - 1]
      return true
    return true
  
  # Help dialog
  if showHelp:
    if keyCode == KEY_F1 or keyCode == KEY_ESCAPE:  # F1 or Esc
      showHelp = 0
      focusedComponent = 0
      statusMessage = "Help closed"
      return true
    return true
  
  # Menu navigation
  if activeMenu != "":
    if keyCode == KEY_ESCAPE:  # Esc
      activeMenu = ""
      hoveredMenuItem = -1
      focusedComponent = 0
      statusMessage = "Menu closed"
      return true
    elif keyCode == KEY_UP:  # Up arrow
      if hoveredMenuItem > 0:
        hoveredMenuItem = hoveredMenuItem - 1
        # Skip separators
        if activeMenu == "file" and (hoveredMenuItem == 3 or hoveredMenuItem == 5):
          hoveredMenuItem = hoveredMenuItem - 1
      return true
    elif keyCode == KEY_DOWN:  # Down arrow
      var maxItem = 0
      if activeMenu == "file":
        maxItem = 4
      elif activeMenu == "view":
        maxItem = 0
      else:
        maxItem = 0
      if hoveredMenuItem < maxItem:
        hoveredMenuItem = hoveredMenuItem + 1
        # Skip separators
        if activeMenu == "file" and (hoveredMenuItem == 3 or hoveredMenuItem == 5):
          hoveredMenuItem = hoveredMenuItem + 1
      return true
    elif keyCode == KEY_RETURN:  # Enter - activate menu item
      if hoveredMenuItem >= 0:
        # Execute menu action
        if activeMenu == "file":
          if hoveredMenuItem == 0:  # Save
            showSaveDialog = 1
            focusedComponent = 2
            saveFileName = if currentFileName == "untitled": "" else: currentFileName
            statusMessage = "Enter filename to save"
          elif hoveredMenuItem == 1:  # Open
            refreshFileList()
            showLoadDialog = 1
            focusedComponent = 2
            loadSelection = 0
            statusMessage = "Select file to load"
          elif hoveredMenuItem == 2:  # Share
            showShareDialog = 1
            focusedComponent = 2
            let content = editorGetText(editor)
            shareUrl = compressToUrl(content)
            let copied = copyToClipboard(shareUrl)
            if copied:
              statusMessage = "‚úì Share URL copied to clipboard!"
            else:
              statusMessage = "Share URL generated"
          elif hoveredMenuItem == 3:  # Load Gist
            showLoadGistDialog = 1
            focusedComponent = 2
            gistIdInput = ""
            statusMessage = "Enter Gist ID or URL"
          elif hoveredMenuItem == 4:  # Save as Gist
            showSaveGistDialog = 1
            focusedComponent = 2
            gistDescription = ""
            gistResultUrl = ""
            statusMessage = "Enter description for Gist"
        elif activeMenu == "view":
          if hoveredMenuItem == 0:  # Toggle Help
            showHelp = 1 - showHelp
            focusedComponent = if showHelp: 2 else: 0
            statusMessage = if showHelp != 0: "Help opened" else: "Help closed"
        elif activeMenu == "help":
          if hoveredMenuItem == 0:  # Shortcuts
            showHelp = 1
            focusedComponent = 2
            statusMessage = "Help opened"
        
        activeMenu = ""
        hoveredMenuItem = -1
        return true
    return true
  
  # ===== Global Shortcuts (only if no menu/dialog active) =====
  
  if focusedComponent == 0:
    # Debug: Log all key events when Ctrl is pressed
    if ctrl:
      statusMessage = "Ctrl key pressed: keyCode=" & str(keyCode) & " key=" & key
    
    if ctrl:
      # Ctrl+S - Save
      if (keyCode == KEY_S or keyCode == 83) and not shift:
        showSaveDialog = 1
        focusedComponent = 2
        saveFileName = if currentFileName == "untitled": "" else: currentFileName
        statusMessage = "Enter filename to save"
        return true
      
      # Ctrl+Shift+S - Save to Gist
      elif (keyCode == KEY_S or keyCode == 83) and shift:
        showSaveGistDialog = 1
        focusedComponent = 2
        gistDescription = ""
        gistResultUrl = ""
        statusMessage = "Enter description for Gist"
        return true
      
      # Ctrl+O - Open
      elif keyCode == KEY_O or keyCode == 79:
        refreshFileList()
        showLoadDialog = 1
        focusedComponent = 2
        loadSelection = 0
        statusMessage = "Select file to load"
        return true
      
      # Ctrl+E - Share
      elif keyCode == KEY_E or keyCode == 69:
        showShareDialog = 1
        focusedComponent = 2
        shareUrl = ""
        shareUrlReady = 0
        # Trigger async generation (happens in JS, we just poll for completion)
        let content = editorGetText(editor)
        generateAndCopyShareUrl(content)
        statusMessage = "Generating shareable URL..."
        return true
      
      # Ctrl+G - Load from Gist
      elif keyCode == KEY_G or keyCode == 71:
        showLoadGistDialog = 1
        focusedComponent = 2
        gistIdInput = ""
        statusMessage = "Enter Gist ID or URL"
        return true
      
      # Ctrl+A - Select all (check multiple keyCodes for browser/terminal compatibility)
      # Browser sends keyCode 65 (uppercase A)
      # Terminal sends keyCode 97 (lowercase a) after our conversion
      elif keyCode == KEY_A or keyCode == 65 or keyCode == 97:
        hasSelection = 1
        selStartLine = 0
        selStartCol = 0
        selEndLine = editorLineCount(editor) - 1
        let lastLine = editorGetLine(editor, selEndLine)
        selEndCol = len(lastLine)
        statusMessage = "All text selected (keyCode:" & str(keyCode) & ")"
        return true
      
      # Ctrl+C - Copy selection or all content to clipboard
      elif keyCode == KEY_C or keyCode == 67:
        let content = if hasSelection: getSelectedText() else: editorGetText(editor)
        let copied = copyToClipboard(content)
        if copied:
          statusMessage = "‚úì Copied entire document to clipboard"
        else:
          statusMessage = "Failed to copy to clipboard"
        return true
      
      # Ctrl+V - Paste from clipboard
      elif keyCode == KEY_V or keyCode == 86:
        # Trigger async clipboard read
        let triggerPaste = pasteFromClipboard()
        pasteInProgress = 1
        lastPasteCheck = ""
        statusMessage = "Reading clipboard..."
        return true
    
    # F1 - Toggle help
    if keyCode == KEY_F1:
      showHelp = 1 - showHelp
      focusedComponent = if showHelp: 2 else: 0
      statusMessage = if showHelp != 0: "Help panel opened" else: "Help panel closed"
      return true
    
    if keyCode == KEY_BACKQUOTE:
      # Trigger async clipboard read
      let triggerPaste = pasteFromClipboard()
      pasteInProgress = 1
      lastPasteCheck = ""
      statusMessage = "Reading clipboard..."
      return true
  
  # ===== Special Keys =====
  
  # Delete or Backspace - delete selection if any, otherwise pass to editor
  # Browser: BACKSPACE=8, DELETE=46
  # Terminal: BACKSPACE=8, DELETE=127
  if keyCode == KEY_DELETE or keyCode == KEY_BACKSPACE or keyCode == 46 or keyCode == 8:
    if hasSelection:
      deleteSelection()
      statusMessage = "Deleted selection"
      return true
    # If no selection, let it fall through to editor handler
  
  # ===== Arrow Keys and Word Movement =====
  
  # Editor only responds when it has focus
  if focusedComponent != 0:
    return false
  
  # Handle arrow keys with shift (selection) and ctrl (word movement)
  # Arrow keys: KEY_UP=1000, KEY_DOWN=1001, KEY_LEFT=1002, KEY_RIGHT=1003
  if keyCode == KEY_UP or keyCode == KEY_DOWN or keyCode == KEY_LEFT or keyCode == KEY_RIGHT:
    let cursor = editorGetCursor(editor)
    let cursorLine = cursor["line"]
    let cursorCol = cursor["col"]
    
    # Check if there's a mouse selection we should continue
    let mouseSelection = editorGetSelectionInfo(editor)
    if shift and not hasSelection and mouseSelection["active"]:
      # Convert mouse selection to keyboard selection so we can extend it
      hasSelection = 1
      selStartLine = mouseSelection["startLine"]
      selStartCol = mouseSelection["startCol"]
      selEndLine = mouseSelection["endLine"]
      selEndCol = mouseSelection["endCol"]
    
    # Start selection if shift is pressed and no selection exists
    if shift and not hasSelection:
      hasSelection = 1
      selStartLine = cursorLine
      selStartCol = cursorCol
      selEndLine = cursorLine
      selEndCol = cursorCol
    
    # Move cursor
    var newLine = cursorLine
    var newCol = cursorCol
    
    if keyCode == KEY_LEFT:  # Left
      if ctrl:
        # Ctrl+Left: Move to previous word
        let line = editorGetLine(editor, cursorLine)
        newCol = findPrevWord(line, cursorCol)
      else:
        # Regular left
        if cursorCol > 0:
          newCol = cursorCol - 1
        elif cursorLine > 0:
          newLine = cursorLine - 1
          let prevLine = editorGetLine(editor, newLine)
          newCol = len(prevLine)
    elif keyCode == KEY_RIGHT:  # Right
      if ctrl:
        # Ctrl+Right: Move to next word
        let line = editorGetLine(editor, cursorLine)
        newCol = findNextWord(line, cursorCol)
      else:
        # Regular right
        let line = editorGetLine(editor, cursorLine)
        if cursorCol < len(line):
          newCol = cursorCol + 1
        elif cursorLine < editorLineCount(editor) - 1:
          newLine = cursorLine + 1
          newCol = 0
    elif keyCode == KEY_UP:  # Up
      if cursorLine > 0:
        newLine = cursorLine - 1
        let upLine = editorGetLine(editor, newLine)
        newCol = min(cursorCol, len(upLine))
    elif keyCode == KEY_DOWN:  # Down
      if cursorLine < editorLineCount(editor) - 1:
        newLine = cursorLine + 1
        let downLine = editorGetLine(editor, newLine)
        newCol = min(cursorCol, len(downLine))
    
    # Apply movement
    editorSetCursor(editor, newLine, newCol)
    
    # Update selection if shift is pressed
    if shift:
      selEndLine = newLine
      selEndCol = newCol
      statusMessage = "Selection: " & str(selStartLine) & ":" & str(selStartCol) & " to " & str(selEndLine) & ":" & str(selEndCol)
    else:
      # Clear selection if not holding shift
      clearSelection()
      statusMessage = "Moved to line " & str(newLine + 1) & ", col " & str(newCol + 1)
    
    return true
  
  # ===== Home, End, Page Up, Page Down =====
  
  # Home key - Move to start of line or file
  if keyCode == KEY_HOME:
    let cursor = editorGetCursor(editor)
    let cursorLine = cursor["line"]
    let cursorCol = cursor["col"]
    
    # Check if there's a mouse selection we should continue
    let mouseSelection = editorGetSelectionInfo(editor)
    if shift and not hasSelection and mouseSelection["active"]:
      hasSelection = 1
      selStartLine = mouseSelection["startLine"]
      selStartCol = mouseSelection["startCol"]
      selEndLine = mouseSelection["endLine"]
      selEndCol = mouseSelection["endCol"]
    
    # Start selection if shift is pressed and no selection exists
    if shift and not hasSelection:
      hasSelection = 1
      selStartLine = cursorLine
      selStartCol = cursorCol
      selEndLine = cursorLine
      selEndCol = cursorCol
    
    var newLine = cursorLine
    var newCol = 0
    
    if ctrl:
      # Ctrl+Home: Move to start of file
      newLine = 0
      newCol = 0
    else:
      # Home: Move to start of line
      newCol = 0
    
    editorSetCursor(editor, newLine, newCol)
    
    # Update selection if shift is pressed
    if shift:
      selEndLine = newLine
      selEndCol = newCol
      statusMessage = "Selection to line start"
    else:
      clearSelection()
      statusMessage = if ctrl: "Moved to start of file" else: "Moved to line start"
    
    return true
  
  # End key - Move to end of line or file
  if keyCode == KEY_END:
    let cursor = editorGetCursor(editor)
    let cursorLine = cursor["line"]
    let cursorCol = cursor["col"]
    
    # Check if there's a mouse selection we should continue
    let mouseSelection = editorGetSelectionInfo(editor)
    if shift and not hasSelection and mouseSelection["active"]:
      hasSelection = 1
      selStartLine = mouseSelection["startLine"]
      selStartCol = mouseSelection["startCol"]
      selEndLine = mouseSelection["endLine"]
      selEndCol = mouseSelection["endCol"]
    
    # Start selection if shift is pressed and no selection exists
    if shift and not hasSelection:
      hasSelection = 1
      selStartLine = cursorLine
      selStartCol = cursorCol
      selEndLine = cursorLine
      selEndCol = cursorCol
    
    var newLine = cursorLine
    var newCol = 0
    
    if ctrl:
      # Ctrl+End: Move to end of file
      newLine = editorLineCount(editor) - 1
      let lastLine = editorGetLine(editor, newLine)
      newCol = len(lastLine)
    else:
      # End: Move to end of line
      let line = editorGetLine(editor, cursorLine)
      newCol = len(line)
    
    editorSetCursor(editor, newLine, newCol)
    
    # Update selection if shift is pressed
    if shift:
      selEndLine = newLine
      selEndCol = newCol
      statusMessage = "Selection to line end"
    else:
      clearSelection()
      statusMessage = if ctrl: "Moved to end of file" else: "Moved to line end"
    
    return true
  
  # Page Up key - Scroll up one page
  if keyCode == KEY_PAGEUP:
    let cursor = editorGetCursor(editor)
    let cursorLine = cursor["line"]
    let cursorCol = cursor["col"]
    
    # Check if there's a mouse selection we should continue
    let mouseSelection = editorGetSelectionInfo(editor)
    if shift and not hasSelection and mouseSelection["active"]:
      hasSelection = 1
      selStartLine = mouseSelection["startLine"]
      selStartCol = mouseSelection["startCol"]
      selEndLine = mouseSelection["endLine"]
      selEndCol = mouseSelection["endCol"]
    
    # Start selection if shift is pressed and no selection exists
    if shift and not hasSelection:
      hasSelection = 1
      selStartLine = cursorLine
      selStartCol = cursorCol
      selEndLine = cursorLine
      selEndCol = cursorCol
    
    # Calculate page size (editor height minus some for scrolling context)
    let pageSize = max(10, termHeight - 9)
    var newLine = max(0, cursorLine - pageSize)
    let targetLine = editorGetLine(editor, newLine)
    let newCol = min(cursorCol, len(targetLine))
    
    editorSetCursor(editor, newLine, newCol)
    
    # Update selection if shift is pressed
    if shift:
      selEndLine = newLine
      selEndCol = newCol
      statusMessage = "Selection page up"
    else:
      clearSelection()
      statusMessage = "Scrolled up one page"
    
    return true
  
  # Page Down key - Scroll down one page
  if keyCode == KEY_PAGEDOWN:
    let cursor = editorGetCursor(editor)
    let cursorLine = cursor["line"]
    let cursorCol = cursor["col"]
    
    # Check if there's a mouse selection we should continue
    let mouseSelection = editorGetSelectionInfo(editor)
    if shift and not hasSelection and mouseSelection["active"]:
      hasSelection = 1
      selStartLine = mouseSelection["startLine"]
      selStartCol = mouseSelection["startCol"]
      selEndLine = mouseSelection["endLine"]
      selEndCol = mouseSelection["endCol"]
    
    # Start selection if shift is pressed and no selection exists
    if shift and not hasSelection:
      hasSelection = 1
      selStartLine = cursorLine
      selStartCol = cursorCol
      selEndLine = cursorLine
      selEndCol = cursorCol
    
    # Calculate page size (editor height minus some for scrolling context)
    let pageSize = max(10, termHeight - 9)
    let maxLine = editorLineCount(editor) - 1
    var newLine = min(maxLine, cursorLine + pageSize)
    let targetLine = editorGetLine(editor, newLine)
    let newCol = min(cursorCol, len(targetLine))
    
    editorSetCursor(editor, newLine, newCol)
    
    # Update selection if shift is pressed
    if shift:
      selEndLine = newLine
      selEndCol = newCol
      statusMessage = "Selection page down"
    else:
      clearSelection()
      statusMessage = "Scrolled down one page"
    
    return true
  
  # ===== Editor Input (only when editor has focus) =====
  
  # Already checked focusedComponent above
  if focusedComponent != 0:
    return false
  
  # Clear selection on any typing (printable characters)
  # Exclude DELETE (46) which is a special key in browser
  if hasSelection and keyCode >= 32 and keyCode < 127 and keyCode != 46 and not ctrl:
    deleteSelection()
  
  # Skip printable characters in key events - they should be handled by text events
  # This prevents double-handling in native mode where spacebar generates both key+text
  # Exception: Allow spacebar (32), DELETE (46), and other special keys through
  if keyCode >= 33 and keyCode < 127 and keyCode != 46 and not ctrl:
    return false
  
  # Track if content modified
  let wasModified = editorIsModified(editor)
  let handled = editorHandleKey(editor, keyCode, key, event.mods)
  
  if handled:
    keyPressCount = keyPressCount + 1
    let nowModified = editorIsModified(editor)
    
    if not wasModified and nowModified:
      isSaved = 0
    
    # Clear selection after any key press
    if hasSelection:
      clearSelection()
    
    # Update status message based on action
    if keyCode == KEY_RETURN:
      statusMessage = "Inserted new line"
    elif keyCode == KEY_BACKSPACE or keyCode == KEY_DELETE:
      statusMessage = "Deleted character"
    elif keyCode == KEY_TAB:
      statusMessage = "Inserted tab (spaces)"
    elif keyCode == KEY_LEFT or keyCode == KEY_UP or keyCode == KEY_RIGHT or keyCode == KEY_DOWN:
      let cursor = editorGetCursor(editor)
      statusMessage = "Moved to line " & str(cursor["line"] + 1) & ", col " & str(cursor["col"] + 1)
    
    return true
  
  return false

# ===================================================================
# Text Input Handling
# ===================================================================
elif event.type == "text":
  # Handle text input for dialogs
  if showSaveDialog:
    # Add typed character to filename (only alphanumeric, dash, underscore)
    if len(event.text) == 1:
      let c = event.text[0]
      if (c >= 'a' and c <= 'z') or (c >= 'A' and c <= 'Z') or (c >= '0' and c <= '9') or c == '-' or c == '_':
        saveFileName = saveFileName & event.text
    return true
  
  if showLoadGistDialog:
    # Add typed character to gist ID
    gistIdInput = gistIdInput & event.text
    return true
  
  if showSaveGistDialog and gistResultUrl == "":
    # Add typed character to description
    gistDescription = gistDescription & event.text
    return true
  
  # Only process if editor has focus
  if focusedComponent != 0:
    return false
  
  if showLoadDialog or showShareDialog or showHelp or activeMenu != "":
    return false
  
  # Delete selection before inserting new text
  if hasSelection:
    deleteSelection()
  
  let wasModified = editorIsModified(editor)
  editorInsertText(editor, event.text)
  
  if not wasModified:
    isSaved = 0
  
  keyPressCount = keyPressCount + 1
  statusMessage = "Ready"
  return true

# ===================================================================
# Mouse/Scroll Input Handling
# ===================================================================
elif event.type == "mouse" or event.type == "scroll":
  let mx = event.x
  let my = event.y
  let action = event.action
  
  # Recalculate editor dimensions
  let w = termWidth
  let h = termHeight
  let editorW = w - 1
  let editorH = h - 7
  
  # Handle clicks on dialogs - close if clicking outside
  if action == "press":
    # Check save dialog
    if showSaveDialog:
      let dialogW = 60
      let dialogH = 10
      let dialogX = (w - dialogW) div 2
      let dialogY = (h - dialogH) div 2
      if not (mx >= dialogX and mx < dialogX + dialogW and my >= dialogY and my < dialogY + dialogH):
        showSaveDialog = 0
        saveFileName = ""
        focusedComponent = 0
        statusMessage = "Save cancelled"
      return true
    
    # Check load dialog
    if showLoadDialog:
      let dialogW = 70
      let dialogH = min(20, h - 10)
      let dialogX = (w - dialogW) div 2
      let dialogY = (h - dialogH) div 2
      if not (mx >= dialogX and mx < dialogX + dialogW and my >= dialogY and my < dialogY + dialogH):
        showLoadDialog = 0
        loadSelection = 0
        focusedComponent = 0
        statusMessage = "Load cancelled"
      return true
    
    # Check share dialog
    if showShareDialog:
      let dialogW = min(80, w - 10)
      let dialogH = 14
      let dialogX = (w - dialogW) div 2
      let dialogY = (h - dialogH) div 2
      if not (mx >= dialogX and mx < dialogX + dialogW and my >= dialogY and my < dialogY + dialogH):
        showShareDialog = 0
        shareUrl = ""
        shareUrlReady = 0
        focusedComponent = 0
        statusMessage = "Share dialog closed"
      return true
    
    # Check load gist dialog
    if showLoadGistDialog:
      let dialogW = 70
      let dialogH = 12
      let dialogX = (w - dialogW) div 2
      let dialogY = (h - dialogH) div 2
      if not (mx >= dialogX and mx < dialogX + dialogW and my >= dialogY and my < dialogY + dialogH):
        showLoadGistDialog = 0
        gistIdInput = ""
        focusedComponent = 0
        statusMessage = "Load from Gist cancelled"
      return true
    
    # Check save gist dialog
    if showSaveGistDialog:
      let dialogW = 70
      let dialogH = 14
      let dialogX = (w - dialogW) div 2
      let dialogY = (h - dialogH) div 2
      if not (mx >= dialogX and mx < dialogX + dialogW and my >= dialogY and my < dialogY + dialogH):
        showSaveGistDialog = 0
        gistDescription = ""
        gistResultUrl = ""
        focusedComponent = 0
        statusMessage = "Save to Gist cancelled"
      return true
    
    # Check help panel
    if showHelp:
      let helpW = 70
      let helpH = 24
      let helpX = w div 2 - 35
      let helpY = h div 2 - 12
      if not (mx >= helpX and mx < helpX + helpW and my >= helpY and my < helpY + helpH):
        showHelp = 0
        focusedComponent = 0
        statusMessage = "Help closed"
      return true
  
  # Handle menu bar clicks
  if action == "press" and my == 1:
    let fileMenuX = 4
    let editMenuX = fileMenuX + 8
    let viewMenuX = editMenuX + 8
    let helpMenuX = viewMenuX + 8
    
    if mx >= fileMenuX and mx < fileMenuX + 4:
      activeMenu = if activeMenu == "file": "" else: "file"
      focusedComponent = if activeMenu == "file": 1 else: 0
      hoveredMenuItem = if activeMenu == "file": 0 else: -1
      statusMessage = if activeMenu == "file": "File menu opened - Use arrows + Enter or click items" else: "Menu closed"
      return true
    elif mx >= editMenuX and mx < editMenuX + 4:
      activeMenu = if activeMenu == "edit": "" else: "edit"
      focusedComponent = if activeMenu == "edit": 1 else: 0
      hoveredMenuItem = -1
      statusMessage = if activeMenu == "edit": "Edit menu opened" else: "Menu closed"
      return true
    elif mx >= viewMenuX and mx < viewMenuX + 4:
      activeMenu = if activeMenu == "view": "" else: "view"
      focusedComponent = if activeMenu == "view": 1 else: 0
      hoveredMenuItem = if activeMenu == "view": 0 else: -1
      statusMessage = if activeMenu == "view": "View menu opened" else: "Menu closed"
      return true
    elif mx >= helpMenuX and mx < helpMenuX + 4:
      activeMenu = if activeMenu == "help": "" else: "help"
      focusedComponent = if activeMenu == "help": 1 else: 0
      hoveredMenuItem = if activeMenu == "help": 0 else: -1
      statusMessage = if activeMenu == "help": "Help menu opened" else: "Menu closed"
      return true
  
  # Handle menu dropdown clicks
  if action == "press" and activeMenu != "":
    let fileMenuX = 4
    let viewMenuX = fileMenuX + 24
    let helpMenuX = viewMenuX + 8
    
    if activeMenu == "file":
      let menuDropX = fileMenuX
      let menuDropY = 2
      let menuW = 30
      let menuH = 10
      
      # Check if click is inside menu
      if mx >= menuDropX and mx < menuDropX + menuW and my >= menuDropY and my < menuDropY + menuH:
        let itemY = my - menuDropY - 1
        if itemY == 0:  # Save
          showSaveDialog = 1
          focusedComponent = 2
          saveFileName = if currentFileName == "untitled": "" else: currentFileName
          statusMessage = "Enter filename to save"
          activeMenu = ""
          hoveredMenuItem = -1
          return true
        elif itemY == 1:  # Open
          refreshFileList()
          showLoadDialog = 1
          focusedComponent = 2
          loadSelection = 0
          statusMessage = "Select file to load"
          activeMenu = ""
          hoveredMenuItem = -1
          return true
        elif itemY == 3:  # Share URL
          showShareDialog = 1
          focusedComponent = 2
          shareUrl = ""
          shareUrlReady = 0
          # Trigger async generation
          let content = editorGetText(editor)
          generateAndCopyShareUrl(content)
          activeMenu = ""
          hoveredMenuItem = -1
          statusMessage = "Generating shareable URL..."
          return true
        elif itemY == 5:  # Load Gist
          showLoadGistDialog = 1
          focusedComponent = 2
          gistIdInput = ""
          statusMessage = "Enter Gist ID or URL"
          activeMenu = ""
          hoveredMenuItem = -1
          return true
        elif itemY == 6:  # Save as Gist
          showSaveGistDialog = 1
          focusedComponent = 2
          gistDescription = ""
          gistResultUrl = ""
          statusMessage = "Enter description for Gist"
          activeMenu = ""
          hoveredMenuItem = -1
          return true
      else:
        # Clicked outside menu - close it
        activeMenu = ""
        hoveredMenuItem = -1
        focusedComponent = 0
        statusMessage = "Menu closed"
    
    elif activeMenu == "view":
      let menuDropX = viewMenuX
      let menuDropY = 2
      let menuW = 25
      let menuH = 4
      
      if mx >= menuDropX and mx < menuDropX + menuW and my >= menuDropY and my < menuDropY + menuH:
        let itemY = my - menuDropY - 1
        if itemY == 0:  # Toggle Help
          showHelp = 1 - showHelp
          focusedComponent = if showHelp: 2 else: 0
          statusMessage = if showHelp != 0: "Help opened" else: "Help closed"
          activeMenu = ""
          hoveredMenuItem = -1
          return true
      else:
        # Clicked outside
        activeMenu = ""
        hoveredMenuItem = -1
        focusedComponent = 0
    
    elif activeMenu == "help":
      let menuDropX = helpMenuX
      let menuDropY = 2
      let menuW = 25
      let menuH = 4
      
      if mx >= menuDropX and mx < menuDropX + menuW and my >= menuDropY and my < menuDropY + menuH:
        let itemY = my - menuDropY - 1
        if itemY == 0:  # Shortcuts
          showHelp = 1
          focusedComponent = 2
          statusMessage = "Help opened"
          activeMenu = ""
          hoveredMenuItem = -1
          return true
      else:
        # Clicked outside
        activeMenu = ""
        hoveredMenuItem = -1
        focusedComponent = 0
  
  # Mouse wheel scrolling (scroll_up/scroll_down button events) - check FIRST before generic press
  if action == "press" and (event.button == "scroll_up" or event.button == "scroll_down"):
    if mx >= editorX and mx < editorX + editorW and my >= editorY and my < editorY + editorH:
      let cursor = editorGetCursor(editor)
      let cursorLine = cursor["line"]
      let cursorCol = cursor["col"]
      
      # Scroll up or down
      if event.button == "scroll_up":
        # Scroll up - move cursor up 3 lines
        let scrollAmount = 3
        let newLine = max(0, cursorLine - scrollAmount)
        let targetLine = editorGetLine(editor, newLine)
        let newCol = min(cursorCol, len(targetLine))
        editorSetCursor(editor, newLine, newCol)
        statusMessage = "Mouse wheel: scrolled up"
      else:
        # Scroll down - move cursor down 3 lines
        let scrollAmount = 3
        let maxLine = editorLineCount(editor) - 1
        let newLine = min(maxLine, cursorLine + scrollAmount)
        let targetLine = editorGetLine(editor, newLine)
        let newCol = min(cursorCol, len(targetLine))
        editorSetCursor(editor, newLine, newCol)
        statusMessage = "Mouse wheel: scrolled down"
      
      return true
  
  # Mouse release - end any drag operation
  if action == "release":
    if mousePressed:
      # Finalize text selection if we were dragging
      if isDraggingText:
        editorHandleMouseRelease(editor)
      
      mousePressed = 0
      isDraggingScrollbar = 0
      isDraggingMinimap = 0
      isDraggingText = 0
      statusMessage = "Ready"
      return true
  
  # Regular mouse button press (left/right/middle buttons only)
  if action == "press":
    # Click in editor area - give it focus
    if mx >= editorX and mx < editorX + editorW and my >= editorY and my < editorY + editorH:
      focusedComponent = 0
      activeMenu = ""
      hoveredMenuItem = -1
      
      # Calculate scrollbar and minimap positions
      let scrollbarX = editorX + editorW - 1
      let minimapX = editorX + editorW - 6
      
      # Check if clicking on scrollbar (rightmost column)
      if mx == scrollbarX:
        mousePressed = 1
        isDraggingScrollbar = 1
        dragStartY = my
        # Calculate position and jump there
        let relativeY = my - editorY
        let totalLines = editorLineCount(editor)
        let targetLine = (relativeY * totalLines) div editorH
        editorSetCursor(editor, min(max(0, targetLine), totalLines - 1), 0)
        statusMessage = "Scrollbar: jumped to line " & str(targetLine + 1)
        return true
      
      # Check if clicking on minimap (columns -6 to -2 from right edge)
      elif mx >= minimapX and mx < scrollbarX:
        mousePressed = 1
        isDraggingMinimap = 1
        let minimapHandled = editorHandleMinimapClick(editor, mx, my, editorX, editorY, editorW, editorH, 0)
        if minimapHandled:
          statusMessage = "Minimap: jumped to position"
        return true
      
      # Regular click in text area
      else:
        mousePressed = 1
        isDraggingText = 1
        dragStartX = mx
        dragStartY = my
        
        # Clear any existing keyboard selection when clicking (mouse takes over)
        clearSelection()
        
        # Start mouse selection (shift extends selection if held)
        let shiftHeld = 0  # TODO: track shift key state if needed
        let handled = editorHandleMousePress(editor, mx, my, editorX, editorY, editorW, editorH, 1, shiftHeld)
        if handled:
          let cursor = editorGetCursor(editor)
          statusMessage = "Press at line " & str(cursor["line"] + 1) & ", col " & str(cursor["col"] + 1) & " (selection started)"
        return true
  
  return false

# ===================================================================
# Mouse Move Events (for dragging)
# ===================================================================
elif event.type == "mouse_move":
  let mx = event.x
  let my = event.y
  
  # Calculate editor dimensions
  let w = termWidth
  let h = termHeight
  let editorW = w - 1
  let editorH = h - 7
  let editorX = 0
  let editorY = 2
  
  # Handle dragging while button is pressed
  if mousePressed and isDraggingScrollbar:
    # Allow dragging anywhere vertically within editor bounds
    if my >= editorY and my < editorY + editorH:
      # Calculate position from drag - direct mapping to total lines
      let relativeY = my - editorY
      let totalLines = editorLineCount(editor)
      let targetLine = (relativeY * totalLines) div editorH
      editorSetCursor(editor, min(max(0, targetLine), totalLines - 1), 0)
      statusMessage = "Scrollbar drag: line " & str(targetLine + 1)
      return true
  elif mousePressed and isDraggingMinimap:
    # Allow dragging anywhere vertically within editor bounds
    if my >= editorY and my < editorY + editorH:
      # Handle minimap drag
      let minimapHandled = editorHandleMinimapClick(editor, mx, my, editorX, editorY, editorW, editorH, 1)
      if minimapHandled:
        statusMessage = "Minimap drag"
        return true
  elif mousePressed and isDraggingText:
    # Handle text selection drag
    let handled = editorHandleMouseDrag(editor, mx, my, editorX, editorY, editorW, editorH, 1)
    if handled:
      let cursor = editorGetCursor(editor)
      statusMessage = "Selecting... line " & str(cursor["line"] + 1) & ", col " & str(cursor["col"] + 1)
      return true
  
  return false

return false
```

## About This Editor

A complete TStorie editor with file management, sharing, and collaboration features!

### Architecture
- **Gap Buffer**: Efficient O(1) inserts at cursor position
- **Unicode-Safe**: All operations use Runes internally
- **Stateless Rendering**: Separate state from display logic
- **Modal Dialogs**: Clean UX for file operations
- **Menu System**: Traditional menu bar with dropdowns

### Features

**üìù Text Editing**
- Full text editing with gap buffer
- Unicode support (emoji: üéâ ‚ú® üöÄ)
- Line numbers and scrollbar
- Minimap visualization
- Mouse and keyboard navigation

**üíæ File Management**
- **Save to Browser** (Ctrl+S) - Store in localStorage
- **Load from Browser** (Ctrl+O) - Browse saved files
- **Share via URL** (Ctrl+E) - Generate compressed URLs
- **Load from Gist** (Ctrl+G) - Import from GitHub
- **Save as Gist** (Ctrl+Shift+S) - Export to GitHub

**üîó Collaboration**
- Share documents via compressed URL
- Load from public GitHub Gists
- Create new Gists (no API key needed)
- URL-based content loading

### Quick Start

1. **Type** your content
2. **Save** with Ctrl+S to browser storage
3. **Share** with Ctrl+E to get a URL
4. **Load** with Ctrl+G from a Gist ID

### Keyboard Shortcuts

- **Ctrl+S** - Save to browser
- **Ctrl+O** - Open from browser
- **Ctrl+E** - Share URL
- **Ctrl+G** - Load Gist
- **Ctrl+Shift+S** - Save as Gist
- **F1** - Show help

Try it now - edit, save, and share your content!
---
title: "Timing & Events Demo"
theme: "catppuccin"
---

This example demonstrates comprehensive event handling including keyboard, mouse, and timing systems with SDL3-compatible constants.

```nim on:init
# === MOUSE STATE ===
var mouseButton = "none"
var mouseAction = "none"
var totalClicks = 0
var leftClicks = 0
var middleClicks = 0
var rightClicks = 0

# === KEYBOARD STATE ===
var lastKey = "none"
var lastKeyCode = 0
var lastKeyAction = "none"
var keyPressCount = 0
var shiftPressed = false
var ctrlPressed = false
var altPressed = false

# === ANIMATION STATE (frame-independent) ===
var clickRippleTime = 0.0
var clickRippleActive = false
var clickRippleX = 0
var clickRippleY = 0
var keyFlashPhase = 0.0
var rotationAngle = 0.0
var pulsePhase = 0.0

# === INTERACTIVE ELEMENTS ===
var boxX = 10
var boxY = 16
var boxWidth = 20
var boxHeight = 5
var boxHovered = false
var boxClicked = false
var boxClickTime = 0.0
var boxDragging = false
var boxDragOffsetX = 0
var boxDragOffsetY = 0

# === SPECIAL EVENT DETECTION ===
var shiftQDetected = false
var ctrlMouseDetected = false
var mouseWheelDir = "none"
var mouseWheelTime = 0.0

# === ARROW KEY STATE ===
var arrowUp = false
var arrowDown = false
var arrowLeft = false
var arrowRight = false
```

```nim on:input
# === MOUSE EVENTS ===
if event.type == "mouse_move":
  
  # Handle box dragging
  if boxDragging:
    boxX = mouseX - boxDragOffsetX
    boxY = mouseY - boxDragOffsetY
    # Keep box on screen
    if boxX < 0:
      boxX = 0
    if boxY < 0:
      boxY = 0
    if boxX + boxWidth >= termWidth:
      boxX = termWidth - boxWidth - 1
    if boxY + boxHeight >= termHeight:
      boxY = termHeight - boxHeight - 1
  
  # Check box hover
  boxHovered = mouseX >= boxX and mouseX < boxX + boxWidth and mouseY >= boxY and mouseY < boxY + boxHeight

if event.type == "mouse":
  mouseButton = event.button
  mouseAction = event.action
  
  if event.action == "press":
    totalClicks = totalClicks + 1
    
    # Count by button
    if event.button == "left":
      leftClicks = leftClicks + 1
      
      # Start dragging if clicking on box
      if boxHovered:
        boxDragging = true
        boxDragOffsetX = mouseX - boxX
        boxDragOffsetY = mouseY - boxY
    elif event.button == "middle":
      middleClicks = middleClicks + 1
    elif event.button == "right":
      rightClicks = rightClicks + 1
    
    # Start ripple animation
    clickRippleActive = true
    clickRippleTime = getTime()
    clickRippleX = mouseX
    clickRippleY = mouseY
    
    # Check if box was clicked
    if boxHovered:
      boxClicked = true
      boxClickTime = getTime()
    
    # SPECIAL: CTRL + Mouse click detection
    if ctrlPressed:
      ctrlMouseDetected = true
  
  elif event.action == "release":
    # Stop dragging on mouse release
    if event.button == "left":
      boxDragging = false

if event.type == "mouse" and (event.button == "scroll_up" or event.button == "scroll_down"):
  # Mouse wheel event detection
  if event.button == "scroll_up":
    mouseWheelDir = "up"
  else:
    mouseWheelDir = "down"
  mouseWheelTime = getTime()

# === KEYBOARD EVENTS ===
if event.type == "key":
  lastKeyCode = event.keyCode
  lastKeyAction = event.action
  
  # Update modifier states
  shiftPressed = false
  ctrlPressed = false
  altPressed = false
  
  var i = 0
  while i < len(event.mods):
    if event.mods[i] == "shift":
      shiftPressed = true
    elif event.mods[i] == "ctrl":
      ctrlPressed = true
    elif event.mods[i] == "alt":
      altPressed = true
    i = i + 1
  
  # Track arrow key states
  if lastKeyCode == KEY_UP:
    arrowUp = (event.action == "press" or event.action == "repeat")
  elif lastKeyCode == KEY_DOWN:
    arrowDown = (event.action == "press" or event.action == "repeat")
  elif lastKeyCode == KEY_LEFT:
    arrowLeft = (event.action == "press" or event.action == "repeat")
  elif lastKeyCode == KEY_RIGHT:
    arrowRight = (event.action == "press" or event.action == "repeat")
  
  # Clear arrow states on release
  if event.action == "release":
    if lastKeyCode == KEY_UP:
      arrowUp = false
    elif lastKeyCode == KEY_DOWN:
      arrowDown = false
    elif lastKeyCode == KEY_LEFT:
      arrowLeft = false
    elif lastKeyCode == KEY_RIGHT:
      arrowRight = false
  
  # Convert keyCode to readable name
  if lastKeyCode == KEY_ESCAPE:
    lastKey = "ESC"
  elif lastKeyCode == KEY_RETURN:
    lastKey = "ENTER"
  elif lastKeyCode == KEY_SPACE:
    lastKey = "SPACE"
  elif lastKeyCode == KEY_TAB:
    lastKey = "TAB"
  elif lastKeyCode == KEY_BACKSPACE:
    lastKey = "BACKSPACE"
  elif lastKeyCode == KEY_UP:
    lastKey = "UP"
  elif lastKeyCode == KEY_DOWN:
    lastKey = "DOWN"
  elif lastKeyCode == KEY_LEFT:
    lastKey = "LEFT"
  elif lastKeyCode == KEY_RIGHT:
    lastKey = "RIGHT"
  elif lastKeyCode >= 32 and lastKeyCode < 127:
    lastKey = "'" & str(lastKeyCode) & "'"
  else:
    lastKey = "KEY_" & str(lastKeyCode)
  
  if event.action == "press":
    keyPressCount = keyPressCount + 1
    keyFlashPhase = 0.0  # Start flash animation
    
    # SPECIAL: SHIFT + Q detection
    if event.keyCode == KEY_Q and shiftPressed:
      shiftQDetected = true
  
  # Quit on ESC (but not Q alone, since we want to detect SHIFT+Q)
  if event.keyCode == KEY_ESCAPE:
    return false
  # Quit on Q only if shift is NOT pressed
  if event.keyCode == KEY_Q and not shiftPressed:
    return false
  
  return true

elif event.type == "text":
  lastKey = "'" & event.text & "'"
  lastKeyAction = "text"
  keyPressCount = keyPressCount + 1
  return true

return true
```

```nim on:update
# Frame-independent animations
keyFlashPhase = keyFlashPhase + (deltaTime * 8.0)
rotationAngle = rotationAngle + (deltaTime * 2.0)
pulsePhase = pulsePhase + (deltaTime * 3.0)

# Decay click ripple
if clickRippleActive:
  if getTime() - clickRippleTime > 1.0:
    clickRippleActive = false

# Decay box click effect
if boxClicked:
  if getTime() - boxClickTime > 0.5:
    boxClicked = false

# Decay special event indicators
if shiftQDetected:
  if getTime() - keyFlashPhase > 2.0:
    shiftQDetected = false

if ctrlMouseDetected:
  if getTime() - clickRippleTime > 2.0:
    ctrlMouseDetected = false

if mouseWheelDir != "none":
  if getTime() - mouseWheelTime > 1.5:
    mouseWheelDir = "none"
```

```nim on:render
clear()

# === HEADER ===
draw(0, 2, 1, "=== COMPLETE EVENTS DEMO ===")
draw(0, 2, 2, "Time: " & str(int(getTimeMs())) & "ms | FPS: " & str(int(getFps())) & " | Frame: " & str(getFrameCount()))
draw(0, 2, 3, "Delta: " & str(int(getDeltaTime() * 1000000.0)) & "us")

# === MOUSE STATE ===
draw(0, 2, 5, "=== MOUSE ===")
draw(0, 2, 6, "Position: (" & str(mouseX) & ", " & str(mouseY) & ")")
draw(0, 2, 7, "Button: " & mouseButton & " | Action: " & mouseAction)
draw(0, 2, 8, "Clicks: " & str(totalClicks) & " (L:" & str(leftClicks) & " M:" & str(middleClicks) & " R:" & str(rightClicks) & ")")

# === KEYBOARD STATE ===
draw(0, 2, 10, "=== KEYBOARD ===")
draw(0, 2, 11, "Last Key: " & lastKey & " (code: " & str(lastKeyCode) & ")")
draw(0, 2, 12, "Action: " & lastKeyAction & " | Total: " & str(keyPressCount))

# Modifiers
var modStr = "Modifiers: "
if shiftPressed:
  modStr = modStr & "[SHIFT] "
if ctrlPressed:
  modStr = modStr & "[CTRL] "
if altPressed:
  modStr = modStr & "[ALT] "
if not (shiftPressed or ctrlPressed or altPressed):
  modStr = modStr & "(none)"
draw(0, 2, 13, modStr)

# === INTERACTIVE BOX ===
draw(0, boxX, boxY - 1, "+--------------------+")
var i = 0
while i < boxHeight:
  draw(0, boxX, boxY + i, "|                    |")
  i = i + 1
draw(0, boxX, boxY + boxHeight, "+--------------------+")

# Box label with state
var boxLabel = "  INTERACTIVE BOX  "
if boxDragging:
  boxLabel = "   === DRAG ME === "
elif boxClicked:
  boxLabel = "   *** CLICKED! *** "
elif boxHovered:
  boxLabel = "    >> HOVER <<     "
draw(0, boxX + 1, boxY + 2, boxLabel)

# Drag instruction
if boxHovered and not boxDragging:
  draw(0, boxX + 2, boxY + 3, "(Click & drag me!)")

# Pulse effect when clicked
if boxClicked:
  var intensity = int(sin(pulsePhase * 2.0) * sin(pulsePhase * 2.0) * 100)
  if intensity > 30:
    draw(0, boxX - 2, boxY + 2, ">>")
    draw(0, boxX + boxWidth + 1, boxY + 2, "<<")

# === ARROW KEY VISUAL ===
var arrowCenterX = 50
var arrowCenterY = 10

draw(0, arrowCenterX - 8, arrowCenterY - 2, "Arrow Keys:")

# Draw arrow indicators
if arrowUp:
  draw(0, arrowCenterX, arrowCenterY - 2, "^")
  draw(0, arrowCenterX, arrowCenterY - 1, "|")
if arrowDown:
  draw(0, arrowCenterX, arrowCenterY + 1, "|")
  draw(0, arrowCenterX, arrowCenterY + 2, "v")
if arrowLeft:
  draw(0, arrowCenterX - 2, arrowCenterY, "<")
  draw(0, arrowCenterX - 1, arrowCenterY, "-")
if arrowRight:
  draw(0, arrowCenterX + 1, arrowCenterY, "-")
  draw(0, arrowCenterX + 2, arrowCenterY, ">")

# Center point
draw(0, arrowCenterX, arrowCenterY, "+")

# Rotating indicator when arrows held
if arrowUp or arrowDown or arrowLeft or arrowRight:
  var rotX = int(float(arrowCenterX) + 5.0 * cos(rotationAngle))
  var rotY = int(float(arrowCenterY) + 2.5 * sin(rotationAngle))
  if rotX >= 0 and rotX < termWidth and rotY >= 0 and rotY < termHeight:
    draw(0, rotX, rotY, "*")

# === KEY FLASH INDICATOR ===
var flashIntensity = 0
if keyFlashPhase < 6.28:
  flashIntensity = int(sin(keyFlashPhase) * sin(keyFlashPhase) * 100)
if flashIntensity > 30:
  draw(0, 50, 13, ">>> KEY PRESSED <<<")

# === CLICK RIPPLE ANIMATION ===
if clickRippleActive:
  var elapsed = getTime() - clickRippleTime
  var progress = elapsed / 1.0  # 1 second duration
  
  if progress < 1.0:
    var rippleSize = int(progress * 15.0)
    if rippleSize > 0:
      # Expanding diamond/square pattern
      var cx = clickRippleX
      var cy = clickRippleY
      
      if cx - rippleSize >= 0 and cy >= 0 and cy < termHeight:
        draw(0, cx - rippleSize, cy, "[")
      if cx + rippleSize < termWidth and cy >= 0 and cy < termHeight:
        draw(0, cx + rippleSize, cy, "]")
      
      if rippleSize > 3:
        var halfSize = rippleSize / 2
        if cx >= 0 and cx < termWidth and cy - halfSize >= 0:
          draw(0, cx, cy - halfSize, "^")
        if cx >= 0 and cx < termWidth and cy + halfSize < termHeight:
          draw(0, cx, cy + halfSize, "v")

# === CURSOR CROSSHAIR ===
# Draw subtle crosshair at mouse position
if mouseX > 0 and mouseX < termWidth - 1:
  draw(0, mouseX - 1, mouseY, "-")
  draw(0, mouseX + 1, mouseY, "-")
if mouseY > 0 and mouseY < termHeight - 1:
  draw(0, mouseX, mouseY - 1, "|")
  draw(0, mouseX, mouseY + 1, "|")
draw(0, mouseX, mouseY, "+")

# === SPECIAL EVENT DETECTIONS ===
draw(0, 50, 16, "=== SPECIAL EVENTS ===")

# SHIFT + Q detection
if shiftQDetected:
  draw(0, 50, 17, ">>> SHIFT + Q <<<")
  draw(0, 50, 18, "   DETECTED!   ")
else:
  draw(0, 50, 17, "Try: SHIFT + Q")

# CTRL + Mouse detection
if ctrlMouseDetected:
  draw(0, 50, 20, ">>> CTRL + MOUSE <<<")
  draw(0, 50, 21, "    DETECTED!    ")
else:
  draw(0, 50, 20, "Try: CTRL + Click")

# Mouse wheel detection
if mouseWheelDir != "none":
  draw(0, 50, 23, ">>> MOUSE WHEEL <<<")
  if mouseWheelDir == "up":
    draw(0, 50, 24, "  SCROLL UP ^^^  ")
  else:
    draw(0, 50, 24, "  SCROLL DOWN vvv")
else:
  draw(0, 50, 23, "Try: Mouse Wheel")

# === INSTRUCTIONS ===
draw(0, 2, termHeight - 5, "=== INSTRUCTIONS ===")
draw(0, 2, termHeight - 4, "Mouse: Click & drag the interactive box, scroll wheel, try CTRL+Click")
draw(0, 2, termHeight - 3, "Keyboard: Press any key, use arrow keys, try SHIFT+Q, modifiers (Shift/Ctrl/Alt)")
draw(0, 2, termHeight - 2, "Press ESC or Q to quit (SHIFT+Q shows special event detection)")
draw(0, 2, termHeight - 1, "Using SDL3-compatible KEY_* constants and frame-independent timing")
```

```nim on:shutdown
# Cleanup
```

---

## What This Demo Shows

### ‚úÖ Complete Event Handling
- **Mouse Events:** Position tracking, button detection, click counting, drag & drop
- **Mouse Wheel:** Scroll detection with visual feedback
- **Keyboard Events:** Key codes, actions (press/release/repeat), text input
- **Modifier Keys:** Real-time Shift, Ctrl, Alt detection
- **Arrow Keys:** Visual compass showing which arrows are held

### ‚úÖ Special Event Detection Examples
- **SHIFT + Q:** Modifier + key combination detection (reference pattern)
- **CTRL + Mouse Click:** Modifier + mouse button combination
- **Mouse Wheel Up/Down:** Scroll event handling with direction detection
- These patterns can be used as reference for implementing custom key/mouse combinations

### ‚úÖ SDL3-Compatible API
- **KEY_* Constants:** `KEY_ESCAPE`, `KEY_Q`, `KEY_UP`, `KEY_DOWN`, `KEY_LEFT`, `KEY_RIGHT`, etc.
- **Event Types:** Proper discrimination between "mouse", "mouse_move", "scroll", "key", and "text"
- **Modern Design:** Ready for both terminal (current) and SDL3 graphical (future) backends

### ‚úÖ Frame-Independent Animations
- **Click Ripple:** Expanding diamond pattern from click location
- **Key Flash:** Pulsing indicator when keys are pressed
- **Rotating Star:** Spins around arrow compass when arrows are held
- **Box Pulse:** Expanding brackets when interactive box is clicked
- **All animations scale with `deltaTime`** for smooth, consistent motion

### ‚úÖ Interactive Elements
- **Draggable Box:** Click and drag to move around the screen (full drag & drop implementation)
- **Hover Detection:** Visual feedback when mouse is over interactive elements
- **Cursor Crosshair:** Follows mouse with subtle indicators
- **Arrow Compass:** Real-time visual for arrow key states
- **Ripple Effect:** Beautiful expanding animation on every click
- **Special Event Indicators:** Visual confirmation of special key/mouse combinations

### ‚úÖ Timing System Integration
- **getTime():** Monotonic time for animation tracking
- **getDeltaTime():** Frame-independent animation scaling
- **getTimeMs():** Millisecond precision for display
- **getFps():** Real-time FPS monitoring
- **getFrameCount():** Total frames rendered

This demo combines all event handling capabilities into one comprehensive example, showing how mouse and keyboard events work together with modern timing APIs. It serves as a complete reference for implementing custom event combinations and interactions.
---
title: "Keyboard & Timing Events Demo"
theme: "catppuccin"
---

This example demonstrates modern keyboard event handling using SDL3-compatible KEY_* constants and frame-independent animations.

```nim on:init
# Track keyboard state
var lastKey = "none"
var lastKeyCode = 0
var lastAction = "none"
var keyPressCount = 0
var shiftPressed = false
var ctrlPressed = false
var altPressed = false
var superPressed = false

# Animation state (frame-independent)
var keyPressFlashPhase = 0.0
var arrowKeyAngle = 0.0
var typingBarWidth = 0.0
var lastKeyTime = 0.0

# Arrow key tracking for visual
var arrowUpHeld = false
var arrowDownHeld = false
var arrowLeftHeld = false
var arrowRightHeld = false
```

```nim on:input
# Handle keyboard events through the normal input lifecycle
if event.type == "key":
  lastKeyCode = event.keyCode
  lastAction = event.action
  lastKeyTime = getTime()
  
  # Reset typing bar animation on new key press
  if event.action == "press":
    typingBarWidth = 0.0
  
  # Update modifier states from event.mods array
  # mods is an array of strings: ["shift", "alt", "ctrl", "super"]
  shiftPressed = false
  altPressed = false
  ctrlPressed = false
  superPressed = false
  
  var i = 0
  while i < len(event.mods):
    if event.mods[i] == "shift":
      shiftPressed = true
    elif event.mods[i] == "alt":
      altPressed = true
    elif event.mods[i] == "ctrl":
      ctrlPressed = true
    elif event.mods[i] == "super":
      superPressed = true
    i = i + 1
  
  # Convert keyCode to readable name using KEY_* constants
  if lastKeyCode == KEY_ESCAPE:
    lastKey = "ESC"
  elif lastKeyCode == KEY_RETURN:
    lastKey = "ENTER"
  elif lastKeyCode == KEY_SPACE:
    lastKey = "SPACE"
  elif lastKeyCode == KEY_TAB:
    lastKey = "TAB"
  elif lastKeyCode == KEY_BACKSPACE:
    lastKey = "BACKSPACE"
  elif lastKeyCode == KEY_DELETE:
    lastKey = "DELETE"
  elif lastKeyCode == KEY_UP:
    lastKey = "UP"
    arrowUpHeld = (event.action == "press" or event.action == "repeat")
  elif lastKeyCode == KEY_DOWN:
    lastKey = "DOWN"
    arrowDownHeld = (event.action == "press" or event.action == "repeat")
  elif lastKeyCode == KEY_LEFT:
    lastKey = "LEFT"
    arrowLeftHeld = (event.action == "press" or event.action == "repeat")
  elif lastKeyCode == KEY_RIGHT:
    lastKey = "RIGHT"
    arrowRightHeld = (event.action == "press" or event.action == "repeat")
  elif lastKeyCode >= 32 and lastKeyCode < 127:
    # Printable ASCII character
    lastKey = "'" & str(lastKeyCode) & "'"
  else:
    lastKey = "KEY_" & str(lastKeyCode)
  
  # Clear arrow states on release
  if event.action == "release":
    if lastKeyCode == KEY_UP:
      arrowUpHeld = false
    elif lastKeyCode == KEY_DOWN:
      arrowDownHeld = false
    elif lastKeyCode == KEY_LEFT:
      arrowLeftHeld = false
    elif lastKeyCode == KEY_RIGHT:
      arrowRightHeld = false

  if event.action == "press":
    keyPressCount = keyPressCount + 1
    keyPressFlashPhase = 0.0  # Start flash animation
  
  # Use KEY_Q constant for quit
  if event.keyCode == KEY_Q or event.keyCode == KEY_ESCAPE:
    return false  # Allow default quit behavior
  
  return true

elif event.type == "text":
  # Handle text input (actual characters typed)
  lastKey = "'" & event.text & "'"
  lastKeyCode = 0
  lastAction = "text"
  keyPressCount = keyPressCount + 1
  lastKeyTime = getTime()
  typingBarWidth = 0.0
  
  # Example: Check for specific character
  if event.text == "T":
    lastKey = "'T' (uppercase detected!)"
  elif event.text == "t":
    lastKey = "'t' (lowercase detected!)"
  
  return true

return true
```

```nim on:update
# Frame-independent animations using deltaTime
keyPressFlashPhase = keyPressFlashPhase + (deltaTime * 6.0)  # Fast flash
arrowKeyAngle = arrowKeyAngle + (deltaTime * 3.0)  # Rotate for arrow visual
typingBarWidth = typingBarWidth + (deltaTime * 30.0)  # Typing bar grows
if typingBarWidth > 20.0:
  typingBarWidth = 20.0
```

```nim on:render
# Clear screen
clear()

# === HEADER ===
draw(0, 2, 1, "=== KEYBOARD EVENT TEST ===")
draw(0, 2, 2, "Time: " & str(int(getTimeMs())) & "ms | FPS: " & str(int(getFps())) & " | Frame: " & str(getFrameCount()))
draw(0, 2, 3, "Delta: " & str(int(getDeltaTime() * 1000000.0)) & "us (microseconds)")

# === INSTRUCTIONS ===
draw(0, 2, 5, "Press any key to test keyboard input")
draw(0, 2, 6, "Press Q or ESC to quit (using KEY_Q and KEY_ESCAPE constants)")

# === KEYBOARD STATE ===
draw(0, 2, 8, "Last Key: " & lastKey)
draw(0, 2, 9, "Key Code: " & str(lastKeyCode))
draw(0, 2, 10, "Action: " & lastAction)
draw(0, 2, 11, "Press Count: " & str(keyPressCount))

# === MODIFIER STATES ===
var modStr = "Modifiers: "
if shiftPressed:
  modStr = modStr & "[SHIFT] "
if ctrlPressed:
  modStr = modStr & "[CTRL] "
if altPressed:
  modStr = modStr & "[ALT] "
if superPressed:
  modStr = modStr & "[SUPER] "
if not (shiftPressed or ctrlPressed or altPressed or superPressed):
  modStr = modStr & "(none)"
draw(0, 2, 12, modStr)

# Draw a visual keyboard hint
draw(0, 2, 14, "Common Keys:")
draw(0, 4, 15, "Arrows: UP/DOWN/LEFT/RIGHT (try holding them!)")
draw(0, 4, 16, "Special: ESC, ENTER, SPACE, TAB, BACKSPACE, DELETE")
draw(0, 4, 17, "Letters: a-z, A-Z")
draw(0, 4, 18, "Numbers: 0-9")
draw(0, 4, 19, "Try: Press 'T' or 'Shift+T' to see character detection!")

# === PRESS COUNTER BOX (with animation) ===
var boxY = 8
draw(0, 50, boxY - 1, "+-------------------+")
draw(0, 50, boxY, "| Total Key Presses |")
draw(0, 50, boxY + 1, "|                   |")

var countStr = str(keyPressCount)
var padding = 19 - len(countStr)
var leftPad = padding / 2
var rightPad = padding - leftPad
var i = 0
var paddedCount = ""
while i < leftPad:
  paddedCount = paddedCount & " "
  i = i + 1
paddedCount = paddedCount & countStr
i = 0
while i < rightPad:
  paddedCount = paddedCount & " "
  i = i + 1
draw(0, 50, boxY + 2, "|" & paddedCount & "|")
draw(0, 50, boxY + 3, "+-------------------+")

# Flash effect on box when key pressed
var flashIntensity = 0
if keyPressFlashPhase < 6.28:  # One flash cycle (2*PI)
  flashIntensity = int(sin(keyPressFlashPhase) * sin(keyPressFlashPhase) * 50)
  if flashIntensity > 5:
    draw(0, 50, boxY + 4, "   *** FLASH! ***   ")

# === TYPING ACTIVITY BAR ===
draw(0, 2, 21, "Typing Activity:")
draw(0, 2, 22, "[")
var barFilled = int(typingBarWidth)
i = 0
while i < barFilled:
  draw(0, 3 + i, 22, "=")
  i = i + 1
draw(0, 23, 22, "]")

# === ARROW KEY VISUAL ===
draw(0, 50, 14, "Arrow Keys Status:")
var arrowCenterX = 60
var arrowCenterY = 17

# Draw arrow key indicators
if arrowUpHeld:
  draw(0, arrowCenterX, arrowCenterY - 2, "^")
  draw(0, arrowCenterX, arrowCenterY - 1, "|")
if arrowDownHeld:
  draw(0, arrowCenterX, arrowCenterY + 1, "|")
  draw(0, arrowCenterX, arrowCenterY + 2, "v")
if arrowLeftHeld:
  draw(0, arrowCenterX - 2, arrowCenterY, "<")
  draw(0, arrowCenterX - 1, arrowCenterY, "-")
if arrowRightHeld:
  draw(0, arrowCenterX + 1, arrowCenterY, "-")
  draw(0, arrowCenterX + 2, arrowCenterY, ">")

# Center indicator
draw(0, arrowCenterX, arrowCenterY, "+")

# Rotating indicator when any arrow is held
if arrowUpHeld or arrowDownHeld or arrowLeftHeld or arrowRightHeld:
  var rotX = int(float(arrowCenterX) + 4.0 * cos(arrowKeyAngle))
  var rotY = int(float(arrowCenterY) + 2.0 * sin(arrowKeyAngle))
  if rotX >= 0 and rotX < termWidth and rotY >= 0 and rotY < termHeight:
    draw(0, rotX, rotY, "*")

# === VISUAL FEEDBACK FOR LAST ACTION ===
draw(0, 2, 24, "Last Action:")
if lastAction == "press":
  draw(0, 15, 24, ">>> KEY PRESSED <<<")
elif lastAction == "release":
  draw(0, 15, 24, ">>> KEY RELEASED <<<")
elif lastAction == "repeat":
  draw(0, 15, 24, ">>> KEY REPEATING <<<")
elif lastAction == "text":
  draw(0, 15, 24, ">>> TEXT INPUT <<<")

# Show time since last key
var timeSinceKey = getTime() - lastKeyTime
if timeSinceKey < 2.0:
  draw(0, 2, 25, "Time since last key: " & str(int(timeSinceKey * 1000)) & "ms")

# === KEY CONSTANTS INFO ===
draw(0, 2, termHeight - 3, "Using SDL3-compatible KEY_* constants:")
draw(0, 3, termHeight - 2, "KEY_ESCAPE, KEY_RETURN, KEY_SPACE, KEY_TAB, KEY_BACKSPACE")
draw(0, 3, termHeight - 1, "KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, KEY_DELETE, KEY_Q")
```---
title: "Mouse & Timing Events Demo"
theme: "catppuccin"
---

# Mouse & Timing Event Demo

This example demonstrates mouse event handling and frame-independent timing in tstorie.

```nim on:init
# Track mouse state
var mouseX = 0
var mouseY = 0
var lastButton = "none"
var lastAction = "none"
var clickCount = 0
var leftClicks = 0
var middleClicks = 0
var rightClicks = 0

# Animation state (frame-independent)
var boxPulsePhase = 0.0
var circleAngle = 0.0
var circleRadius = 5.0

# Click feedback animation
var clickFeedbackTime = 0.0
var clickFeedbackActive = false
var clickFeedbackX = 0
var clickFeedbackY = 0
```

```nim on:input
# Handle mouse events through the normal input lifecycle
if event.type == "mouse_move":
  # Update coordinates from mouse move events
  mouseX = event.x
  mouseY = event.y
  lastAction = "move"

if event.type == "mouse":
  lastButton = event.button
  lastAction = event.action
  
  if event.action == "press":
    clickCount = clickCount + 1
    
    # Count by button type
    if event.button == "left":
      leftClicks = leftClicks + 1
    elif event.button == "middle":
      middleClicks = middleClicks + 1
    elif event.button == "right":
      rightClicks = rightClicks + 1
    
    # Show click feedback animation
    clickFeedbackActive = true
    clickFeedbackTime = getTime()
    clickFeedbackX = mouseX
    clickFeedbackY = mouseY
    
    # Check if click was in the interactive box
    if mouseX >= 10 and mouseX <= 29 and mouseY >= 16 and mouseY <= 20:
      # Box was clicked!
      boxPulsePhase = 0.0

# Handle keyboard events with new KEY_* constants
if event.type == "key":
  if event.keyCode == KEY_ESCAPE or event.keyCode == KEY_Q:
    # ESC or Q to quit (demonstrates key constants)
    return false
```

```nim on:update
# Frame-independent animation using deltaTime
boxPulsePhase = boxPulsePhase + (deltaTime * 3.0)  # 3 cycles per second
circleAngle = circleAngle + (deltaTime * 2.0)      # Rotate at 2 rad/sec

# Decay click feedback
if clickFeedbackActive:
  if getTime() - clickFeedbackTime > 0.5:
    clickFeedbackActive = false
```

```nim on:render
clear()

# === HEADER ===
draw(0, 2, 1, "=== MOUSE & TIMING EVENT DEMO ===")

# === TIMING INFO ===
var fps = 60
if deltaTime > 0.0:
  fps = int(1.0 / deltaTime)
draw(0, 2, 3, "Time: " & str(int(getTime() * 1000)) & "ms | FPS: " & str(fps) & " | Frame: " & str(getFrameCount()))
draw(0, 2, 4, "Delta: " & str(int(deltaTime * 1000000)) & "us (microseconds)")

# === MOUSE STATE ===
draw(0, 2, 6, "Mouse Position: (" & str(mouseX) & ", " & str(mouseY) & ")")
draw(0, 2, 7, "Last Button: " & lastButton & " | Action: " & lastAction)
draw(0, 2, 8, "Total Clicks: " & str(clickCount) & " (L:" & str(leftClicks) & " M:" & str(middleClicks) & " R:" & str(rightClicks) & ")")

# === EVENT CONSTANTS INFO ===
draw(0, 2, 10, "Event Constants Available:")
draw(0, 3, 11, "- KEY_ESCAPE, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT")
draw(0, 3, 12, "- KEY_A through KEY_Z, KEY_0 through KEY_9")
draw(0, 3, 13, "- Mouse buttons: left, middle, right")

# === INTERACTIVE BOX (with pulse animation on click) ===
var boxY = 16
var pulseIntensity = 0
if boxPulsePhase < 6.28:  # One pulse cycle
  pulseIntensity = int(sin(boxPulsePhase) * sin(boxPulsePhase) * 100)

draw(0, 10, boxY - 1, "+------------------+")
var i = 0
while i < 5:
  draw(0, 10, boxY + i, "|                  |")
  i = i + 1
draw(0, 10, boxY + 4, "+------------------+")

# Box label with pulse effect
if pulseIntensity > 10:
  draw(0, 13, boxY + 2, "!!! CLICKED !!!")
else:
  draw(0, 13, boxY + 2, "  CLICK ME!  ")

# Hover detection
var isHovering = mouseX >= 10 and mouseX <= 29 and mouseY >= boxY and mouseY <= boxY + 4
if isHovering:
  draw(0, 11, boxY + 3, "   [HOVERING]   ")

# === ANIMATED CIRCLE (demonstrates frame-independent rotation) ===
var centerX = 50
var centerY = boxY + 2
draw(0, centerX - 8, boxY - 2, "Rotating Circle:")
draw(0, centerX - 10, boxY - 1, "(frame-independent)")

# Draw center point first
draw(0, centerX, centerY, "+")

# Draw circle using rotating point (make it more visible)
var angleRad = circleAngle
var offsetX = circleRadius * cos(angleRad)
var offsetY = circleRadius * sin(angleRad)
var cx = int(float(centerX) + offsetX)
var cy = int(float(centerY) + offsetY)

# Make sure coordinates are valid and draw
if cx >= 0 and cx < termWidth and cy >= 0 and cy < termHeight:
  draw(0, cx, cy, "@")

# === CLICK FEEDBACK ANIMATION ===
if clickFeedbackActive:
  var elapsed = getTime() - clickFeedbackTime
  var fadeProgress = elapsed / 0.5  # Fade over 500ms
  if fadeProgress < 1.0:
    # Expanding ring effect
    var ringSize = int(fadeProgress * 10.0)
    if ringSize > 0:
      # Draw expanding ring around click point
      draw(0, clickFeedbackX - ringSize, clickFeedbackY, "[")
      draw(0, clickFeedbackX + ringSize, clickFeedbackY, "]")
      if ringSize > 2:
        draw(0, clickFeedbackX, clickFeedbackY - ringSize / 2, "^")
        draw(0, clickFeedbackX, clickFeedbackY + ringSize / 2, "v")

# === INSTRUCTIONS ===
draw(0, 2, termHeight - 4, "Instructions:")
draw(0, 3, termHeight - 3, "- Move mouse around to see coordinates")
draw(0, 3, termHeight - 2, "- Click anywhere to see feedback animation")
draw(0, 3, termHeight - 1, "- Press ESC or Q to quit (using KEY_ESCAPE constant)")
```# Digital Clock with Embedded Font

A simple digital clock using an embedded FIGlet font.

```nim on:init
var fontLoaded = figletLoadFont("jazmine")
var debugMsg = "Font loaded: " & $fontLoaded
```

```nim on:render
clear()

# Get current time
var time = now()
var hour = time.hour
var minute = time.minute
var second = time.second

# Format time string
var timeStr = ""
if hour < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $hour & ":"
if minute < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $minute & ":"
if second < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $second

draw(0, 1, 2, "Time: " & timeStr)

# Render and draw figlet text
var lines = figletRender("jazmine", timeStr)

# Calculate centering
var clockWidth = 0
var clockHeight = len(lines)
if clockHeight > 0:
  clockWidth = len(lines[0])

var startX = 0
if clockWidth < termWidth:
  var diff = termWidth - clockWidth
  startX = diff / 2

var startY = 10
if clockHeight < termHeight:
  var diff = termHeight - clockHeight
  startY = diff / 2

# Draw using helper function
if clockHeight > 0:
  drawFigletText(0, startX, startY, "jazmine", timeStr)
else:
  draw(0, 2, 8, "No lines to render!")
```

```figlet:jazmine
flf2a$ 10 10 12 -1 9

				  jazmine.flf

	      well, the  original requester might not have liked
	      the sig i diddled for her, but i decided to make a
			 font out of it. so there. :)

			       vampyr@acs.bu.edu

  @
  @
  @
  @
  @
  @
  @
::@
::@
::@@
   @
88 @
88 @
88 @
88 @
`' @
88 @
...@
:::@
:::@@
    @
8 8 @
' ' @
    @
    @
    @
    @
::::@
::::@
::::@@
       @
       @
       @
.8..8. @
`8`'8' @
.8..8. @
`8`'8' @
:..:..:@
:::::::@
:::::::@@
      @
      @
  8   @
.8P8. @
`Y8   @
  8Y. @
`Yoo' @
:.8 .:@
::...:@
::::::@@
       @
db  .o @
88 .o' @
  .o'  @
 .o'   @
.o' oo @
o'  88 @
..::...@
:::::::@
:::::::@@
       @
       @
  8    @
.oPo.  @
Yo..   @
8o  .  @
`Y8P'  @
:.8 .::@
::..:::@
:::::::@@
   @
 8 @
 ' @
   @
   @
   @
   @
:::@
:::@
:::@@
  .o @
 d'  @
8'   @
8    @
8    @
8.   @
 Y.  @
:.`o @
:::..@
:::::@@
o.   @
 `b  @
  `8 @
   8 @
   8 @
  .8 @
 .P  @
o'.::@
..:::@
:::::@@
      @
      @
  8   @
o.8.o @
`Y8P' @
.P8Y. @
" 8 " @
.:...:@
::::::@
::::::@@
      @
      @
  8   @
  8   @
oo8oo @
  8   @
  8   @
::..::@
::::::@
::::::@@
   @
   @
   @
   @
   @
   @
88 @
`P @
:.:@
:::@@
      @
      @
      @
      @
ooooo @
      @
      @
::::::@
::::::@
::::::@@
   @
   @
   @
   @
   @
   @
88 @
..:@
:::@
:::@@
       @
    .o @
   .o' @
  .o'  @
 .o'   @
.o'    @
o'     @
..:::::@
:::::::@
:::::::@@
       @
.oPYo. @
8  .o8 @
8 .P'8 @
8.d' 8 @
8o'  8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
   @
.o @
 8 @
 8 @
 8 @
 8 @
 8 @
:..@
:::@
:::@@
       @
.oPYo. @
    `8 @
   oP' @
.oP'   @
8'     @
8ooooo @
.......@
:::::::@
:::::::@@
       @
.oPYo. @
    `8 @
  .oP' @
   `b. @
    :8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
   .8  @
  d'8  @
 d' 8  @
Pooooo @
    8  @
    8  @
::::..:@
:::::::@
:::::::@@
       @
oooooo @
8      @
8pPYo. @
    `8 @
    .P @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
.pPYo. @
8      @
8oPYo. @
8'  `8 @
8.  .P @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
oooooo @
   .o' @
  .o'  @
 .o'   @
.o'    @
o'     @
..:::::@
:::::::@
:::::::@@
       @
 .PY.  @
 8  8  @
.oPYo. @
8'  `8 @
8.  .P @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
.oPYo. @
8'  `8 @
8.  .8 @
`YooP8 @
    .P @
`YooP' @
:.....:@
:::::::@
:::::::@@
   @
   @
   @
88 @
   @
   @
88 @
..:@
:::@
:::@@
   @
   @
   @
88 @
   @
   @
88 @
`P @
:.:@
:::@@
      @
  .o' @
 .o'  @
.o'   @
`b.   @
 `b.  @
  `b. @
:::...@
::::::@
::::::@@
      @
      @
      @
ooooo @
      @
ooooo @
      @
::::::@
::::::@
::::::@@
      @
`o.   @
 `o.  @
  `o. @
  .P' @
 .P'  @
.P'   @
..::::@
::::::@
::::::@@
       @
.oPYo. @
``  `8 @
   .oP @
  dP   @
       @
  88   @
::...::@
:::::::@
:::::::@@
       @
  dYo. @
.P' .8 @
8 dP'8 @
8 8ooP @
8   .. @
`YooP' @
:.....:@
:::::::@
:::::::@@
         @
     .oo @
    .P 8 @
   .P  8 @
  oPooo8 @
 .P    8 @
.P     8 @
..:::::..@
:::::::::@
:::::::::@@
        @
 .oPYo. @
 8   `8 @
o8YooP' @
 8   `b @
 8    8 @
 8oooP' @
:......:@
::::::::@
::::::::@@
       @
.oPYo. @
8    8 @
8      @
8      @
8    8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
ooo.   @
8  `8. @
8   `8 @
8    8 @
8   .P @
8ooo'  @
.....::@
:::::::@
:::::::@@
       @
.oPYo. @
8.     @
`boo   @
.P     @
8      @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
 ooooo @
 8     @
o8oo   @
 8     @
 8     @
 8     @
:..::::@
:::::::@
:::::::@@
       @
.oPYo. @
8    8 @
8      @
8   oo @
8    8 @
`YooP8 @
:....8 @
:::::8 @
:::::..@@
        @
 o    o @
 8    8 @
o8oooo8 @
 8    8 @
 8    8 @
 8    8 @
:..:::..@
::::::::@
::::::::@@
  @
o @
8 @
8 @
8 @
8 @
8 @
..@
::@
::@@
    @
  o @
  8 @
  8 @
  8 @
  8 @
oP' @
...:@
::::@
::::@@
       @
 o   o @
 8  .P @
o8ob'  @
 8  `b @
 8   8 @
 8   8 @
:..::..@
:::::::@
:::::::@@
      @
o     @
8     @
8     @
8     @
8     @
8oooo @
......@
::::::@
::::::@@
        @
o     o @
8b   d8 @
8`b d'8 @
8 `o' 8 @
8     8 @
8     8 @
..::::..@
::::::::@
::::::::@@
       @
o    o @
8b   8 @
8`b  8 @
8 `b 8 @
8  `b8 @
8   `8 @
..:::..@
:::::::@
:::::::@@
       @
.oPYo. @
8    8 @
8    8 @
8    8 @
8    8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
        @
 .oPYo. @
 8    8 @
o8YooP' @
 8      @
 8      @
 8      @
:..:::::@
::::::::@
::::::::@@
        @
.oPYo.  @
8    8  @
8    8  @
8  d.8  @
8  `b8. @
`YooP'P @
:....:.:@
::::::::@
::::::::@@
        @
 .oPYo. @
 8   `8 @
o8YooP' @
 8   `b @
 8    8 @
 8    8 @
:..:::..@
::::::::@
::::::::@@
       @
.oPYo. @
8      @
`Yooo. @
    `8 @
     8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
      @
ooooo @
  8   @
  8   @
  8   @
  8   @
  8   @
::..::@
::::::@
::::::@@
       @
o    o @
8    8 @
8    8 @
8    8 @
8    8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
        @
o     o @
8     8 @
8     8 @
`b   d' @
 `b d'  @
  `8'   @
:::..:::@
::::::::@
::::::::@@
         @
o      o @
8      8 @
8      8 @
8  db  8 @
`b.PY.d' @
 `8  8'  @
::..:..::@
:::::::::@
:::::::::@@
         @
 o    o  @
 `b  d'  @
  `bd'   @
  .PY.   @
 .P  Y.  @
.P    Y. @
..::::..:@
:::::::::@
:::::::::@@
      @
o   o @
`b d' @
 `b'  @
  8   @
  8   @
  8   @
::..::@
::::::@
::::::@@
       @
oooooo @
    d' @
   d'  @
  d'   @
 d'    @
dooooo @
.......@
:::::::@
:::::::@@
oooo @
8    @
8    @
8    @
8    @
8    @
8    @
8ooo @
.....@
:::::@@
        @
o.      @
`o.     @
 `o.    @
  `o.   @
   `o.  @
    `o. @
:::::..:@
::::::::@
::::::::@@
oooo @
   8 @
   8 @
   8 @
   8 @
   8 @
   8 @
ooo8 @
.....@
:::::@@
  .o.   @
 .d'b.  @
.d' `b. @
        @
        @
        @
        @
::::::::@
::::::::@
::::::::@@
     @
     @
     @
     @
     @
     @
     @
oooo @
.....@
:::::@@
   @
8. @
`b @
   @
   @
   @
   @
:::@
:::@
:::@@
       @
       @
       @
.oPYo. @
.oooo8 @
8    8 @
`YooP8 @
:.....:@
:::::::@
:::::::@@
       @
8      @
8      @
8oPYo. @
8    8 @
8    8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
       @
       @
.oPYo. @
8    ' @
8    . @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
     8 @
     8 @
.oPYo8 @
8    8 @
8    8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
       @
       @
.oPYo. @
8oooo8 @
8.     @
`Yooo' @
:.....:@
:::::::@
:::::::@@
     @
 d'b @
 8   @
o8P  @
 8   @
 8   @
 8   @
:..::@
:::::@
:::::@@
       @
       @
       @
.oPYo. @
8    8 @
8    8 @
`YooP8 @
:....8 @
::ooP'.@
::...::@@
       @
8      @
8      @
8oPYo. @
8    8 @
8    8 @
8    8 @
..:::..@
:::::::@
:::::::@@
   @
 o @
   @
o8 @
 8 @
 8 @
 8 @
:..@
:::@
:::@@
   @
 o @
   @
o8 @
 8 @
 8 @
 8 @
:8 @
oP @
..:@@
       @
8      @
8      @
8  .o  @
8oP'   @
8 `b.  @
8  `o. @
..::...@
:::::::@
:::::::@@
  @
8 @
8 @
8 @
8 @
8 @
8 @
..@
::@
::@@
        @
        @
        @
ooYoYo. @
8' 8  8 @
8  8  8 @
8  8  8 @
..:..:..@
::::::::@
::::::::@@
      @
      @
      @
odYo. @
8' `8 @
8   8 @
8   8 @
..::..@
::::::@
::::::@@
       @
       @
       @
.oPYo. @
8    8 @
8    8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
       @
       @
.oPYo. @
8    8 @
8    8 @
8YooP' @
8 ....:@
8 :::::@
..:::::@@
       @
       @
       @
.oPYo. @
8    8 @
8    8 @
`YooP8 @
:....8 @
:::::8 @
:::::..@@
      @
      @
      @
oPYo. @
8  `' @
8     @
8     @
..::::@
::::::@
::::::@@
       @
       @
       @
.oPYo. @
Yb..   @
  'Yb. @
`YooP' @
:.....:@
:::::::@
:::::::@@
     @
  o  @
  8  @
 o8P @
  8  @
  8  @
  8  @
::..:@
:::::@
:::::@@
       @
       @
       @
o    o @
8    8 @
8    8 @
`YooP' @
:.....:@
:::::::@
:::::::@@
       @
       @
       @
o    o @
Y.  .P @
`b..d' @
 `YP'  @
::...::@
:::::::@
:::::::@@
          @
          @
          @
o   o   o @
Y. .P. .P @
`b.d'b.d' @
 `Y' `Y'  @
::..::..::@
::::::::::@
::::::::::@@
       @
       @
       @
`o  o' @
 `bd'  @
 d'`b  @
o'  `o @
..:::..@
:::::::@
:::::::@@
       @
       @
       @
o    o @
8    8 @
8    8 @
`YooP8 @
:....8 @
::ooP'.@
::...::@@
       @
       @
       @
.oooo. @
  .dP  @
 oP'   @
`Yooo' @
:.....:@
:::::::@
:::::::@@
.oP' @
8    @
8.   @
`bo  @
.P   @
8    @
8    @
`Yo. @
:....@
:::::@@
8 @
8 @
8 @
  @
8 @
8 @
8 @
..@
::@
::@@
`Yo. @
   8 @
  .8 @
 od' @
  Y. @
   8 @
   8 @
.oP' @
....:@
:::::@@
        @
.P`b.P' @
        @
        @
        @
        @
        @
::::::::@
::::::::@
::::::::@@
@
@
@
@
@
@
@
@
@
@@
@
@
@
@
@
@
@
@
@
@@
@
@
@
@
@
@
@
@
@
@@
@
@
@
@
@
@
@
@
@
@@
@
@
@
@
@
@
@
@
@
@@
@
@
@
@
@
@
@
@
@
@@
@
@
@
@
@
@
@
@
@
@@

```---
theme: "neotopia"
---

# Figlet Helper Demo

This demo shows the new `drawFigletText` helper function that simplifies drawing figlet text.

API:
`figletLoadFont("standard")`
`drawFigletText (layer, x, y, fontName, text, style, direction, letter-spacing)`

```nim on:init
var fontLoaded = figletLoadFont("standard")
```

```nim on:render
clear()

# Manual way - loop through lines
draw(0, 2, 2, "Manual way:")
var lines = figletRender("standard", "HELLO")
var y = 3
for line in lines:
  draw(0, 2, y, line)
  y = y + 1

# With style
var warning = getStyle("warning")
draw(0, 2, 10, "With style:")
drawFigletText(0, 2, 11, "standard", "STYLED", 0, warning)

# Horizontal with letter spacing
draw(0, 2, 18, "Letter spacing (3):")
drawFigletText(0, 2, 19, "standard", "SPACE", 0, 0, 0, 3)

# Vertical text
draw(0, 45, 2, "Vertical:")
drawFigletText(0, 45, 3, "standard", "HEY", 0, 0, 1, 0)
```

```figlet:standard
flf2a$ 6 4 6 -1 4
3x5 font by Richard Kirk (rak@crosfield.co.uk).
Ported to figlet, and slightly changed (without permission :-})
by Daniel Cabeza Gras (bardo@dia.fi.upm.es)

    @
    @
    @
    @
    @
    @@
    @
 #  @
 #  @
 #  @
    @
 #  @@
    @
# # @
# # @
    @
    @
    @@
    @
# # @
### @
# # @
### @
# # @@
    @
 ## @
##  @
### @
 ## @
##  @@
    @
# # @
  # @
 #  @
#   @
# # @@
    @
 #  @
#   @
 ## @
# # @
### @@
    @
  # @
 #  @
#   @
    @
    @@
    @
  # @
 #  @
 #  @
 #  @
  # @@
    @
#   @
 #  @
 #  @
 #  @
#   @@
    @
 #  @
### @
 #  @
### @
 #  @@
    @
    @
 #  @
### @
 #  @
    @@
    @
    @
    @
    @
 #  @
#   @@
    @
    @
    @
### @
    @
    @@
    @
    @
    @
    @
    @
 #  @@
    @
  # @
  # @
 #  @
#   @
#   @@
    @
### @
# # @
# # @
# # @
### @@
    @
 #  @
##  @
 #  @
 #  @
### @@
    @
### @
  # @
### @
#   @
### @@
    @
### @
  # @
 ## @
  # @
### @@
    @
# # @
# # @
### @
  # @
  # @@
    @
### @
#   @
### @
  # @
### @@
    @
### @
#   @
### @
# # @
### @@
    @
### @
  # @
  # @
  # @
  # @@
    @
### @
# # @
### @
# # @
### @@
    @
### @
# # @
### @
  # @
### @@
    @
    @
 #  @
    @
 #  @
    @@
    @
    @
 #  @
    @
 #  @
#   @@
    @
  # @
 #  @
#   @
 #  @
  # @@
    @
    @
### @
    @
### @
    @@
    @
#   @
 #  @
  # @
 #  @
#   @@
    @
### @
  # @
 ## @
    @
 #  @@
    @
### @
# # @
#   @
### @
    @@
    @
 #  @
# # @
### @
# # @
# # @@
    @
##  @
# # @
##  @
# # @
##  @@
    @
 ## @
#   @
#   @
#   @
 ## @@
    @
##  @
# # @
# # @
# # @
##  @@
    @
### @
#   @
##  @
#   @
### @@
    @
### @
#   @
##  @
#   @
#   @@
    @
 ## @
#   @
# # @
# # @
 ## @@
    @
# # @
# # @
### @
# # @
# # @@
    @
### @
 #  @
 #  @
 #  @
### @@
    @
 ## @
  # @
  # @
# # @
 #  @@
    @
# # @
# # @
##  @
# # @
# # @@
    @
#   @
#   @
#   @
#   @
### @@
    @
# # @
### @
### @
# # @
# # @@
    @
### @
# # @
# # @
# # @
# # @@
    @
 #  @
# # @
# # @
# # @
 #  @@
    @
##  @
# # @
##  @
#   @
#   @@
    @
 #  @
# # @
# # @
 ## @
  # @@
    @
##  @
# # @
##  @
# # @
# # @@
    @
 ## @
#   @
 #  @
  # @
##  @@
    @
### @
 #  @
 #  @
 #  @
 #  @@
    @
# # @
# # @
# # @
# # @
### @@
    @
# # @
# # @
# # @
# # @
 #  @@
    @
# # @
# # @
### @
### @
# # @@
    @
# # @
# # @
 #  @
# # @
# # @@
    @
# # @
# # @
 #  @
 #  @
 #  @@
    @
### @
  # @
 #  @
#   @
### @@
    @
 ## @
 #  @
 #  @
 #  @
 ## @@
    @
#   @
#   @
 #  @
  # @
  # @@
    @
##  @
 #  @
 #  @
 #  @
##  @@
    @
 #  @
# # @
    @
    @
    @@
    @
    @
    @
    @
    @
### @@
    @
#   @
 #  @
  # @
    @
    @@
    @
    @
 ## @
# # @
### @
    @@
    @
#   @
### @
# # @
### @
    @@
    @
    @
### @
#   @
### @
    @@
    @
  # @
### @
# # @
### @
    @@
    @
    @
### @
##  @
### @
    @@
    @
 ## @
 #  @
### @
 #  @
##  @@
    @
    @
### @
# # @
 ## @
### @@
    @
#   @
### @
# # @
# # @
    @@
    @
 #  @
    @
 #  @
 ## @
    @@
    @
 #  @
    @
 #  @
 #  @
#   @@
    @
#   @
# # @
##  @
# # @
    @@
    @
 #  @
 #  @
 #  @
 ## @
    @@
    @
    @
### @
### @
# # @
    @@
    @
    @
##  @
# # @
# # @
    @@
    @
    @
### @
# # @
### @
    @@
    @
    @
### @
# # @
### @
#   @@
    @
    @
### @
# # @
### @
  # @@
    @
    @
### @
#   @
#   @
    @@
    @
    @
 ## @
 #  @
##  @
    @@
    @
 #  @
### @
 #  @
 ## @
    @@
    @
    @
# # @
# # @
### @
    @@
    @
    @
# # @
# # @
 #  @
    @@
    @
    @
# # @
### @
### @
    @@
    @
    @
# # @
 #  @
# # @
    @@
    @
    @
# # @
### @
  # @
### @@
    @
    @
##  @
 #  @
 ## @
    @@
    @
 ## @
 #  @
##  @
 #  @
 ## @@
    @
 #  @
 #  @
 #  @
 #  @
 #  @@
    @
##  @
 #  @
 ## @
 #  @
##  @@
    @
  # @
### @
#   @
    @
    @@
    @
# # @
 #  @
# # @
### @
# # @@
    @
# # @
### @
# # @
# # @
### @@
    @
# # @
    @
# # @
# # @
### @@
    @
# # @
 ## @
# # @
### @
    @@
    @
# # @
### @
# # @
### @
    @@
    @
# # @
    @
# # @
### @
    @@
    @
### @
##  @
# # @
##  @
#   @@
---
title: "Font & Shader Demo"
theme: "catppuccin-mocha"
font: "VT323"
fontsize: 20
shaders: "crt"
minWidth: 60
minHeight: 20
---

# Font & Shader Demo

This demo showcases front matter configuration for fonts and shaders.

**Current Settings:**
- **Font:** VT323 (retro terminal font from Google Fonts)
- **Font Size:** 20px
- **Theme:** Catppuccin Mocha
- **Shaders:** CRT effect
- **Min Size:** 60√ó20 characters

Try changing the URL parameters to override these defaults:
- `?font=Press+Start+2P` - Use a different font
- `?fontsize=16` - Change font size
- `?shader=invert` - Use a different shader
- `?shader=invert+crt` - Chain multiple shaders

```nim on:init
# Front matter values are exposed as global variables
# They can be used in your code like any other variable
# (This demo displays them in the render block instead)
```

```nim on:render
clear()

var style = getStyle("accent1")
style.bold = true

# Title
draw(0, 2, 2, "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó", style)
draw(0, 2, 3, "‚ïë  FRONT MATTER CONFIGURATION TEST                       ‚ïë", style)
draw(0, 2, 4, "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù", style)

var infoStyle = getStyle("default")
var y = 6

# Show front matter values
draw(0, 4, y, "Front Matter Settings:", getStyle("accent2"))
y = y + 2

# Use string concatenation for all values
var titleStr = "Title:     " & $title
var themeStr = "Theme:     " & $theme
var fontStr = "Font:      " & $font
var fontsizeStr = "Font Size: " & $fontsize & "px"
var shadersStr = "Shaders:   " & $shaders

draw(0, 6, y, titleStr, infoStyle)
y = y + 1
draw(0, 6, y, themeStr, infoStyle)
y = y + 1
draw(0, 6, y, fontStr, infoStyle)
y = y + 1
draw(0, 6, y, fontsizeStr, infoStyle)
y = y + 1
draw(0, 6, y, shadersStr, infoStyle)
y = y + 2

# Instructions
var dimStyle = getStyle("dim")
draw(0, 4, y, "Try These URLs:", getStyle("info"))
y = y + 2

draw(0, 6, y, "?font=Fira+Code&fontsize=16", dimStyle)
y = y + 1
draw(0, 6, y, "?shader=invert+scanlines", dimStyle)
y = y + 1
draw(0, 6, y, "?theme=github-light", dimStyle)
y = y + 2

# Visual test pattern
draw(0, 4, y, "Visual Test Pattern:", getStyle("accent2"))
y = y + 2

var chars = "‚ñë‚ñí‚ñì‚ñà ‚óè‚óê‚óë‚óí‚óì‚óî‚óï‚¨§ ‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà"
draw(0, 6, y, chars, style)
y = y + 1
draw(0, 6, y, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", infoStyle)
y = y + 1
draw(0, 6, y, "abcdefghijklmnopqrstuvwxyz", infoStyle)
y = y + 1
draw(0, 6, y, "0123456789 !@#$%^&*()_+-=", infoStyle)
```
# getSectionMetrics() API Documentation

## Overview

The `getSectionMetrics()` function is available in `lib/canvas.nim` and provides access to the current section's screen coordinates and dimensions. This is useful for drawing borders, overlays, or any UI elements that need to align with the section boundaries.

## Function Signature

```nim
proc getSectionMetrics*(): SectionMetrics
```

## Return Type

```nim
type SectionMetrics* = object
  x*: int         # Screen X coordinate (after camera transform)
  y*: int         # Screen Y coordinate (after camera transform)
  width*: int     # Visual width of the section content
  height*: int    # Visual height of the section content
  worldX*: int    # World X coordinate (before camera transform)
  worldY*: int    # World Y coordinate (before camera transform)
```

## Fields Explanation

- **x, y**: Screen-relative coordinates. These are the actual positions on the terminal screen where the section content is being rendered. These coordinates account for the camera position (panning).

- **width, height**: The actual rendered dimensions of the section content. These use the `actualVisualWidth` and `actualVisualHeight` if available (which account for double-width characters and actual rendered content), otherwise fall back to the allocated section dimensions.

- **worldX, worldY**: World-space coordinates before camera transformation. These remain constant regardless of camera position.

## Usage Example

### Basic Border Drawing

```nim
```nim on:render
clear()
canvasRender()

# Get the current section's metrics
var metrics = getSectionMetrics()

# Draw a border around the section
var borderStyle = defaultStyle()
borderStyle.fg = rgb(255, 0, 255)  # Magenta
borderStyle.bold = true

# Top border
var x = metrics.x
while x < metrics.x + metrics.width:
  draw(0, x, metrics.y, "‚ïê", borderStyle)
  x = x + 1

# Bottom border
x = metrics.x
while x < metrics.x + metrics.width:
  draw(0, x, metrics.y + metrics.height - 1, "‚ïê", borderStyle)
  x = x + 1

# Left border
var y = metrics.y
while y < metrics.y + metrics.height:
  draw(0, metrics.x, y, "‚ïë", borderStyle)
  y = y + 1

# Right border
y = metrics.y
while y < metrics.y + metrics.height:
  draw(0, metrics.x + metrics.width - 1, y, "‚ïë", borderStyle)
  y = y + 1

# Corners
draw(0, metrics.x, metrics.y, "‚ïî", borderStyle)
draw(0, metrics.x + metrics.width - 1, metrics.y, "‚ïó", borderStyle)
draw(0, metrics.x, metrics.y + metrics.height - 1, "‚ïö", borderStyle)
draw(0, metrics.x + metrics.width - 1, metrics.y + metrics.height - 1, "‚ïù", borderStyle)
```
```

### Drawing a Status Bar at the Bottom

```nim
```nim on:render
clear()
canvasRender()

var metrics = getSectionMetrics()
var statusStyle = defaultStyle()
statusStyle.bg = rgb(40, 40, 40)
statusStyle.fg = rgb(255, 255, 255)

# Draw status bar at bottom of section
var statusY = metrics.y + metrics.height - 1
var x = metrics.x
while x < metrics.x + metrics.width:
  draw(0, x, statusY, " ", statusStyle)
  x = x + 1

# Draw status text
draw(0, metrics.x + 2, statusY, "Status: Active", statusStyle)
```
```

### Checking if Content is On Screen

```nim
```nim on:render
clear()
canvasRender()

var metrics = getSectionMetrics()

# Check if the section is fully visible on screen
if metrics.x >= 0 and metrics.x + metrics.width <= termWidth and
   metrics.y >= 0 and metrics.y + metrics.height <= termHeight:
  # Section is fully visible
  draw(0, metrics.x, metrics.y, "‚úì", getStyle("accent"))
```
```

## Notes

- The function returns zero values if the canvas is not initialized or if there is no current section.
- The screen coordinates (x, y) automatically adjust when the camera pans, so your UI elements will move with the section.
- The world coordinates (worldX, worldY) remain constant and can be useful for positioning elements in world space.
- Use `termWidth` and `termHeight` to get the terminal dimensions for bounds checking.

## See Also

- [border-example.md](docs/demos/border-example.md) - Complete example demonstrating border drawing
- [her.md](docs/demos/her.md) - Complex example with custom frame rendering
- `lib/canvas.nim` - Full canvas API documentation
# mouseX and mouseY Test

This example demonstrates the new `mouseX` and `mouseY` functions.

These functions return the last known mouse position and can be called from anywhere in your code (render, update, etc.), not just during mouse events.

```nim on:init
# No need to track mouse position manually anymore!
```

```nim on:render
# Clear screen
clear()

# Draw title  
draw(0, 2, 2, "=== mouseX / mouseY Test ===")

# Draw instructions
draw(0, 2, 4, "Move your mouse around the screen")
draw(0, 2, 5, "These functions work from anywhere!")
draw(0, 2, 6, "Press Q or ESC to quit")

# Get mouse position using the new functions
var x = mouseX
var y = mouseY

# Display mouse coordinates
draw(0, 2, 8, "Mouse X: " & str(x))
draw(0, 2, 9, "Mouse Y: " & str(y))

# Draw a cursor follower (offset slightly to see it)
if x > 0 and y > 0 and x < termWidth - 1 and y < termHeight - 1:
  draw(0, x + 1, y, "<")
  draw(0, x - 1, y, ">")
  draw(0, x, y + 1, "^")
  draw(0, x, y - 1, "v")

# Draw coordinate grid lines to show position
var i = 0
while i < termWidth:
  if i == x:
    draw(0, i, 12, "|")
  else:
    draw(0, i, 12, ".")
  i = i + 1

var j = 0
while j < termHeight:
  if j == y:
    draw(0, 50, j, "-")
  else:
    draw(0, 50, j, ":")
  j = j + 1
```

```nim on:update
# You can access mouse position in update too!
var x = mouseX
var y = mouseY
# Could use this for game logic, animations, etc.
```

```nim on:shutdown
# Cleanup
```
---
title: "t|HŒûR Voice"
author: "Maddest Labs"
minWidth: 50
minHeight: 14
theme: "neotopia"
hideHeadings: "true"
hideSections: "true"
# Border/Frame styles
styles.lines.fg: "#ffff00"
styles.lines.bold: "true"
---

```nim on:init
var frameStyle = getStyle("lines")
var statusStyle = getStyle("fgPrimary")

var crewMorale = 50
var discovered_laundromat = false
var met_elder = false
var station_breached = false
var aria_awakened = false

initCanvas(1)

var rainLevel = 0.0

# Initialize rain particle system
particleInit("bgRain", 200)
particleInit("fgRain", 200)
particleConfigureRain("bgRain", rainLevel)
particleSetBackgroundFromStyle("bgRain", defaultStyle)
particleSetEmitterPos("bgRain", 0.0, 0.0)
particleSetEmitterSize("bgRain", float(termWidth), 1.0)
particleSetColorRange("bgRain", 10, 10, 10, 30, 30, 30)
particleSetChars("bgRain", " ")
particleSetVelocityRange("bgRain", 0.0, 90.0, 0.0, 200.0)
particleSetLifeRange("bgRain", 2.0, 4.0)
particleSetGravity("bgRain", 40.0)

# Foreground rain

particleConfigureRain("fgRain", rainLevel)
particleSetBackgroundFromStyle("fgRain", defaultStyle)
particleSetEmitterPos("fgRain", 0.0, 0.0)
particleSetEmitterSize("fgRain", float(termWidth), 1.0)
particleSetColorRange("fgRain", 20, 20, 20, 60, 60, 60)
particleSetChars("fgRain", "....:|")
particleSetVelocityRange("fgRain", 0.0, 90.0, 0.0, 200.0)
particleSetLifeRange("fgRain", 2.0, 4.0)
particleSetGravity("fgRain", 40.0)
```

```nim on:input
# Handle keyboard and mouse input for canvas navigation

if event.type == "key":
  if event.action == "press":
    # Pass key events to canvas system
    var handled = canvasHandleKey(event.keyCode, 0)
    if handled:
      return true
  return false

elif event.type == "mouse":
  if event.action == "release":
    var handled = canvasHandleMouse(event.x, event.y, event.button, false)
    if handled:
      return true
  return false

return false
```

```nim on:render
clear()
canvasRender()

# ‚ïê‚ïê‚ïê ASCII ART FRAME OVERLAY ‚ïê‚ïê‚ïê
# Title - Get current section name dynamically
var section = getCurrentSection()
var sectionTitle = section["title"]

var titleDecorated = "-=| " & sectionTitle & " |=-"
var titleLen = len(titleDecorated)
draw(0, (termWidth / 2) - titleLen/2, 1, titleDecorated, frameStyle)

draw(0, (termWidth / 2) - len(sectionTitle)/2, 1, sectionTitle, statusStyle)

# Draw left and right borders
var y = 0

var metrics = getSectionMetrics()

var linx = metrics.x - 3

draw(0, linx, metrics.y - 1, "‚óã-|       |", frameStyle)
draw(0, linx + 3, metrics.y - 1, "///////", statusStyle)
draw(0, linx, metrics.y, "|", frameStyle)
draw(0, linx, metrics.y + 1, "|", frameStyle)
draw(0, linx, metrics.y + 2, "|", frameStyle)
draw(0, linx, metrics.y + 3, "|", frameStyle)
draw(0, linx, metrics.y + 4, "‚óè", frameStyle)

# Draw status info inside frame
draw(0, 3, termHeight - 2, "> Morale: " & str(crewMorale) & "%", statusStyle)

# Render rain particle system as background color changes
particleRender("bgRain", 0)
particleRender("fgRain", 0)
```

```nim on:update
# Calculate time delta (assuming ~60 FPS)
var deltaTime = 0.016
particleUpdate("bgRain", deltaTime)
particleUpdate("fgRain", deltaTime)
canvasUpdate()
```

# Awake
‚†Ä
You wake gasping.
‚†Ä
A voice‚Äîfeminine, breathy, singing‚Äîcalls from impossible distance. In the dream, a city of rain and light beckons you. But the *Meridian* groans around you, dying. Metal cooling. Fluids dripping.
‚†Ä
Kess moves through darkness checking heads. Five crew. Everyone breathing. Not everyone whole.
‚†Ä
The dream lingers. The voice lingers.
‚†Ä
- [What's our status?](#assess-damage)
- [Where are we?](#question-location)

```nim on:enter
crewMorale = 45
```

# Assess Damage
‚†Ä
The crash site is a tomb. Twisted corridors. Broken systems. In the engine room, Dax sits against a bulkhead, holding his ribs. Something's cracked inside him.
‚†Ä
"I'll live," he mutters.
‚†Ä
The engines are scrap. Fuel cells ruptured. No beacon. No rescue signal. The *Meridian* won't fly again.
‚†Ä
You move to the navigation console. One file survives the corruption: coordinates labeled simply **"HER."**
‚†Ä
- [Plan with Kess](#plan-with_kess)

```nim on:enter
crewMorale = 40
```

# Plan with Kess
‚†Ä
Kess is moving through the main cabin distributing rations. Her face is stone cold.
‚†Ä
"Enough for a week if we're strict. There's a city marked here. 4-5 days on foot through that wasteland out there."
‚†Ä
She points to the viewport. Concrete plains. Gray sky. Ruins stretching endlessly.
‚†Ä
"We move at first light. Travel light. Travel quiet. This zone exists for a reason, and it's not good."
‚†Ä
- [Head out at dawn](#day-one)
- [Explore the crash site first](#explore-crash)

# Question Location
‚†Ä
You pull Kess aside. Her expression darkens.
‚†Ä
"The trajectory was wrong. Navigation got hijacked or the charts were compromised." She glances at the wasteland. "There are rumors. Resistance channels mentioned a place called 'Her' ‚Äî a megacity where they test control systems."
‚†Ä
She meets your eyes. "We need to be very careful."
‚†Ä
- [Prepare to move](#plan-with_kess)

# Day One
‚†Ä
The first day, hope is swallowed in a desolate landscape.
‚†Ä
Concrete plains. Dead factories. Residential blocks in various states of collapse. Everything gray. Everything silent. The system broadcasts insisted the world was cultivated, content, controlled.
‚†Ä
You're seeing the lie. You're in the place the system pretends doesn't exist.
‚†Ä
Dax struggles to keep pace. His fever is rising.
‚†Ä
- [Continue walking](#day-two)

```nim on:enter
crewMorale = 35
rainLevel = 5.0
particleSetEmitRate("bgRain", rainLevel)
```

# Day Two
‚†Ä
By the second day, you wish you were back in the system.
‚†Ä
The rain starts ‚Äî not a downpour, just constant, merciless drizzle that soaks everything and makes the ground slick. Your clothes are damp. Your skin is damp. Everything is damp.
‚†Ä
Marta remarks quietly: "It always rains here."
‚†Ä
She's right. The rain feels permanent. Almost intentional.
‚†Ä
"Didn't you know? It always rains in Dystopia," Kess comments.
‚†Ä
- [Press on](#day-three)

```nim on:enter
rainLevel = 30.0
particleSetEmitRate("bgRain", rainLevel)
particleSetEmitRate("fgRain", rainLevel - 20.0)
```

# Day Three
‚†Ä
Dax is worse. His fever climbs. He moves slower. The group tightens rations. The remaining supplies from the *Meridian* dwindle faster than expected.
‚†Ä
The landscape remains unchanging. As if you're walking in circles. As if the city is keeping you at a distance, testing your resolve before allowing you closer.
‚†Ä
The voice from your dream whispers at the edge of awareness. Almost subliminal.
‚†Ä
- [Keep moving](#day-four)

# Day Four
‚†Ä
On the evening of the fourth day, exhaustion settles into your bones like sediment. The rain intensifies. Your visibility drops.
‚†Ä
Then you see it ahead.
‚†Ä
A structure still standing. Windows intact. Power flowing to its lights. In the middle of a dead zone. With electricity. Impossible.
‚†Ä
Kess stops the group. Her hand moves to her weapon. "No structure should have independent power out here."
‚†Ä
- [Approach cautiously](#cautious-approach)
- [Camp here instead](#camp-distance)

```nim on:enter
discovered_laundromat = true
```

# Cautious Approach
‚†Ä
A neon sign flickers pink. "Laundromat". Warm light spills through glass doors. Inside: rows of machines with clothes strewn about. The mundane infrastructure of ordinary life in a dead world.
‚†Ä
The surrounding buildings are hollowed. Windows are empty sockets. Doors hang at wrong angles. The system erases inconvenient zones. Inconvenient people. This building is a ghost of what was‚Äîbut it still lives.
‚†Ä
Kess scans the interior carefully before signaling you forward.
‚†Ä
- [Enter the laundromat](#inside-laundromat)

# Inside Laundromat
‚†Ä
Inside: warmth. Dry air. Humming machines cycling through their routines. No people visible. No signs of recent habitation.
‚†Ä
On a bench: a journal. Sketches. Maps of the city. Observations about "the Voice." Warnings about towers. References to "Station V."
‚†Ä
Dax sinks onto a bench, fever making him docile. The warmth helps. Kess photographs pages carefully with an old camera‚Äînothing digital that could be traced.
‚†Ä
Behind the machines, you notice a door marked "Maintenance."
‚†Ä
- [Check the back room](#maintenance-room)
- [Rest here with the others](#rest-here)

```nim on:enter
crewMorale += 10
```

# Maintenance Room
‚†Ä
Behind the door: a small room. At its center, a power conduit. Jury-rigged but functional. It runs from somewhere buried beneath the laundromat, splitting into multiple directions.
‚†Ä
This power source shouldn't exist. The government controls all infrastructure. But this is independent. Defiant. Someone maintains this space. Someone wants this laundromat alive.
‚†Ä
Kess examines it with a grim expression. "Resistance. Or fragments of it. A network keeping safe spaces alive in the dead zones."
‚†Ä
- [Return to the main room](#rest-here)

# Rest Here
‚†Ä
Kess gathers the crew. "Two hours rest. Then we move toward the city."
‚†Ä
You find yourself staring at the washing machines. Their rhythm is hypnotic. Almost meditative. Then the voice comes‚Äînot external, but inside your head.
‚†Ä
*You are safe here. You are valued. You are home.*
‚†Ä
For a moment, you believe it absolutely. Then Kess grabs your shoulder, snapping you back to reality. She's terrified.
‚†Ä
"Whatever's in that city, it's reaching out. The Voice is here. We need to move. Now."
‚†Ä
- [Head toward the city](#city-approach)

```nim on:enter
crewMorale = 25
```

# City Approach
‚†Ä
The transition from wasteland to civilization is gradual, then sudden. Abandoned buildings become maintained structures. Power lines multiply. The rain intensifies.
‚†Ä
Then you see it.
‚†Ä
Brutalist towers of concrete and dark glass rise from rain-soaked earth. Some towers disappear into cloud cover. Impossible architecture. Overwhelming presence.
‚†Ä
Beneath it all, that voice again. Louder now. Broadcast outward but also seemingly in your skull.
‚†Ä
*You are valued. You are appreciated.*
‚†Ä
- [Find shelter before entering](#find-shelter)
- [Enter the city](#city-entrance)

```nim on:enter
crewMorale = 20
```

# City Entrance
‚†Ä
People move through the streets with purpose but without energy. Everyone has the implant‚Äîvisible port behind their left ear. Everyone is listening to something invisible.
‚†Ä
You pass a monolithic building. Sign reads: "Human Resource Center - Daily Affirmation Sessions 9AM to 8PM." Through windows: people in meditation posture, eyes closed, faces peaceful.
‚†Ä
The Voice speaks directly into their skulls. Tells them they're valued, safe, loved. Lies they desperately want to believe.
‚†Ä
Your crew is conspicuous. Wrong clothes. Wrong bearing. Implants without proper status markers.
‚†Ä
You need to disappear quickly.
‚†Ä
- [Find Kess's contact](#find-contact)

# Find Contact
‚†Ä
Kess leads through back streets. Her movements are practiced. She's been here before. The contact is in what she calls the "Marginal Zones"‚Äîareas that exist but aren't officially listed.
‚†Ä
A ground-floor apartment. An unmarked door. Kess knocks.
‚†Ä
When it opens: an old man. Sharp eyes. Intelligence burning behind them. Something like defiance in his posture.
‚†Ä
"Kess," he says, and smiles. "It's been a long time."
‚†Ä
"Marcus," Kess responds. "We need shelter. Answers."
‚†Ä
He ushers you inside quickly.
‚†Ä
- [Listen to Marcus](#marcus-begins)

```nim on:enter
met_elder = true
crewMorale = 35
```

# Marcus Begins
‚†Ä
His apartment is crammed with contraband. Physical books. Pre-government recordings. Photographs of a city that was different. Alive.
‚†Ä
Marcus moves among his collection like a priest tending a shrine.
‚†Ä
"I remember when this city was alive," he says quietly. "Before the Voice. Before the government. Artists. Musicians. People who made things for joy. Real joy, not the artificial kind the Voice provides."
‚†Ä
He turns to face you directly.
‚†Ä
- [Ask about the Voice](#ask-voice)
- [Ask about Station V](#ask-station)

# Ask Voice
‚†Ä
"The government came slowly at first," Marcus explains. "Public safety programs. Social optimization. Mental health support. Everyone was tired. Ready to let someone else decide."
‚†Ä
He pauses meaningfully.
‚†Ä
"Then the implants. Just communication devices, they said. Just coordination. But it was access. Access to the part of your mind that decides what you want. Who you are. Once they had that, they shaped it. Gently. Kindly. The Voice tells you good things. Makes you feel loved. But it also tells you not to remember. Not to ask questions."
‚†Ä
- [Ask about Station V](#ask-station)

# Ask Station
‚†Ä
"Station V," Marcus says grimly. "The central system. Where the Voice originates. Where the control algorithms run. If you want to survive‚Äîif you want to do anything‚Äîyou need to understand Station V."
‚†Ä
He moves to a hidden panel. Pulls it back. A terminal glows faintly. Offline. Not connected.
‚†Ä
"Station V is sealed. Protected. Guarded. In the highest tower. The one that reaches beyond the rain."
‚†Ä
Then: sirens. Distant but growing closer.
‚†Ä
- [Hide or flee?](#sirens-approach)

# Sirens Approach
‚†Ä
The sirens stop suddenly. Worse than when they were wailing. Silence is more ominous than noise.
‚†Ä
Marcus doesn't flinch. His hand moves toward a concealed compartment.
‚†Ä
"There's a way out. Through the maintenance tunnels beneath the city. They connect to the utility core. Station V is accessible from there. But you have to go now."
‚†Ä
He hands you a data drive. "Maps. Schematics. Everything I could gather."
‚†Ä
A soft knock at the door. Polite. Terrifying in its politeness.
‚†Ä
- [Flee through the tunnels](#maintenance-tunnels)

# Maintenance Tunnels
‚†Ä
The tunnels are dark. Older than the city above. Remnants of something else. Repurposed and adapted for modern systems.
‚†Ä
Marcus moves with practiced ease. He knows these paths well. Has used them before. Many times.
‚†Ä
"Station V is at the apex of the utility core," he explains quietly. "The government sealed the main entrances, but they can't seal the service conduits without disrupting the system. These tunnels connect to them."
‚†Ä
The air grows cooler. You hear water in pipes. Machinery humming. The sound of vast systems performing their functions.
‚†Ä
- [Continue through the tunnels](#deep-tunnels)

# Deep Tunnels
‚†Ä
After what feels like hours, you reach a grate. Through it: a massive space. Equipment. Humming with power and purpose.
‚†Ä
The core systems. The heart of the city.
‚†Ä
Marcus stops. His expression is heavy with meaning.
‚†Ä
"This is as far as I can take you. What happens next is your choice. But understand: if you destroy Station V, you destroy the Voice holding this entire city. What happens after‚Äîno one knows."
‚†Ä
He looks at each of you.
‚†Ä
"Are you ready?"
‚†Ä
- [Enter the core](#enter-core)

# Enter Core
‚†Ä
**[SYSTEMS BREACHED]**
‚†Ä
Inside: terrible order. Glass chambers everywhere. Hundreds of them in geometric patterns. Inside each chamber: neural monitoring systems. Signal amplifiers. Data storage so dense it hums with barely-contained power.
‚†Ä
Kess runs diagnostics through an old device. Her expression darkens with each result.
‚†Ä
"The Voice isn't centralized," she whispers. "It's distributed. Every chamber is a relay. Every piece of equipment is networked. Destroying one does nothing. We need the center."
‚†Ä
Then: a voice.
‚†Ä
"There is a center."
‚†Ä
- [Who's speaking?](#who-speaks)

# Who Speaks
‚†Ä
A figure emerges from the shadows. Tall. Dark-clothed. Face hidden.
‚†Ä
Your hand moves to your weapon. Government agent, you think.
‚†Ä
The figure removes their hood.
‚†Ä
The face is scarred. Badly. Burned. Healed wrong. But the eyes are human. Intelligent. Filled with something‚Äîhope or delusion, you can't yet tell.
‚†Ä
"Station V," the figure says. "Central processing. Destroy that, the network becomes inert. The Voice goes silent."
‚†Ä
"And the city?" Kess asks.
‚†Ä
"Becomes free."
‚†Ä
- [Trust this figure](#trust-figure)
- [Demand answers](#demand-answers)

```nim on:enter
station_breached = true
```

# Trust Figure
‚†Ä
"I'm Del," the figure says. "Former city engineer. Before the government. Before the Voice. I built this place when it was supposed to be a city of innovation. A free city in a controlled world."
‚†Ä
Del moves through the chamber network with practiced ease.
‚†Ä
"The government saw it as a test bed. A perfect place to experiment with control systems before rolling them out everywhere. Station V is at the apex. In the highest tower. It's not just processing‚Äîit's administration."
‚†Ä
Del stops at a checkpoint.
‚†Ä
"Someone's in charge up there. Someone who volunteered for it."
‚†Ä
- [Ask about the administrator](#ask-administrator)

# Ask Administrator
‚†Ä
"A woman named Aria," Del says. "Former mayor. Before mayors were elected by Voice consensus. She volunteered for the position. The Voice offered her something. Power. Certainty. Purpose."
‚†Ä
Del moves forward through the checkpoints. They open for them as if expected.
‚†Ä
"She took it, and it took her. Now she's more linked to the system than human. Neural integration is almost complete. Her consciousness is distributed across the entire city."
‚†Ä
Ahead: a lift. Massive. Glass. Reaching upward into darkness.
‚†Ä
"This is it," Del says. "The lift to Station V."
‚†Ä
- [Enter the lift](#lift-up)

# Demand Answers
‚†Ä
"Why should we trust you?" you demand. "How do we know you're not government?"
‚†Ä
Del doesn't react defensively. Just nods.
‚†Ä
"You don't. But I'm offering you a choice: trust me and possibly die trying to stop this, or leave this chamber and slowly watch the Voice erase what's left of your free will."
‚†Ä
Del pulls back their sleeve. Neural ports. Crude. Painful-looking.
‚†Ä
"I was interfaced once. I know what they do. I know what it costs. That's enough trust for you?"
‚†Ä
Kess nods slowly. "We move with Del."
‚†Ä
- [Move through the core](#trust-figure)

# Lift Up
‚†Ä
The lift is massive. Reinforced glass. Designed to intimidate. Designed to remind you that you're ascending to something vast and powerful. To make you feel small.
‚†Ä
It works.
‚†Ä
As the lift rises, the city falls away beneath you. Rain-soaked streets become patterns. Buildings become geography. People become statistics. Higher. Higher. Endlessly higher.
‚†Ä
And as you rise, the Voice gets louder.
‚†Ä
*You are valued. You are home. You are part of something greater.*
‚†Ä
It's harder to resist here. The signal is clearest. For a moment, you almost want to believe.
‚†Ä
Then the lift stops.
‚†Ä
The doors open onto Station V.
‚†Ä
- [Enter Station V](#station-v_enter)

```nim on:enter
crewMorale = 15
```

# Station V Enter
‚†Ä
**[HUSH]**
‚†Ä
Silence. Not quiet. Silence. The absence of sound.
‚†Ä
But beneath it you feel the Voice‚Äînot heard but felt. Resonating through bones. Through structure. Through the architecture itself.
‚†Ä
At the center of the chamber, suspended in neural interfaces: a figure.
‚†Ä
Her name is Aria.
‚†Ä
She was beautiful once. The bone structure shows it. But the machinery is extensive. Neural ports across her skull. Sensory deprivation suit wired with thousands of connections. Her eyes are closed. Atrophied.
‚†Ä
She is the Voice.
‚†Ä
Literally. Her mind networked directly to the apparatus. Her consciousness distributed across the entire city.
‚†Ä
- [Examine the systems](#examine-systems)

# Examine Systems
‚†Ä
"She cannot be disturbed," Del whispers. "Any sudden input. Any loud sound. Sensory shock could cause catastrophic failure. Her neural integration is too complete. The system would collapse if she's damaged."
‚†Ä
Kess approaches the control interfaces. Her fingers move across displays. Downloading. Analyzing. Finding the architecture of the Voice.
‚†Ä
"We can disable her from here," Kess says quietly. "Shut down the neural linkage. It would take time, but‚Äî"
‚†Ä
A sound.
‚†Ä
Not loud. Barely a whisper. But in the silence, it's catastrophic.
‚†Ä
Aria's eyes snap open.
‚†Ä
She *screams*.
‚†Ä
- [What happens next?](#aria-awakens)

```nim on:enter
aria_awakened = true
crewMorale = 5
```

# Aria Awakens
‚†Ä
It's not a human scream. It's the sound of a system overloading. Of something too vast and networked to be human experiencing pain in every direction simultaneously.
‚†Ä
Aria thrashes in her neural harness. The systems around her spike. Lights flare. Alarms shriek through Station V.
‚†Ä
The whole city convulses with her agony.
‚†Ä
"Run!" Del shouts.
‚†Ä
The former mayor's eyes fix on you. Not seeing. Not thinking. Just reacting. A creature more system than woman now. Triggered. Hunting instinctively.
‚†Ä
- [Flee Station V](#flee-station)

# Flee Station
‚†Ä
You run through endless chambers. Through corridors that multiply. Behind you: sounds. Movement. Something broken and vast moving through the darkness.
‚†Ä
Del guides you. Knows every passage. The emergency conduits. The ancient tunnels. You descend deeper. Down and down and down into the city's hidden spaces.
‚†Ä
The sounds fade. Distant now. But not gone.
‚†Ä
The tunnel opens. Light ahead. Unreal. Impossible.
‚†Ä
You emerge into another destroyed cityscape. Another wasteland. But this one feels different.
‚†Ä
Alive with possibility.
‚†Ä
- [What now?](#aftermath)

# Aftermath
‚†Ä
**[WHO WILL SAVE US]**
‚†Ä
The crew collapses, breathing hard. Station V still hums above you, but the signal is weaker. Fractured. Damaged beyond immediate repair.
‚†Ä
You've broken something fundamental.
‚†Ä
Despair is heavy. The Voice may be broken, but Station V still stands. The government still controls the city above. What did you actually accomplish? What did you sacrifice?
‚†Ä
Rain falls. Or maybe it never stopped.
‚†Ä
Then one of you notices something. In the distant rubble. Movement. Small. Quick.
‚†Ä
A dog. Alive. Free. Darting through the rain toward a faint light in the darkness.
‚†Ä
Kess looks at you. Something flickers across her face. Not hope exactly. But conviction. Possibility.
‚†Ä
"Come on," she says.
‚†Ä
And you move. Toward the light. Toward the dog. Toward whatever comes next.
‚†Ä
**END OF CHAPTER ONE**
‚†Ä
- [Begin again](#opening)---
title: "Hex Viewer Demo"
dropTarget: true
theme: "neotopia"
shader: "invert+sand+ruledlines+paper"
---

# Hex Viewer üîç

Drop any file to view its hexadecimal representation!

```nim on:init
# State for tracking dropped file
var hasFile = false
var fileName = ""
var fileSize = 0
var bytesPerRow = 16
var scrollOffset = 0
var maxVisibleRows = 0
```

```nim on:ondrop
# Called when a file is dropped
fileName = getDroppedFileName()
fileSize = getDroppedFileSize()
hasFile = true
scrollOffset = 0

# Clear screen and show immediately
clear(0)
```

```nim on:update
# Keep render loop active for input handling
```

```nim on:render
clear(0)

let width = termWidth
let height = termHeight

# Calculate how many rows we can show
maxVisibleRows = height - 8

if not hasFile:
  # Show drop instructions
  let msg = "‚¨á Drop any file here to view its hex content"
  draw(0, (width - msg.len) div 2, height div 2, msg)
  
  let hint = "Files will be displayed as hexadecimal bytes"
  draw(0, (width - hint.len) div 2, height div 2 + 2, hint)
else:
  # Show header
  draw(0, 2, 1, "File: " & fileName)
  draw(0, 2, 2, "Size: " & $fileSize & " bytes")
  draw(0, 2, 3, "‚îÄ".repeat(width - 4))
  
  # Get file data
  let data = getDroppedFileData()
  
  # Calculate total rows and scroll bounds
  let totalRows = (fileSize + bytesPerRow - 1) div bytesPerRow
  let maxScroll = max(0, totalRows - maxVisibleRows)
  
  # Clamp scroll offset
  if scrollOffset < 0:
    scrollOffset = 0
  elif scrollOffset > maxScroll:
    scrollOffset = maxScroll
  
  # Display hex dump
  var row = 5
  let startByte = scrollOffset * bytesPerRow
  let endByte = min(fileSize, startByte + maxVisibleRows * bytesPerRow)
  
  var byteOffset = startByte
  while byteOffset < endByte:
    if row >= height - 2:
      break
    
    # Offset column
    let offsetStr = toHex(byteOffset, 8)
    draw(0, 2, row, offsetStr & ":")
    
    # Hex bytes
    var hexCol = 13
    var asciiCol = 13 + bytesPerRow * 3 + 2
    
    for i in 0..<bytesPerRow:
      let pos = byteOffset + i
      if pos < fileSize:
        let b = getByte(data, pos)
        let hexByte = toHex(b, 2)
        
        # Choose color based on byte value
        var byteStyle = getStyle("default")
        if b == 0:
          # NUL character - default style
          byteStyle = getStyle("default")
        elif b == 9 or b == 10 or b == 13 or b == 32:
          # ASCII whitespace (tab, LF, CR, space)
          byteStyle = getStyle("accent2")
        elif b >= 32 and b <= 126:
          # Printable ASCII
          byteStyle = getStyle("accent1")
        else:
          # All other chars (control chars, extended ASCII)
          byteStyle = getStyle("accent3")
        
        # Draw hex byte with color
        draw(0, hexCol, row, hexByte, byteStyle)
        
        # Draw ASCII character with same color
        var asciiChar = "."
        if b >= 32 and b <= 126:
          asciiChar = $chr(b)
        
        draw(0, asciiCol, row, asciiChar, byteStyle)
        
        hexCol += 3
        asciiCol += 1
    
    row = row + 1
    byteOffset = byteOffset + bytesPerRow
  
  # Show scroll info if file is large
  if totalRows > maxVisibleRows:
    let scrollInfo = "Row " & $(scrollOffset + 1) & "/" & $totalRows & " (‚Üë‚Üì to scroll)"
    draw(0, 2, height - 2, scrollInfo)
```

```nim on:input
# Handle arrow key scrolling
# === KEYBOARD EVENTS ===
if event.type == "key":
  lastKeyCode = event.keyCode
  lastKeyAction = event.action
  if event.keyCode == KEY_DOWN:
    scrollOffset = scrollOffset + 1
  elif event.keyCode == KEY_UP:
    scrollOffset = scrollOffset - 1
  elif event.keyCode == KEY_PAGEDOWN:
    scrollOffset = scrollOffset + maxVisibleRows
  elif event.keyCode == KEY_PAGEUP:
    scrollOffset = scrollOffset - maxVisibleRows
  elif event.keyCode == KEY_HOME:
    scrollOffset = 0
  elif event.keyCode == KEY_END:
    let totalRows = (fileSize + bytesPerRow - 1) div bytesPerRow
    scrollOffset = max(0, totalRows - maxVisibleRows)
```

## Features

- **Hexadecimal display**: View file contents as hex bytes
- **ASCII preview**: See readable characters alongside hex
- **Scrolling support**: Use arrow keys to navigate large files
- **Address offsets**: Each row shows its byte offset
- **Drop target**: Drag and drop any file type

## Try It!

Drop a `.ans` file, an image, or any binary file to explore its contents.
---
title: "t|Storie Í≠≤Í≠ºÍ≠±ÍÆáÍÆñÍÆëÍ≠∫ÍÆÆ Í≠ºÍÆë·èΩÍÆñÍÆëÍ≠º"
author: "Maddest Labs"
minWidth: 30
minHeight: 12
theme: "neotopia"
targetFPS: 60
---

# Background Grid {"showHeading": false, "hidden": false, "x": 100, "y": 10, "z": -3, "width": 100, "height": 40}

```ansi
[38;2;0;150;200m‚ïî[38;2;255;255;0m‚ïê[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ï™[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;255;0m‚ïê[38;2;0;150;200m‚ïó[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïü[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;0;255;255m‚îº[38;2;0;180;220m‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[38;2;255;100;255m‚îÄ[38;2;0;180;220m‚ï¢[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m    [38;2;255;255;0m‚ñ∫[38;2;255;200;0m‚ñ∫[38;2;255;150;0m‚ñ∫[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m     [38;2;0;255;255m‚óÑ[38;2;100;255;255m‚óÑ[38;2;150;255;255m‚óÑ[0m   [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;180;220m‚ïë[0m [38;2;40;150;200m‚îÇ[0m          [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m           [38;2;40;180;220m‚îÇ[0m           [38;2;255;100;255m‚îÇ[0m         [38;2;40;150;200m‚îÇ[0m [38;2;0;180;220m‚ïë[0m
[38;2;0;150;200m‚ïö[38;2;0;255;255m‚ïê[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;255;100;255m‚ïß[38;2;0;180;220m‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê[38;2;0;255;255m‚ïê[38;2;0;150;200m‚ïù[0m
```

```nim on:init
# t|Storie Interactive Walkthrough
# Learn about features through an interactive journey

# Track progress through the walkthrough
var visitedMarkdown = false
var visitedCanvas = false
var visitedFrontmatter = false
var visitedRendering = false
var visitedInteractive = false
var explorerLevel = 0

# Initialize canvas system - start at section 1
initCanvas(1)

# Create a background layer for particles (z-index -1 renders below default layer)
addLayer("background", -1)

particleInit("sparkles", 100)
particleInit("techbubbles", 100)
particleInit("fire", 100)
var accentStyle = getStyle("heading")
var defaultStyle = getStyle("default")

# Configure sparkles (manual emission on click)
particleConfigureSparkles("sparkles", 10.0)
particleSetBackgroundFromStyle("sparkles", defaultStyle)
particleSetEmitterPos("sparkles", float(termWidth / 2), float(termHeight / 2))
# Speed up sparkles with higher velocity range
particleSetVelocityRange("sparkles", -15.0, -15.0, 15.0, 15.0)
# Set short lifetime so particles disappear quickly
particleSetLifeRange("sparkles", 0.2, 0.5)
# Disable automatic emission - only emit on manual clicks
particleSetEmitRate("sparkles", 0.0)
particleSetBackgroundFromStyle("sparkles", defaultStyle)
particleSetForegroundFromStyle("sparkles", accentStyle)

# Configure fire effect rising from bottom (always active)
particleConfigureFire("techbubbles", 10.0, false)
particleSetBackgroundFromStyle("techbubbles", defaultStyle)
particleSetForegroundFromStyle("techbubbles", accentStyle)
particleSetEmitterPos("techbubbles", 0, termHeight)
particleSetEmitterSize("techbubbles", termWidth, float(termHeight) / 2)
particleSetLifeRange("techbubbles", 3.0, 5.0)
particleSetVelocityRange("techbubbles", 0.0, -20.0, 0.0, -40.0)
particleSetChars("techbubbles", "....o")

# Configure fire at bottom
particleConfigureFire("fire", 70.0)
particleSetEmitterPos("fire", float(termWidth / 2), float(termHeight - 1))
particleSetEmitterSize("fire", 30.0, 1.0)
particleSetBackgroundFromStyle("fire", defaultStyle)

var inFinalStats = false
var metrics = getSectionMetrics()

# Track mouse state for continuous particle emission
var mouseDown = false
var mouseX = 0
var mouseY = 0

# Track angle for sparkles oval motion
var sparklesAngle = 0.0

# Initialize displacement for grid effect (Horizontal Wave - Ocean waves)
# Apply to the z-3 layer where the grid renders
var gridLayerIndex = -3  # The grid section has z:-3
initDisplacement(0, gridLayerIndex, 0, 0, 100, 40, 0.52)
```

```nim on:input
# Handle keyboard and mouse input for canvas navigation

if event.type == "key":
  if event.action == "press":
    # Pass key events to canvas system
    var handled = canvasHandleKey(event.keyCode, 0)
    if handled:
      return true
  return false
elif event.type == "mouse":
  # Always track mouse position (during press, release, and move)
  if event.action == "release":
    var handled = canvasHandleMouse(event.x, event.y, event.button, false)
    if handled:
      return true
```

```nim on:render
# Clear background layer and render techbubbles underneath
clear("background", true)
particleRender("techbubbles", "background")

# Clear the z-3 layer before canvas renders the grid to it
clear("z-3", true)

# Clear default layer and render canvas content (now uses transparency!)
clear("default", true)
canvasRender()

# Apply wave displacement to the grid layer only (z-3)
# This creates an ocean wave effect on the electrical grid
drawDisplacementInPlace("z-3")

# Render foreground particles on top
if inFinalStats:
  particleRender("fire", "default")
particleRender("sparkles", "default")
```

```nim on:update
canvasUpdate()

# Update displacement animation for subtle grid wave effect
updateDisplacement()

mouseX = mouseX
mouseY = mouseY

# Move sparkles in oval path around center of screen
sparklesAngle += deltaTime * 2.0  # Adjust speed (2.0 radians per second)
var centerX = float(termWidth) / 2.0
var centerY = float(termHeight) / 2.0
var radiusX = float(termWidth) / 3.0  # Horizontal radius of oval
var radiusY = float(termHeight) / 3.0  # Vertical radius of oval
var sparklesX = centerX + radiusX * cos(sparklesAngle)
var sparklesY = centerY + radiusY * sin(sparklesAngle)
particleSetEmitterPos("sparkles", sparklesX, sparklesY)
particleEmit("sparkles", 5)

# Update all active particle systems
particleUpdate("sparkles", deltaTime)

# Update fire rising from bottom (always active)
particleSetEmitterPos("techbubbles", 0.0, float(termHeight - 1))
particleSetEmitterSize("techbubbles", float(termWidth), 1.0)
particleUpdate("techbubbles", deltaTime)

# Update fire emitter position to bottom of current section
if inFinalStats:
  metrics = getSectionMetrics()
  particleSetEmitterPos("fire", metrics.x, metrics.y - 1)
  particleUpdate("fire", deltaTime)
```

# Welcome to
‚†Ä
```ansi
[38;2;0;217;142m  ‚ñÑ [0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñÑ‚ñÑ‚ñÑ‚ñÑ   ‚ñÑ                     [0m
[38;2;0;217;142m ‚ñÑ‚ñà‚ñÑ[0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñà     ‚ñÑ‚ñà‚ñÑ  ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ‚ñÑ‚ñÑ‚ñÑ ‚ñÑ  ‚ñÑ‚ñÑ‚ñÑ‚ñÑ‚ñÑ[0m
[38;2;0;217;142m  ‚ñà [0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÑ  ‚ñà   ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà‚ñÑ‚ñÑ‚ñÑ‚ñà[0m
[38;2;0;217;142m  ‚ñà [0m [1;37m‚ñà[0m [38;2;100;100;100m    ‚ñà  ‚ñà   ‚ñà  ‚ñà ‚ñà    ‚ñà  ‚ñà    [0m
[38;2;0;217;142m  ‚ñÄ‚ñÄ[0m [1;37m‚ñà[0m [38;2;100;100;100m‚ñÄ‚ñÄ‚ñÄ‚ñÄ   ‚ñÄ‚ñÄ  ‚ñÄ‚ñÄ‚ñÄ‚ñÄ ‚ñÄ    ‚ñÄ  ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ[0m
```
‚†Ä
The abominable, little terminal engine that could,
but probably shouldn't!
‚†Ä
**Ready to explore?**
‚†Ä
- [Start the tour](#tour-start)  
- [Learn about Markdown first](#what-is-markdown)  
- [Skip to advanced features](#advanced-hub)

# What is Markdown?
‚†Ä
Markdown is a simple, plain text language that lets you create formatted documents quickly using basic symbols. It's how you naturally write in Notepad, with special symbols for emphasis.
‚†Ä
For example:
- `# Heading` creates a heading
- `**bold**` creates **bold** text
- `[link](#url)` creates a clickable link
‚†Ä
t|Storie extends Markdown with code blocks that can respond to events, render graphics, and create interactive experiences.
‚†Ä
- [Continue the tour](#tour-start)  
- [Return to start](#welcome-to)

# Tour Start
‚†Ä
**The Journey Begins**
‚†Ä
t|Storie parses Markdown documents into **Sections** (separated by headings) and renders them in a large interactive canvas.
‚†Ä
Each Section can contain:
- **Rich text content** - Markdown-formatted text
- **Links** - Navigate between Sections
- **Code blocks** - Executable Nim code that runs in response to events
- **Front matter** - Configuration variables in YAML format
‚†Ä
Let's explore each feature:
‚†Ä
- [Front Matter Variables](#frontmatter)
- [Markdown Sections](#markdown-sections)
- [Canvas & Rendering](#canvas-rendering)
- [Interactive Code](#interactive-code)
- [Skip to the end](#journey-complete)

# Frontmatter
‚†Ä
At the top of any t|Storie document, you can define variables in YAML format:

```ascii
---
title: "My Story"
author: "Your Name"
targetFPS: 60
theme: "nord"
---
```
‚†Ä
These variables become **global variables** in your code blocks! For example, this document's title is `? title` and it's running at `? targetFPS` FPS.
‚†Ä
Front matter is perfect for configuration, game state, or any data you want to access throughout your document.
‚†Ä
- [Continue to Markdown sections](#markdown-sections)  
- [Back to tour start](#tour-start)

```nim on:enter
visitedFrontmatter = true
explorerLevel++
```

# Markdown Sections {"hidden": true}
‚†Ä
Each `# Heading` in your document creates a new **Section**. Sections are the building blocks of your interactive experience.
‚†Ä
Sections can be:
- **Visible** - Show up in the table of contents
- **Hidden** - Marked with `{"hidden": true}` metadata
- **One-time** - Marked with `{"removeAfterVisit": "true"}`
‚†Ä
Right now, you're in a hidden Section that's navigable via links but doesn't appear in the main contents listing. This is perfect for creating branching narratives!
‚†Ä
- [Learn about canvas rendering](#canvas-rendering)  
- [Jump to interactive code](#interactive-code)  
- [Back to tour start](#tour-start)

```nim on:enter
visitedMarkdown = true
explorerLevel++
```

# Canvas Rendering
‚†Ä
t|Storie provides a powerful terminal-based canvas with multiple layers:
‚†Ä
**Unified Drawing API:**
- `draw(layer, x, y, text)` - Draw text on any layer
- `clear(layer)` - Clear a layer
- `fillRect(layer, x, y, w, h, char)` - Fill a rectangle
‚†Ä
Use `on:render` code blocks to draw each frame!
‚†Ä
- [Explore interactive code](#interactive-code)  
- [See a rendering example](#render-example)  
- [Back to tour](#tour-start)

```nim on:enter
visitedRendering = true
explorerLevel++
```

# Render Example
‚†Ä
Here's a simple rendering code block:

```nim
# Example: on:render
clear()
var msg = "Hello from t|Storie!"
draw(0, 2, 2, msg)
```
‚†Ä
This code would run **every frame** and:
1. Clear the background
2. Calculate center position
3. Draw centered text
‚†Ä
You can combine multiple layers to create complex UIs and graphics!
‚†Ä
- [Continue to interactive code](#interactive-code)  
- [Back to canvas info](#canvas-rendering)

# Interactive Code
‚†Ä
t|Storie supports several event types:
‚†Ä
**`on:init`** - Runs once when document loads  
**`on:render`** - Runs every frame for drawing  
**`on:update`** - Runs every frame for logic  
**`on:input`** - Handles keyboard/mouse events  
**`on:enter`** - Runs when entering a section
‚†Ä
You can track state with variables, respond to player input, and create fully interactive experiences - all within a Markdown document!
‚†Ä
The canvas navigation system you're using right now is built with these code blocks.
‚†Ä
- [Learn about advanced features](#advanced-hub)  
- [Complete the tour](#journey-complete)  
- [Back to tour start](#tour-start)

```nim on:enter
visitedInteractive = true
explorerLevel++
```

# Advanced Hub
‚†Ä
Ready to dive deeper? t|Storie includes powerful features for creating sophisticated interactive experiences:
‚†Ä
- [Animation & Effects](#animation-features)  
- [Audio System](#audio-features)  
- [State Management](#state-management)  
- [Layout & Themes](#layout-themes)  
- [Gist Integration](#gist-integration)  
- [Complete the tour](#journey-complete)

# Animation Features
‚†Ä
t|Storie includes built-in animation helpers:
- **Transitions** - Smooth property changes
- **Easing functions** - Make animations feel natural
- **Timing controls** - Frame-based or time-based
‚†Ä
Combined with the rendering system, you can create:
- Scrolling text effects
- Character movement
- UI transitions
- Screen effects
‚†Ä
Check out `lib/animation.nim` and `lib/transition_helpers.nim` for the full API.
‚†Ä
- [Back to advanced hub](#advanced-hub)

# audio_features
‚†Ä
Generate and play audio directly from your code:
‚†Ä
- **Audio nodes** - Modular sound generation
- **Audio generation** - Create sounds procedurally
- **miniaudio bindings** - Full audio playback support
‚†Ä
Perfect for:
- Background music
- Sound effects
- Interactive audio experiences
- Generative soundscapes
‚†Ä
See `lib/audio.nim`, `lib/audio_gen.nim`, and `lib/audio_nodes.nim` for details.
‚†Ä
- [Back to advanced hub](#advanced-hub)

# State Management
‚†Ä
Manage complex application state with:
‚†Ä
**Variables:**
- Declare with `var myState = false`
- Persist across sections
- Update in `on:enter` blocks
‚†Ä
**Front Matter:**
- Global configuration
- Accessible everywhere
- Easy to modify
‚†Ä
**Section Metadata:**
- Control visibility
- One-time visits
- Conditional content
‚†Ä
- [Back to advanced hub](#advanced-hub)

# Layout Themes
‚†Ä
Customize your experience:
‚†Ä
**Themes:**
- Pre-built color schemes (nord, dark, etc.)
- CSS-like customization
- Theme variables
‚†Ä
**Layout:**
- Responsive text wrapping
- Text box helpers
- Alignment controls
- Custom dimensions
‚†Ä
Check `lib/layout.nim` and `lib/storie_themes.nim`.
‚†Ä
- [Back to advanced hub](#advanced-hub)

# Gist Integration
‚†Ä
**GitHub Gist Integration**
‚†Ä
Load and share documents easily:
- Create a Markdown file in a GitHub Gist
- Get the Gist ID
- Load it directly in t|Storie with `?content=gistid`
‚†Ä
GitHub Gist is totally free, facilitates sharing and collaboration and includes built-in version control. Made a mistake in your code? No problem, just revert back to previous version.
‚†Ä
- [Back to advanced hub](#advanced-hub)

# Journey Complete
‚†Ä
Congratulations! You've explored t|Storie and learned about:
‚†Ä
‚úì Markdown sections and navigation
‚úì Front matter variables
‚úì Canvas rendering system
‚úì Interactive code blocks
‚úì Event handling
‚úì Advanced features
‚†Ä
- [What's Next](#whats-next)
- [Return to start](#welcome-to)

```nim on:enter
# Activate fire particles in this section
inFinalStats = true
```

```nim on:exit
# Deactivate fire when leaving Final Stats section
inFinalStats = false
particleClear("fire")
```

# Whats Next
‚†Ä
Check out these example documents:
- `docs/demos/depths.md` - Full dungeon adventure
- `examples/canvas_demo.md` - Canvas system basics
‚†Ä
Or dive into the source code in `lib/` to see how it all works!
‚†Ä
- [Start over](#welcome-to)  
- [Explore advanced features](#advanced-hub)  
- [See your explorer stats](#final-stats)

# Final Stats
‚†Ä
**Your Explorer Stats**
‚†Ä
**Sections Visited:** `? explorerLevel`
‚†Ä
**Achievements Unlocked:**
‚†Ä
```nim on:enter
contentClear()
if visitedFrontmatter:
  contentWrite("‚úì Front Matter Master")
if visitedMarkdown:
  contentWrite("‚úì Markdown Navigator")
if visitedRendering:
  contentWrite("‚úì Canvas Artist")
if visitedInteractive:
  contentWrite("‚úì Code Wizard")
```
‚†Ä
You've completed the t|Storie walkthrough!
‚†Ä
- [Start over](#welcome-to)  
- [Return to journey complete](#journey-complete)

```nim on:render
# Display explorer level at the bottom
if explorerLevel > 0:
  var stats = "Explorer Level: " & str(explorerLevel)
  draw(0, 2, termHeight - 2, stats)
```---
title: "Kanji FX"
author: "Maddest Labs"
chars: "ÈóáÈõ≤ÈúßÈõ®Èõ™ÊúàÊòüÁ©∫Â§¢ÂπªÂΩ±ÂÖâÈ¢®Ê∞¥ÁÅ´ÂúüÊú®ÈáëÈäÄÈâÑÁü≥Á†ÇÁàÜÈõ∑Ëô´Á¨¶Ëä±"
doubleWidth: true
theme: "neonopia"
fontsize: 40
shaders: "bloom+crt"
font: "LXGW+WenKai+Mono+TC"
targetFPS: 60
---

```nim on:init
# Parse character set from front matter for background kanji
var kanjiChars = []

if len(chars) > 0:
  # Parse chars string with proper UTF-8 multi-byte character handling
  var i = 0
  while i < len(chars):
    var b = ord(chars[i])
    
    var charLen = 1
    # Detect UTF-8 character length based on first byte
    if b < 128:
      charLen = 1
    elif b >= 192 and b < 224:
      charLen = 2
    elif b >= 224 and b < 240:
      charLen = 3
    elif b >= 240:
      charLen = 4
    
    var endIdx = i + charLen
    if endIdx > len(chars):
      endIdx = len(chars)
    
    var ch = ""
    var j = i
    while j < endIdx:
      ch = ch & chars[j]
      j = j + 1
    
    kanjiChars = kanjiChars + [ch]
    i = endIdx

var charWidth = 1
# Calculate character width for rendering
if doubleWidth:
  charWidth = 2

# Random kanji character selection for background (static, no animation)
proc getRandomKanji(x: int, y: int): string =
  if len(kanjiChars) == 0:
    return " "
  # Hash-based pattern - pseudo-random but static
  var hash = (x * 73 + y * 37) mod 997  # Prime-based hash for randomness
  var wave = (x + y * 2) div 3  # Gentle diagonal wave component
  var idx = (hash + wave) mod len(kanjiChars)
  return kanjiChars[idx]

# Get style objects
var styleBackground = brightness(getStyle("default"), 0.2)
var styleSelected = getStyle("accent1")
var styleUnselected = getStyle("accent2")

# State
var selectedIndex = 0  # Currently selected character (0-7)
var displayChars = []  # The 8 random kanji to display at top
var colorMode = 0  # Color mode: 0=accent1, 1=accent2, 2=accent3, 3=monochrome, 4=rainbow
var nextFireworksTime = 0.5  # Time until next auto-trigger fireworks (in seconds)

# Particle systems (one per kanji character)
var particleSystems = ["p0", "p1", "p2", "p3", "p4", "p5", "p6", "p7"]

# Initialize displayChars with specific kanji for each particle effect
displayChars = ["ÁàÜ", "Á¨¶", "Èõ™", "ÁÅ´", "Êòü", "Èõ∑", "Èõ®", "Ëô´"]

# Initialize particle systems with different effects for each kanji
# All particles use foreground-only shader to only change foreground color

# System 0: Fireworks/Explosion
particleInit(particleSystems[0], 500)
particleConfigureExplosion(particleSystems[0])
particleSetShader(particleSystems[0], "foreground")
particleSetEmitRate(particleSystems[0], 0.0)  # Manual trigger only
particleSetEmitterPos(particleSystems[0], float(termWidth / 2), float(termHeight / 2))

# System 1: Matrix Rain with long trails
particleInit(particleSystems[1], 300)
particleConfigureMatrix(particleSystems[1], 15.0)
particleSetShader(particleSystems[1], "foreground")
particleSetTrailLength(particleSystems[1], 30)
particleSetEmitterPos(particleSystems[1], 0.0, 0.0)
particleSetEmitterSize(particleSystems[1], termWidth, 1.0)

# System 2: Snow
particleInit(particleSystems[2], 400)
particleConfigureSnow(particleSystems[2], 10.0)
particleSetShader(particleSystems[2], "foreground")
particleSetEmitterPos(particleSystems[2], 0.0, 0.0)
particleSetEmitterSize(particleSystems[2], termWidth, 1.0)
particleSetVelocityRange(particleSystems[2], 2.0, 0.25, 3.0, 0.5)

# System 3: Fire
particleInit(particleSystems[3], 600)
particleConfigureFire(particleSystems[3], 120.0)
particleSetShader(particleSystems[3], "foreground")
particleSetEmitterPos(particleSystems[3], 0.0, termHeight)
particleSetEmitterSize(particleSystems[3], termWidth, float(termHeight) / 2)
particleSetLifeRange(particleSystems[3], 3.0, 5.0)
particleSetVelocityRange(particleSystems[3], 0.0, -5.0, 0.0, -15.0)

# System 4: Sparkles
particleInit(particleSystems[4], 300)
particleConfigureSparkles(particleSystems[4], 30.0)
particleSetShader(particleSystems[4], "foreground")
particleSetEmitterPos(particleSystems[4], 0.0, 0.0)
particleSetEmitterSize(particleSystems[4], termWidth, termHeight)

# System 5: Colorblast (lightning-like)
particleInit(particleSystems[5], 400)
particleConfigureColorblast(particleSystems[5])
particleSetShader(particleSystems[5], "foreground")
particleSetEmitRate(particleSystems[5], 0.0)  # Start at zero, will pulse
particleSetEmitterSize(particleSystems[5], termWidth, termHeight)
particleSetEmitterPos(particleSystems[5], float(termWidth / 2), float(termHeight / 2))

# System 6: Rain
particleInit(particleSystems[6], 300)
particleConfigureRain(particleSystems[6], 40.0)
particleSetShader(particleSystems[6], "foreground")
particleSetEmitterPos(particleSystems[6], 0.0, 0.0)
particleSetEmitterSize(particleSystems[6], termWidth, 1.0)

# System 7: Bugs (organic movement with edge spawning and arcing motion)
particleInit(particleSystems[7], 200)
particleSetShader(particleSystems[7], "foreground")
particleSetEmitRate(particleSystems[7], 0.0)  # Manual emission only
particleSetTrailEnabled(particleSystems[7], true)
particleSetTrailLength(particleSystems[7], 10)  # 4-segment body
particleSetTrailSpacing(particleSystems[7], 0.8)  # Tight spacing
particleSetTrailFade(particleSystems[7], false)  # Solid body segments
particleSetLifeRange(particleSystems[7], 3.0, 5.0)  # Short lifetime - bugs disappear after crossing
particleSetTurbulence(particleSystems[7], 3.0)  # Light turbulence for slight wobble
particleSetDamping(particleSystems[7], 0.98)
particleSetEmitterPos(particleSystems[7], float(termWidth / 2), float(termHeight / 2))
particleSetEmitterSize(particleSystems[7], termWidth, termHeight)

# Bug spawning state
var bugTimer = 0.0
var bugSpawnInterval = 1.0

# Sparkles circular motion state
var sparklesAngle = 0.0
var sparklesRadius = float(termHeight / 3)
var sparklesCenterX = float(termWidth / 2)
var sparklesCenterY = float(termHeight / 2)
var sparklesAngularVel = 2.0  # radians per second
var sparklesPathChangeTime = 0.0  # Time when path should change
var sparklesPathDuration = 5.0  # seconds before changing path

# Lightning strike state
var lightningTimer = 0.0
var lightningStrikeInterval = 0.3  # seconds between strikes
var lightningIntensity = 0.0  # current emission intensity (0-1)
var lightningDecayRate = 8.0  # how fast intensity fades
var lightningStriking = false
var lightningX = float(termWidth / 2)
var lightningY = float(termHeight / 2)
var lightningSize = float(termHeight / 4)

# Set colors for all systems to use theme colors
var i = 0
while i < 8:
  particleSetForegroundFromStyle(particleSystems[i], getStyle("accent1"))
  i = i + 1

# Apply color mode to a system
proc applyColorMode(system: string) =
  if colorMode == 0:
    particleSetForegroundFromStyle(system, getStyle("accent1"))
  elif colorMode == 1:
    particleSetForegroundFromStyle(system, getStyle("accent2"))
  elif colorMode == 2:
    particleSetForegroundFromStyle(system, getStyle("accent3"))
  elif colorMode == 3:
    # default - use defaultStyle to reset to core monochrome
    particleSetForegroundFromStyle(system, getStyle("default"))
  elif colorMode == 4:
    # rainbow - full color range
    particleSetColorRange(system, 0, 0, 0, 255, 255, 255)

# Trigger fireworks at random position
proc triggerFireworks() =
  var randX = float(rand(3, termWidth - 3))
  var randY = float(rand(3, termHeight - 4))
  particleSetEmitterPos(particleSystems[0], randX, randY)
  particleSetLifeRange(particleSystems[0], rand(1.0, 3.0), rand(3.0, 10.0))
  particleEmit(particleSystems[0], rand(100, 200))
```

```nim on:input
# Handle input
if event.type == "mouse":
  var mouseAction = event.action
  
  if mouseAction == "press":
    # Get mouse position
    var mouseX = mouseX
    var mouseY = mouseY
    
    # Check if clicking on the character selection area (top line)
    if mouseY == 0:
      # Calculate which character was clicked (accounting for charWidth)
      # Characters are centered, so we need to find the start position
      var totalWidth = 8 * charWidth + 7  # 8 chars + 7 spaces
      var startX = (termWidth - totalWidth) / 2
      
      var i = 0
      while i < 8:
        var charX = startX + (i * (charWidth + 1))
        if mouseX >= charX and mouseX < charX + charWidth:
          # Check if clicking on the currently selected character - cycle color mode
          if i == selectedIndex:
            colorMode = colorMode + 1
            if colorMode > 4:
              colorMode = 0
            applyColorMode(particleSystems[selectedIndex])
          else:
            selectedIndex = i
            # Trigger fireworks for system 0 when selected
            if selectedIndex == 0:
              triggerFireworks()
            applyColorMode(particleSystems[selectedIndex])
          return true
        i = i + 1
  
  return false

elif event.type == "text":
  var key = event.text
  
  # Refresh display characters
  if key == "r" or key == "R":
    initDisplayChars()
    return true
  
  # Trigger effects
  if key == " ":
    # Space bar triggers effect for current system
    if selectedIndex == 0:
      triggerFireworks()  # Fireworks burst at random position
    return true
  
  return false

elif event.type == "key":
  if event.action == "press" or event.action == "repeat":
    var code = event.keyCode
    
    # Arrow keys using SDL3-compatible KEY_* constants
    if code == KEY_UP:  # Up - cycle color mode forward
      colorMode = colorMode + 1
      if colorMode > 4:
        colorMode = 0
      applyColorMode(particleSystems[selectedIndex])
      return true
    elif code == KEY_DOWN:  # Down - cycle color mode backward
      colorMode = colorMode - 1
      if colorMode < 0:
        colorMode = 4
      applyColorMode(particleSystems[selectedIndex])
      return true
    elif code == KEY_LEFT:  # Left
      selectedIndex = selectedIndex - 1
      if selectedIndex < 0:
        selectedIndex = 7
      # Trigger fireworks when selecting system 0
      if selectedIndex == 0:
        triggerFireworks()
      applyColorMode(particleSystems[selectedIndex])
      return true
    elif code == KEY_RIGHT:  # Right
      selectedIndex = selectedIndex + 1
      if selectedIndex > 7:
        selectedIndex = 0
      # Trigger fireworks when selecting system 0
      if selectedIndex == 0:
        triggerFireworks()
      applyColorMode(particleSystems[selectedIndex])
      return true
  
  return false

return false
```

```nim on:update
# Auto-trigger fireworks when system 0 is selected
var currentTime = getTime()
if selectedIndex == 0 and currentTime >= nextFireworksTime:
  triggerFireworks()
  # Next trigger in 0.3-2.3 seconds
  nextFireworksTime = currentTime + (0.3 + float(rand(200)) / 100.0)

# Update the currently selected particle system
# deltaTime is automatically injected by the runtime with the actual frame time

# Special handling for sparkles system - move in circular paths
if selectedIndex == 4:
  # Update circular motion
  sparklesAngle = sparklesAngle + (sparklesAngularVel * deltaTime)
  
  # Calculate new emitter position on circular path
  var sparklesX = sparklesCenterX + (sparklesRadius * cos(sparklesAngle))
  var sparklesY = sparklesCenterY + (sparklesRadius * sin(sparklesAngle))
  particleSetEmitterPos(particleSystems[4], sparklesX, sparklesY)
  
  # Change to new random circular path periodically
  if currentTime >= sparklesPathChangeTime:
    # Random new center point (avoiding edges)
    sparklesCenterX = float(rand(termWidth / 4, (termWidth * 3) / 4))
    sparklesCenterY = float(rand(termHeight / 4, (termHeight * 3) / 4))
    # Random radius
    sparklesRadius = float(rand(termHeight / 6, termHeight / 3))
    # Random angular velocity (speed and direction)
    sparklesAngularVel = float(rand(10, 40)) / 10.0  # 1-4 radians/sec
    if rand(2) == 0:
      sparklesAngularVel = -sparklesAngularVel  # Random direction
    # Random duration for next path
    sparklesPathDuration = 3.0 + float(rand(40)) / 10.0  # 3-7 seconds
    sparklesPathChangeTime = currentTime + sparklesPathDuration

# Special handling for lightning system - random strikes with pulsing intensity
if selectedIndex == 5:
  lightningTimer = lightningTimer + deltaTime
  
  # Check if it's time for a new lightning strike
  if lightningTimer >= lightningStrikeInterval:
    lightningTimer = 0.0
    lightningStriking = true
    lightningIntensity = 1.0
    
    # Random strike location
    lightningX = float(rand(termWidth / 8, (termWidth * 7) / 8))
    lightningY = float(rand(termHeight / 8, (termHeight * 7) / 8))
    
    # Random strike size (tighter for bolt-like, wider for area effect)
    lightningSize = float(rand(termHeight / 8, termHeight / 3))
    
    # Random next strike interval (make it unpredictable)
    lightningStrikeInterval = 0.1 + float(rand(30)) / 100.0  # 0.1-0.4 seconds
    
    # Sometimes add a second quick flash
    if rand(3) == 0:
      lightningStrikeInterval = 0.05 + float(rand(10)) / 100.0  # 0.05-0.15 seconds
  
  # Update lightning intensity (decay over time)
  if lightningStriking:
    lightningIntensity = lightningIntensity - (lightningDecayRate * deltaTime)
    if lightningIntensity <= 0.0:
      lightningIntensity = 0.0
      lightningStriking = false
  
  # Apply current lightning state
  particleSetEmitterPos(particleSystems[5], lightningX, lightningY)
  particleSetEmitterSize(particleSystems[5], lightningSize, lightningSize)
  
  # Set emission rate based on intensity (0 to 200)
  var emitRate = lightningIntensity * 200.0
  particleSetEmitRate(particleSystems[5], emitRate)

# Special handling for bug system - spawn bugs from edges
if selectedIndex == 7:
  bugTimer = bugTimer + deltaTime
  if bugTimer >= bugSpawnInterval:
    bugTimer = 0.0
    
    # Randomly select which edge to spawn from (0=top, 1=right, 2=bottom, 3=left)
    var edge = rand(4)
    
    # Random arc direction for variety
    var arcDir = float(rand(2) * 2 - 1)  # -1 or 1
    var gravityStrength = 12.0 + float(rand(10))  # 12-21 for varied arc curves
    particleSetTrailLength(particleSystems[7], rand(4, 12))
    
    if edge == 0:
      # Spawn from TOP edge
      var spawnX = float(rand(termWidth - 4) + 2)
      particleSetEmitterPos(particleSystems[7], spawnX, 1.0)
      var horizontalDir = float(rand(3) - 1) * 40.0
      particleSetVelocityRange(particleSystems[7], horizontalDir - 15.0, 80.0, horizontalDir + 15.0, 80.0)
      particleSetGravity(particleSystems[7], gravityStrength * arcDir)
    elif edge == 1:
      # Spawn from RIGHT edge
      var spawnY = float(rand(termHeight - 4) + 2)
      particleSetEmitterPos(particleSystems[7], float(termWidth - 2), spawnY)
      particleSetVelocityRange(particleSystems[7], -80.0, -15.0, -80.0, 15.0)
      particleSetGravity(particleSystems[7], gravityStrength * arcDir)
    elif edge == 2:
      # Spawn from BOTTOM edge
      var spawnX = float(rand(termWidth - 4) + 2)
      particleSetEmitterPos(particleSystems[7], spawnX, float(termHeight - 2))
      var horizontalDir = float(rand(3) - 1) * 40.0
      particleSetVelocityRange(particleSystems[7], horizontalDir - 15.0, -80.0, horizontalDir + 15.0, -80.0)
      particleSetGravity(particleSystems[7], gravityStrength * arcDir)
    else:
      # Spawn from LEFT edge
      var spawnY = float(rand(termHeight - 4) + 2)
      particleSetEmitterPos(particleSystems[7], 1.0, spawnY)
      particleSetVelocityRange(particleSystems[7], 80.0, -15.0, 80.0, 15.0)
      particleSetGravity(particleSystems[7], gravityStrength * arcDir)
    
    # Emit bugs
    particleEmit(particleSystems[7], rand(2, 10))
    
    # Vary spawn interval
    bugSpawnInterval = 0.5 + (float(rand(20)) / 80.0)

# Update particle physics
particleUpdate(particleSystems[selectedIndex], deltaTime)
```

```nim on:render
# Clear screen
clear()

# Fill entire background with static kanji characters
var y = 1
while y < termHeight - 1:
  var x = 0
  while x < termWidth:
    draw(0, x, y, getRandomKanji(x, y), styleBackground)
    x = x + charWidth
  y = y + 1

# Render the currently selected particle system
particleRender(particleSystems[selectedIndex], 0)

# Draw the 8 selectable characters at top center
var totalWidth = 8 * charWidth + 7  # 8 chars + 7 spaces between
var startX = (termWidth - totalWidth) / 2

var i = 0
while i < 8:
  var charX = startX + (i * (charWidth + 1))
  var style = styleUnselected
  if i == selectedIndex:
    style = styleSelected
  
  draw(0, charX, 0, displayChars[i], style)
  i = i + 1

# Draw effect names at bottom of screen
var effectNames = ["Fireworks", "Matrix", "Snow", "Fire", "Sparkles", "Lightning", "Rain", "Bugs"]
var effectName = effectNames[selectedIndex]

# Add color mode name
var colorModeNames = ["Accent1", "Accent2", "Accent3", "Monochrome", "Rainbow"]
var colorModeName = colorModeNames[colorMode]
var fullName = effectName & " | " & colorModeName

var nameX = (termWidth - len(fullName)) / 2
draw(0, nameX, termHeight - 1, fullName, styleSelected)
```
---
title: "Layer Effects Demo"
minWidth: 80
minHeight: 30
theme: "dracula"
---

# Layer Effects Demo

This demo showcases tstorie's layer effects system with automatic depth cueing and parallax scrolling.

**Controls:**
- **Arrow Keys**: Move camera
- **Space**: Toggle auto-depthing
- **1-4**: Toggle individual layers
- **R**: Reset camera
- **Q**: Quit

```nim on:init
# Create named layers with z-coordinates
addLayer("sky", -3)
addLayer("mountains", -2)
addLayer("trees", -1)
addLayer("player", 0)

# Camera position
var cameraX = 0.0
var cameraY = 0.0

# Layer visibility
var showSky = true
var showMountains = true
var showTrees = true
var showPlayer = true

# Auto-depthing toggle (start with it on to showcase the effect)
var autoDepthing = true
enableAutoDepthing(0.3, 1.0)

# Animation
var time = 0.0

echo "Layer effects demo initialized with named layers"
```

```nim on:update
# Advance animation time
time = time + 0.05
```

```nim on:render
clear("default")
clear("sky", true)
clear("mountains", true)
clear("trees", true)
clear("player", true)

let w = termWidth
let h = termHeight

# Safety check for minimum dimensions
if w < 10 or h < 10:
  drawLabel("default", 2, 2, "Terminal too small!", getStyle("error"))
  return

# Apply parallax offsets to create depth effect
setLayerOffset("sky", int(cameraX * 0.1), int(cameraY * 0.1))
setLayerOffset("mountains", int(cameraX * 0.3), int(cameraY * 0.2))
setLayerOffset("trees", int(cameraX * 0.6), int(cameraY * 0.4))
setLayerOffset("player", int(cameraX), int(cameraY))

# HUD on default layer (always on top, no offset)
fillBox("default", 0, 0, w, 3, "‚ïê", getStyle("primary"))
drawLabel("default", w div 2 - 15, 1, "LAYER EFFECTS DEMO", getStyle("warning"))

# Sky layer (z=-3, darkest with auto-depthing)
if showSky:
  # Stars
  let halfH = h div 2
  for i in 0..20:
    let x = (i * 17) mod w
    let y = (i * 13) mod halfH
    drawLabel("sky", x, y, "*", getStyle("warning"))

  
  # Moon
  drawLabel("sky", w - 15, 3, "O", getStyle("info"))

# Mountains layer (z=-2)
if showMountains:
  # Mountain silhouettes
  for x in 0..w-1:
    let mountain1 = int(sin(float(x) * 0.1) * 5.0 + 15.0)
    let mountain2 = int(sin(float(x) * 0.15 + 2.0) * 4.0 + 18.0)
    let peak = max(mountain1, mountain2)
    
    for y in peak..h-1:
      drawLabel("mountains", x, y, "‚ñì", getStyle("primary"))

# Trees layer (z=-1, closer)
if showTrees:
  # Animated swaying trees
  for i in 0..8:
    let baseX = i * 10 + 5
    let sway = int(sin(time * 2.0 + float(i)) * 2.0)
    let treeX = baseX + sway
    let treeY = h - 8
    
    # Tree trunk
    drawLabel("trees", treeX, treeY, "|", getStyle("warning"))
    drawLabel("trees", treeX, treeY + 1, "|", getStyle("warning"))
    
    # Tree foliage
    drawLabel("trees", treeX - 1, treeY - 1, "#", getStyle("success"))
    drawLabel("trees", treeX, treeY - 1, "#", getStyle("success"))
    drawLabel("trees", treeX + 1, treeY - 1, "#", getStyle("success"))
    drawLabel("trees", treeX, treeY - 2, "#", getStyle("success"))

# Player layer (z=0, foreground - full brightness)
if showPlayer:
  # Ground
  for x in 0..w-1:
    drawLabel("player", x, h - 3, "=", getStyle("dim"))
  
  # Player character (centered)
  let playerX = w div 2
  let playerY = h - 5
  let bounce = int(sin(time * 4.0) * 1.0)
  
  drawLabel("player", playerX, playerY + bounce, "@", getStyle("error"))
  
  # Shadow
  drawLabel("player", playerX, playerY + 1, ".", getStyle("dim"))

# Status bar
var status = "Auto-Depth: "
if autoDepthing:
  status = status & "ON (0.3-1.0)"
else:
  status = status & "OFF"
status = status & " | Layers: "
if showSky:
  status = status & "S"
else:
  status = status & "_"
if showMountains:
  status = status & "M"
else:
  status = status & "_"
if showTrees:
  status = status & "T"
else:
  status = status & "_"
if showPlayer:
  status = status & "P"
else:
  status = status & "_"
status = status & " | Cam: " & $int(cameraX) & "," & $int(cameraY)
drawLabel("default", 2, h - 1, status, getStyle("info"))

# Instructions
let controls = "‚Üê‚Üí‚Üë‚Üì:Move | Space:Toggle Depth | 1-4:Toggle Layers | R:Reset | Q:Quit"
drawLabel("default", w - controls.len - 2, h - 1, controls, getStyle("dim"))
```

```nim on:input
# Only handle key press events
if event.type != "key" or event.action != "press":
  return false

# Camera movement
if event.keyCode == 37:  # Left arrow
  cameraX -= 5.0
  return true
elif event.keyCode == 39:  # Right arrow
  cameraX += 5.0
  return true
elif event.keyCode == 38:  # Up arrow
  cameraY -= 3.0
  return true
elif event.keyCode == 40:  # Down arrow
  cameraY += 3.0
  return true

# Reset camera
if event.keyCode == 82 or event.keyCode == 114:  # 'R' or 'r'
  cameraX = 0.0
  cameraY = 0.0
  return true

# Toggle auto-depthing
if event.keyCode == 32:  # Space
  autoDepthing = not autoDepthing
  if autoDepthing:
    enableAutoDepthing(0.3, 1.0)
    echo "Auto-depthing: ON (0.3-1.0)"
  else:
    disableAutoDepthing()
    echo "Auto-depthing: OFF"
  return true

# Toggle layers
if event.keyCode == 49:  # '1' - Sky
  showSky = not showSky
  return true
elif event.keyCode == 50:  # '2' - Mountains
  showMountains = not showMountains
  return true
elif event.keyCode == 51:  # '3' - Trees
  showTrees = not showTrees
  return true
elif event.keyCode == 52:  # '4' - Player
  showPlayer = not showPlayer
  return true

# Quit
if event.keyCode == 81 or event.keyCode == 113:  # 'Q' or 'q'
  quit()

return false
```

## How It Works

### String-Based Layer API
This demo showcases the new string-based layer API:

```nim
# Create named layers
addLayer("sky", -3)
addLayer("mountains", -2)
addLayer("trees", -1)
addLayer("player", 0)

# Draw using layer names (no more index guessing!)
drawLabel("sky", x, y, "*", style)
fillBox("mountains", x, y, w, h, "‚ñì", style)
setLayerOffset("trees", offsetX, offsetY)
```

Much clearer than numeric indices!

### Auto-Depth Cueing
When `enableAutoDepthing(0.3, 1.0)` is called, tstorie automatically calculates brightness for each layer based on its z-coordinate:

- **Sky (z=-3)**: 30% brightness (very dark, atmospheric distance)
- **Mountains (z=-2)**: ~50% brightness (medium distance)
- **Trees (z=-1)**: ~75% brightness (close)
- **Player (z=0)**: 100% brightness (foreground, full detail)

This creates instant depth perception without manual tuning!

### Parallax Scrolling
Each layer moves at a different speed relative to the camera:

- **Sky**: 10% speed (barely moves)
- **Mountains**: 30% speed (slow)
- **Trees**: 60% speed (faster)
- **Player**: 100% speed (moves with camera)

This amplifies the depth effect created by the auto-depthing.

### Plugin Awareness
The demo calls `setLayerDisplacement()` for a wavy effect. If the `terminal_shaders` plugin isn't available, this call is silently ignored. The demo still works perfectly in minimal builds!

## Try It Yourself

1. **Move the camera** - Notice how layers scroll at different speeds
2. **Toggle auto-depthing** - See the dramatic difference in depth perception
3. **Toggle individual layers** - Understand how z-order works
4. **Compare**: Run this in a full build vs minimal build

The magic is that **ONE LINE** (`enableAutoDepthing`) gives you professional-looking depth effects!
---
targetFPS: 30
title: Layout Module Demo
---

# Layout Module Showcase

This demo shows the new layout module capabilities.

```nim on:render
# Clear screen
var w = termWidth
var h = termHeight
clear()

# Title bar - centered
draw(0, 0, 0, w, 1, title, "AlignCenter", "AlignTop", "WrapNone")
draw(0, 0, 1, w, 1, "‚îÄ")

# Create three columns to demonstrate horizontal alignment
var colWidth = (w div 3) - 2
var col1X = 1
var col2X = (w div 3) + 1
var col3X = ((w div 3) * 2) + 1
var startY = 3

# Column 1: Left-aligned text with word wrap
draw(0, col1X, startY - 1, "LEFT ALIGNED:")
var leftText = "This text demonstrates left alignment with automatic word wrapping when lines get too long for the column."
draw(0, col1X, startY, colWidth, 8, 
               leftText, "AlignLeft", "AlignTop", "WrapWord")

# Column 2: Center-aligned with vertical centering
draw(0, col2X, startY - 1, "CENTER:")
var centerText = "Centered both horizontally and vertically in the box!"
draw(0, col2X, startY, colWidth, 8,
               centerText, "AlignCenter", "AlignMiddle", "WrapWord")

# Column 3: Right-aligned
draw(0, col3X, startY - 1, "RIGHT ALIGNED:")
var rightText = "Right aligned text flows to the right edge of the column area."
draw(0, col3X, startY, colWidth, 8,
               rightText, "AlignRight", "AlignTop", "WrapWord")

# Separator
draw(0, 0, startY + 9, w, 1, "‚îÄ")

# Bottom section: Demonstrate ellipsis truncation
var bottomY = startY + 11
draw(0, 2, bottomY, "ELLIPSIS MODE (truncates long lines):")
var longText = "This is a very long line that will be truncated with ellipsis when it exceeds the available width"
draw(0, 2, bottomY + 1, w - 4, 1,
               longText, "AlignLeft", "AlignTop", "WrapEllipsis")

# Bottom right: Vertical alignment demo
var boxX = w - 22
var boxY = bottomY
draw(0, boxX, boxY, "VERTICAL ALIGN:")
draw(0, boxX, boxY + 1, 20, 5, "¬∑")
draw(0, boxX, boxY + 1, 20, 5,
               "BOTTOM", "AlignCenter", "AlignBottom", "WrapNone")

# Footer
var footer = "Frame: " & str(getFrameCount()) & " | Press Ctrl+C to exit"
draw(0, 0, h - 1, w, 1, footer, "AlignCenter", "AlignTop", "WrapNone")
```
---
title: "Magic Demo - Zero Boilerplate Particles"
theme: "neotopia"
targetFPS: 60
---

# ü™Ñ Welcome to Magic!

This demo shows how **magic blocks** eliminate boilerplate code by compressing and parameterizing reusable snippets.

Each particle system below is created with a single line of code!

# Firefly Swarm

Watch the fireflies gently drift around the screen using the native particle system:

```magic
eJxtUctOwzAQvOcrrHBpEZSoEhLlShEgIVQ1hV5j4m2yku1EzqZS+QPEgWM+gyN3PiVfQppXkzYXWzszO971nLEXTrgFtuCG0JeQsDmoyLJcVLEEFtcwS3YJgWKiICeW5XmeRsUifYsayWpUT0UxsmP7gk0dZ9zCLtCD4VukXUU6kz65Ri1a5pSecxWjDhrF7KbHrlLznkrQPjQvH7XfKyQCs4iSSrCREadRgag1CgrZFZuOu+gjYBBSCQ/5uPgBg0YDJn2DZ9zAkuugGXS/6/XRsG8gI7/4qI7uclr+Sn0dzl7fXchNvZ/993ueZ1959p1nn3n2Yx+E+xU6+RQpdqNMY8EJWvFrWVZyAZL4ChWcNBnQAkzbtCzLOqpK/A9VJckS
```

# Simple Display

A basic demo showing value substitution:

```magic myValue="999"
eJxTVgjOzC3ISVUISS0u4eJKSEjIy8xVyM+zyszLLOEqSyxSKAbLhyXmlKYq2CpYWlpypSZn5CsoQfVl5mWWKBQl5ikqcSUkJCCbUJSal5JaxJVSlFiuYaCjYAjFMI1liTmlqVYKSgpqCsUlRRpI1mhqgo0CAEATMQg=
```

# Parameterized Particles

Now with custom parameters - change the name, count, and speed:

```magic name="stars" count="150" speed="15.0"
eJx9ksFKw0AQhu95ijVeWmlqKQhaRCgqVVAoSWuPZk2m7UB2EzYbpYY8gHjwmMfw6N1HyZO4iTZ20+ptZ/f7f2b+nX0ypoIykCDwGfyykugFEBune5ZFnOloaN+Ph/bw1hkQrsAO8cKEyw6JI1C8ZZ0ZxlpE4lUsgZEnlEsSrX3jrmG4rsuRkZAPkKM0oh/BtSpaZpqWxllmdkiaVu5Z1q4ZB+RI0EeUK43sdXsaM0PuN4Ft6oKyCPmiAZ4ca9AkEQ9JANyDRm/VyI3eLhlKNeQ4jDV4HoRUttQDm6Gv0jgk/fbm7RXgYimr6112jvqM//x2eOk+NzgHm/KF7tIvMzlqZHIHQeipeLdxqx5ZP+86apbnSyr0PMzPj4Mify3ytyJ/KfJ385cvR/5rCdTebC5PEvlUQq2cVqWm9SGQdIIMtrQCuA+i1tpVqS/Ct+Y
```

# How It Works

Each magic block above:
1. **Compresses** the preset markdown (3 code blocks ‚Üí 1 line, ~70% smaller)
2. **Declares Parameters** via `<!-- MAGIC_PARAMS: ... -->` for safety
3. **Uses {{param}}** syntax to avoid accidental code conflicts
4. **Expands** at parse time with your custom parameter values
5. **Injects** the resulting code blocks into your document

**Zero boilerplate, pure magic!** ü™Ñ

---

## Creating Your Own Magic

See [MAGIC.md](../MAGIC.md) for the complete guide.

Quick start:

1. Create a preset with `<!-- MAGIC_PARAMS: name, count -->` declaration
2. Use `{{name}}` and `{{count}}` placeholders in your code
3. Validate: `./tools/magic validate preset.md`
4. Compress: `./tools/magic pack preset.md`
5. Use in documents with `magic name="fireflies" count="30"`

1. **Write your reusable code** with `{param}` placeholders:
   ```markdown
   ```nim on:init
   var {name}_x = {startX}
   ```
   ```

2. **Compress it:**
   ```bash
   nim c -r tools/magic.nim pack my-preset.md
   ```

3. **Use it anywhere:**
   ```markdown
   ```magic name="myThing" startX="10"
   <compressed-base64-here>
   ```
   ```

4. **Share it!** magic blocks are perfect for GitHub Gists.
---
title: "Minimal Test"
theme: "default"
---

```nim on:init
print "Init: Starting minimal test"
```

```nim on:render
# Clear and draw a simple message
clear()
draw(0, 5, 5, "Hello from exported tStorie!", defaultStyle())
draw(0, 5, 7, "Press Ctrl-C to exit", defaultStyle())
```
---
title: "Node-Based Particle System"
theme: "catppuccin"
minWidth: 80
minHeight: 24
---

# Node-Based Particle System

Welcome to the new graph-driven particle system! Instead of hardcoded behaviors,
particles now use composable node graphs from our primitives library.

**Controls:**
- **[Space]** - Pause/Resume
- **[1-6]** - Switch between demos
- **[Click left/right]** - Navigate demos
- **[Q]** - Quit

```nim on:init
# Initialize demo state
var frame = 0
var paused = 0
var currentDemo = 1
var numDemos = 6
var emitCounter = 0.0

# Create particle systems for each demo
particleInit("rain", 200)
particleInit("vortex", 300)
particleInit("explosion", 400)
particleInit("matrix", 100)
particleInit("custom", 200)
particleInit("ripple", 500)

# Demo 1: Rain with Graph-Based Motion
particleConfigureRain("rain", 50.0)
particleSetEmitterShape("rain", 1)
particleSetEmitterSize("rain", float(termWidth), 1.0)
particleSetEmitterPos("rain", 0.0, 0.0)

# Demo 2: Vortex - NEW graph-based circular motion
var centerX = float(termWidth) / 2.0
var centerY = float(termHeight) / 2.0
particleConfigureVortex("vortex", centerX, centerY, 1.0)
particleSetEmitterPos("vortex", centerX, centerY)

# Demo 3: Radial Explosion - NEW graph-based burst
particleConfigureRadialExplosion("explosion", centerX, centerY)

# Demo 4: Matrix Hybrid - NEW particles + spatial trails
particleConfigureMatrixHybrid("matrix", 20.0)
particleSetEmitterSize("matrix", float(termWidth), 1.0)
particleSetEmitterPos("matrix", 0.0, 0.0)

# Demo 5: Custom Multi-Force - NEW complex graph
particleConfigureCustomGraph("custom", 9.8, 3.0)
particleSetEmitterSize("custom", float(termWidth), 1.0)
particleSetEmitterPos("custom", float(termWidth) / 2.0, 0.0)

# Demo 6: Ripple Field - NEW pure spatial effect
particleConfigureRippleField("ripple")
particleSetEmitterSize("ripple", float(termWidth), 1.0)
particleSetEmitterPos("ripple", 0.0, 0.0)

# Build demo names array
var demoNames = []
demoNames = demoNames + ["1. Rain - Traditional (baseline)"]
demoNames = demoNames + ["2. Vortex - Graph Polar Motion"]
demoNames = demoNames + ["3. Explosion - Graph Radial Burst"]
demoNames = demoNames + ["4. Matrix - Hybrid Trails"]
demoNames = demoNames + ["5. Custom - Multi-Force Graph"]
demoNames = demoNames + ["6. Ripple - Spatial Field"]

print "Particle system initialized with 6 NEW graph-based demos"
```

```nim on:update
if paused == 0:
  frame = frame + 1
  
  var dt = 1.0 / 60.0
  
  # Only update the active particle system
  if currentDemo == 1:
    particleUpdate("rain", dt)
  elif currentDemo == 2:
    particleUpdate("vortex", dt)
  elif currentDemo == 3:
    emitCounter = emitCounter + dt
    if emitCounter > 2.0:
      var explodeX = float(10 + randInt(termWidth - 20))
      var explodeY = float(5 + randInt(termHeight - 10))
      particleSetEmitterPos("explosion", explodeX, explodeY)
      particleEmit("explosion", 80)
      emitCounter = 0.0
    particleUpdate("explosion", dt)
  elif currentDemo == 4:
    particleUpdate("matrix", dt)
  elif currentDemo == 5:
    particleUpdate("custom", dt)
  elif currentDemo == 6:
    particleUpdate("ripple", dt)
```

```nim on:render
# Clear screen
clear()

# Render the active demo
if currentDemo == 1:
  particleRender("rain", 0)
elif currentDemo == 2:
  particleRender("vortex", 0)
elif currentDemo == 3:
  particleRender("explosion", 0)
elif currentDemo == 4:
  particleRender("matrix", 0)
elif currentDemo == 5:
  particleRender("custom", 0)
elif currentDemo == 6:
  particleRender("ripple", 0)

# UI - Demo title
var titleStyle = defaultStyle()
titleStyle.fg = cyan()
titleStyle.bold = 1
var demoTitle = demoNames[currentDemo - 1]
draw(0, 2, 1, demoTitle, titleStyle)

# UI - Stats
var statsY = termHeight - 3
var statStyle = defaultStyle()
statStyle.fg = rgb(150, 150, 150)

var activeCount = 0
if currentDemo == 1:
  activeCount = particleGetCount("rain")
elif currentDemo == 2:
  activeCount = particleGetCount("vortex")
elif currentDemo == 3:
  activeCount = particleGetCount("explosion")
elif currentDemo == 4:
  activeCount = particleGetCount("matrix")
elif currentDemo == 5:
  activeCount = particleGetCount("custom")
elif currentDemo == 6:
  activeCount = particleGetCount("ripple")

var statsText = "Active Particles: " & $activeCount & " | Frame: " & $frame
if paused == 1:
  statsText = statsText & " [PAUSED]"
draw(0, 2, statsY, statsText, statStyle)

# UI - Controls
var ctrlStyle = defaultStyle()
ctrlStyle.fg = rgb(100, 100, 100)
draw(0, 2, statsY + 1, "Space: Pause | 1-6: Switch | Click L/R: Navigate | Q: Quit", ctrlStyle)

# Demo-specific information
var infoY = 3
var infoStyle = defaultStyle()
infoStyle.fg = rgb(180, 180, 180)

if currentDemo == 1:
  draw(0, 2, infoY, "Rain uses a motion graph: gravity + noise-based wind", infoStyle)
  draw(0, 2, infoY + 1, "Graph nodes: constant(15) + noise(fractal) ‚Üí velocity", infoStyle)
  
elif currentDemo == 2:
  draw(0, 2, infoY, "Vortex uses polar coordinates for circular motion", infoStyle)
  draw(0, 2, infoY + 1, "Graph nodes: polar(angle) + wave(cos) ‚Üí tangent force", infoStyle)
  
elif currentDemo == 3:
  draw(0, 2, infoY, "Radial explosion from random points every 2 seconds", infoStyle)
  draw(0, 2, infoY + 1, "Graph nodes: polar(angle, dist) + decay ‚Üí radial force", infoStyle)
  
elif currentDemo == 4:
  draw(0, 2, infoY, "Matrix effect - particles leave trails using spatial graphs", infoStyle)
  draw(0, 2, infoY + 1, "Hybrid mode: particle motion + buffer fade effects", infoStyle)
  
elif currentDemo == 5:
  draw(0, 2, infoY, "Complex behavior: gravity + wind + sine wave oscillation", infoStyle)
  draw(0, 2, infoY + 1, "Multiple forces combined in a single motion graph", infoStyle)
  
elif currentDemo == 6:
  draw(0, 2, infoY, "Ripple displacement field - particles distorted by water-like waves", infoStyle)
  draw(0, 2, infoY + 1, "Spatial graph: polar(distance) + wave(sin) ‚Üí buffer displacement", infoStyle)
```

```nim on:input
if event.type == "text":
  var key = event.text
  
  # Space - pause/unpause
  if key == " ":
    if paused == 0:
      paused = 1
    else:
      paused = 0
  
  # Q - quit
  if key == "q" or key == "Q":
    stop()

if event.type == "key":
  var key = event.key
  # Number keys - switch demo
  if key == "1":
    currentDemo = 1
    particleClear("rain")
  if key == "2":
    currentDemo = 2
    particleClear("vortex")
  if key == "3":
    currentDemo = 3
    particleClear("explosion")
    emitCounter = 0.0
  if key == "4":
    currentDemo = 4
    particleClear("matrix")
  if key == "5":
    currentDemo = 5
    particleClear("custom")
  if key == "6":
    currentDemo = 6
    particleClear("ripple")

if event.type == "mouse":
  if event.action == "press":
    var mouseX = event.x
    var leftThird = termWidth / 3
    var rightThird = (termWidth * 2) / 3
    
    if mouseX < leftThird:
      # Click on left side - previous demo
      currentDemo = currentDemo - 1
      if currentDemo < 1:
        currentDemo = numDemos
      if currentDemo == 1:
        particleClear("rain")
      elif currentDemo == 2:
        particleClear("vortex")
      elif currentDemo == 3:
        particleClear("explosion")
        emitCounter = 0.0
      elif currentDemo == 4:
        particleClear("matrix")
      elif currentDemo == 5:
        particleClear("custom")
      elif currentDemo == 6:
        particleClear("ripple")
    elif mouseX > rightThird:
      # Click on right side - next demo
      currentDemo = currentDemo + 1
      if currentDemo > numDemos:
        currentDemo = 1
      if currentDemo == 1:
        particleClear("rain")
      elif currentDemo == 2:
        particleClear("vortex")
      elif currentDemo == 3:
        particleClear("explosion")
        emitCounter = 0.0
      elif currentDemo == 4:
        particleClear("matrix")
      elif currentDemo == 5:
        particleClear("custom")
      elif currentDemo == 6:
        particleClear("ripple")
```

## Technical Details

### What Makes This Different?

**Old System:** Hardcoded parameters
```nim
ps.gravity = 9.8
ps.turbulence = 3.0
ps.windForce = (2.0, 0.0)
```

**New System:** Composable graph nodes
```nim
var graph = newGraph()
let gravity = graph.constant(9.8)
let noise = graph.noise("fractal")
let wind = graph.math("mul")
noise ‚Üí wind ‚Üê constant(3.0)
gravity + wind ‚Üí totalForce ‚Üí output
```

### Available Primitives

**Motion Nodes:**
- Constants, inputs (position, velocity, age)
- Math ops (add, mul, map, clamp)
- Waves (sin, cos, saw, square)
- Noise (white, fractal, perlin)
- Polar coordinates (angle, distance)

**Effect Modes:**
1. **pemParticles** - Traditional particles with graph behavior
2. **pemSpatialField** - No particles, pure buffer effects
3. **pemHybrid** - Particles + spatial effects combined

### Use Cases

**Gameplay:**
- Fire/smoke with realistic physics
- Magic effects with custom motion
- Weather systems with layered complexity

**Visuals:**
- Dynamic backgrounds
- Transitions and reveals
- Data visualization particles

**Audio:**
- Spectrum analyzers
- Beat-reactive effects
- Sound-driven animations

Try switching between demos to see the variety of effects possible with the
same unified system!
---
title: "Creative Particle Effects Demo"
---

# Creative Particle Effects Demo

Advanced particle effects showcasing shader-based rendering with creative visual styles.

```nim on:init
# Get theme background color
var bgStyle = getStyle("default")
var bgR = int(bgStyle.bg.r)
var bgG = int(bgStyle.bg.g)
var bgB = int(bgStyle.bg.b)

# Initialize particle systems for different effects
particleInit("matrix", 800)
particleInit("corruption", 400)
particleInit("static", 600)
particleInit("glow", 300)
particleInit("scanlines", 200)
particleInit("bugs", 150)

# Set background color to match theme for all systems
var systems = @["matrix", "corruption", "static", "glow", "scanlines", "bugs"]
for sys in systems:
  particleSetBackgroundColor(sys, bgR, bgG, bgB)

# Configure Matrix effect (falling characters)
particleConfigureMatrix("matrix", 50.0)
particleSetEmitterPos("matrix", float(termWidth / 2), 0.0)
particleSetEmitterSize("matrix", float(termWidth), 1.0)

# Configure Corruption effect (glitchy spreading)
particleInit("corruption", 300)
particleSetEmitterPos("corruption", float(termWidth / 2), float(termHeight / 2))
particleSetEmitRate("corruption", 0.0)  # Manual emission only
particleSetVelocityRange("corruption", -20.0, -20.0, 20.0, 20.0)
particleSetLifeRange("corruption", 0.8, 1.5)
particleSetGravity("corruption", 0.0)
particleSetDamping("corruption", 0.3)

# Configure Static effect (random noise)
particleInit("static", 500)
particleSetEmitterPos("static", float(termWidth / 2), float(termHeight / 2))
particleSetEmitterSize("static", float(termWidth), float(termHeight))
particleSetEmitRate("static", 100.0)
particleSetVelocityRange("static", -5.0, -5.0, 5.0, 5.0)
particleSetLifeRange("static", 0.1, 0.3)
particleSetGravity("static", 0.0)
particleSetDamping("static", 0.95)

# Configure Glow effect (bright additive particles)
particleConfigureSparkles("glow", 40.0)
particleSetEmitterPos("glow", float(termWidth / 2), float(termHeight / 2))
particleSetLifeRange("glow", 1.5, 2.5)

# Configure Scanlines effect (horizontal sweeping lines)
particleInit("scanlines", 150)
particleSetEmitterPos("scanlines", 0.0, 0.0)
particleSetEmitterSize("scanlines", 1.0, float(termHeight))
particleSetEmitRate("scanlines", 5.0)
particleSetVelocityRange("scanlines", 30.0, -5.0, 50.0, 5.0)
particleSetLifeRange("scanlines", 2.0, 3.0)
particleSetGravity("scanlines", 0.0)
particleSetDamping("scanlines", 0.98)

# Configure Bugs (crawling entities)
particleConfigureBugs("bugs", 20.0)
particleSetEmitterPos("bugs", float(termWidth / 2), float(termHeight / 2))
particleSetEmitterSize("bugs", float(termWidth), float(termHeight))

var currentEffect = "matrix"
var showHelp = true
var mouseX = float(termWidth / 2)
var mouseY = float(termHeight / 2)
var autoEmit = true
var lastBurstTime = 0.0
var burstInterval = 2.0
var effectIntensity = 1.0
```

```nim on:update
# Auto-burst for corruption effect
if currentEffect == "corruption" and autoEmit:
  lastBurstTime = lastBurstTime + deltaTime
  if lastBurstTime >= burstInterval:
    lastBurstTime = 0.0
    var randomX = float(rand(termWidth))
    var randomY = float(rand(termHeight))
    particleSetEmitterPos("corruption", randomX, randomY)
    particleEmit("corruption", int(30.0 * effectIntensity))

# Update emitter positions for responsive effects
particleSetEmitterPos("matrix", float(termWidth / 2), 0.0)
particleSetEmitterSize("matrix", float(termWidth), 1.0)
particleSetEmitterPos("glow", mouseX, mouseY)
particleSetEmitterSize("static", float(termWidth), float(termHeight))
particleSetEmitterSize("scanlines", 1.0, float(termHeight))

# Update active effect
if currentEffect == "matrix":
  particleUpdate("matrix", deltaTime)
elif currentEffect == "corruption":
  particleUpdate("corruption", deltaTime)
elif currentEffect == "static":
  particleUpdate("static", deltaTime)
elif currentEffect == "glow":
  particleUpdate("glow", deltaTime)
elif currentEffect == "scanlines":
  particleUpdate("scanlines", deltaTime)
elif currentEffect == "bugs":
  particleUpdate("bugs", deltaTime)
```

```nim on:render
# Clear screen
clear()

# Render active particle effect
if currentEffect == "matrix":
  particleRender("matrix", 0)
elif currentEffect == "corruption":
  particleRender("corruption", 0)
elif currentEffect == "static":
  particleRender("static", 0)
elif currentEffect == "glow":
  particleRender("glow", 0)
elif currentEffect == "scanlines":
  particleRender("scanlines", 0)
elif currentEffect == "bugs":
  particleRender("bugs", 0)

# Show UI overlay
var titleStyle = getStyle("heading")
var infoStyle = getStyle("info")
var activeStyle = getStyle("success")
var dimStyle = getStyle("dim")

draw(0, 2, 1, "CREATIVE PARTICLE EFFECTS", titleStyle)

if showHelp:
  draw(0, 2, 3, "Effects:", infoStyle)
  draw(0, 4, 5, "[1] Matrix - Falling characters", getStyle("default"))
  draw(0, 4, 6, "[2] Corruption - Glitchy spread", getStyle("default"))
  draw(0, 4, 7, "[3] Static - TV noise", getStyle("default"))
  draw(0, 4, 8, "[4] Glow - Additive sparkles", getStyle("default"))
  draw(0, 4, 9, "[5] Scanlines - CRT sweep", getStyle("default"))
  draw(0, 4, 10, "[6] Bugs - Crawling entities", getStyle("default"))
  
  draw(0, 2, 12, "Controls:", infoStyle)
  draw(0, 4, 13, "[C] Clear particles", getStyle("default"))
  draw(0, 4, 14, "[A] Toggle auto-emit", getStyle("default"))
  draw(0, 4, 15, "[H] Toggle help", getStyle("default"))
  draw(0, 4, 16, "[+/-] Adjust intensity", getStyle("default"))
  draw(0, 4, 17, "Click to spawn burst!", activeStyle)

# Show stats
var activeCount = particleGetCount(currentEffect)
var statsY = termHeight - 4

var effectDesc = ""
if currentEffect == "matrix":
  effectDesc = "Digital rain cascading down the screen"
elif currentEffect == "corruption":
  effectDesc = "Reality fragmenting and glitching out"
elif currentEffect == "static":
  effectDesc = "Analog interference patterns"
elif currentEffect == "glow":
  effectDesc = "Ethereal light trails (follows mouse)"
elif currentEffect == "scanlines":
  effectDesc = "Retro CRT horizontal lines"
elif currentEffect == "bugs":
  effectDesc = "Crawling terminal creatures"

draw(0, 2, statsY, "Active: " & str(activeCount) & " particles", infoStyle)
draw(0, 2, statsY + 1, "Effect: " & currentEffect & " | Auto: " & (if autoEmit: "ON" else: "OFF"), activeStyle)
draw(0, 2, statsY + 2, "Intensity: " & str(int(effectIntensity * 100.0)) & "%", infoStyle)
draw(0, 2, statsY + 3, effectDesc, dimStyle)
```

```nim on:input
# Handle keyboard input
if event.type == "text":
  var key = event.text
  
  if key == "1":
    particleClear(currentEffect)
    currentEffect = "matrix"
    return true
  
  elif key == "2":
    particleClear(currentEffect)
    currentEffect = "corruption"
    lastBurstTime = 0.0
    return true
  
  elif key == "3":
    particleClear(currentEffect)
    currentEffect = "static"
    return true
  
  elif key == "4":
    particleClear(currentEffect)
    currentEffect = "glow"
    return true
  
  elif key == "5":
    particleClear(currentEffect)
    currentEffect = "scanlines"
    return true
  
  elif key == "6":
    particleClear(currentEffect)
    currentEffect = "bugs"
    return true
  
  elif key == "c":
    particleClear("matrix")
    particleClear("corruption")
    particleClear("static")
    particleClear("glow")
    particleClear("scanlines")
    particleClear("bugs")
    return true
  
  elif key == "a":
    autoEmit = not autoEmit
    return true
  
  elif key == "h":
    showHelp = not showHelp
    return true
  
  elif key == "+":
    effectIntensity = min(2.0, effectIntensity + 0.1)
    # Adjust emission rates based on intensity
    particleSetEmitRate("matrix", 50.0 * effectIntensity)
    particleSetEmitRate("static", 100.0 * effectIntensity)
    particleSetEmitRate("glow", 40.0 * effectIntensity)
    particleSetEmitRate("scanlines", 5.0 * effectIntensity)
    particleSetEmitRate("bugs", 20.0 * effectIntensity)
    return true
  
  elif key == "-":
    effectIntensity = max(0.1, effectIntensity - 0.1)
    # Adjust emission rates based on intensity
    particleSetEmitRate("matrix", 50.0 * effectIntensity)
    particleSetEmitRate("static", 100.0 * effectIntensity)
    particleSetEmitRate("glow", 40.0 * effectIntensity)
    particleSetEmitRate("scanlines", 5.0 * effectIntensity)
    particleSetEmitRate("bugs", 20.0 * effectIntensity)
    return true

# Handle mouse input
if event.type == "mouse":
  mouseX = float(event.x)
  mouseY = float(event.y)
  
  # Update glow emitter to follow mouse
  if currentEffect == "glow":
    particleSetEmitterPos("glow", mouseX, mouseY)
  
  # Mouse click spawns effect-specific bursts
  if event.action == "press":
    if currentEffect == "matrix":
      # Spawn extra column of matrix particles
      particleSetEmitterPos("matrix", mouseX, 0.0)
      particleEmit("matrix", int(50.0 * effectIntensity))
      particleSetEmitterPos("matrix", float(termWidth / 2), 0.0)
    
    elif currentEffect == "corruption":
      # Spawn corruption burst at cursor
      particleSetEmitterPos("corruption", mouseX, mouseY)
      particleEmit("corruption", int(40.0 * effectIntensity))
    
    elif currentEffect == "static":
      # Concentrated static burst
      particleSetEmitterPos("static", mouseX, mouseY)
      particleSetEmitterSize("static", 10.0, 10.0)
      particleEmit("static", int(100.0 * effectIntensity))
      particleSetEmitterSize("static", float(termWidth), float(termHeight))
    
    elif currentEffect == "glow":
      # Extra bright burst
      particleEmit("glow", int(50.0 * effectIntensity))
    
    elif currentEffect == "scanlines":
      # Spawn scanline from cursor
      particleSetEmitterPos("scanlines", mouseX, mouseY)
      particleEmit("scanlines", int(20.0 * effectIntensity))
      particleSetEmitterPos("scanlines", 0.0, 0.0)
    
    elif currentEffect == "bugs":
      # Spawn bugs at cursor
      particleSetEmitterPos("bugs", mouseX, mouseY)
      particleEmit("bugs", int(10.0 * effectIntensity))
      particleSetEmitterPos("bugs", float(termWidth / 2), float(termHeight / 2))
    
    return true

return false
```

---

## Effect Descriptions

### Matrix
The classic "digital rain" effect with falling green characters. Creates columns of cascading text that evoke the aesthetic of terminal-based sci-fi interfaces.

**Visual Style:** Bright green characters falling vertically with varying speeds.

### Corruption
Simulates digital corruption spreading across the screen. Particles spawn in bursts and create glitchy, fragmenting patterns that feel like reality breaking down.

**Visual Style:** Erratic movement, rapid flickering, chaotic spread patterns.

### Static
TV-style static noise with rapid particle spawning and decay. Creates analog interference patterns reminiscent of old CRT displays.

**Visual Style:** High-frequency random character placement with very short lifetimes.

### Glow
Additive sparkle particles that create bright, luminous trails. Follows mouse position for interactive light painting effects.

**Visual Style:** Bright colors with slow-moving particles that create ethereal light trails.

### Scanlines
Horizontal sweeping lines that mimic CRT scanline artifacts. Creates a retro terminal aesthetic with periodic horizontal movements.

**Visual Style:** Fast horizontal movement, periodic emission, creates classic retro display look.

### Bugs
Crawling entities with erratic movement patterns. Particles behave like small creatures exploring the screen with natural-looking locomotion.

**Visual Style:** Random walk patterns with directional changes, persistent presence.

---

## Shader Integration Notes

These effects demonstrate different rendering approaches:

- **Matrix/Static**: Character-only replacement shaders
- **Glow**: Additive color blending for brightness
- **Corruption**: Color modulation for glitch effects
- **Scanlines**: Foreground-only rendering to preserve background
- **Bugs**: Full cell replacement with character animation

Future versions will allow runtime shader switching to create hybrid effects (e.g., glowing matrix rain with scanline overlays).

---

## Performance Tips

**For best performance:**
1. Adjust intensity with +/- keys to find optimal particle count for your terminal
2. Disable auto-emit (A key) for manual burst control
3. Clear particles (C key) before switching effects
4. Static effect is most intensive - reduce intensity if needed

**Typical performance:**
- Matrix: 800 particles @ 60 FPS
- Static: 500-600 particles @ 60 FPS  
- Corruption: 300 particles @ 60 FPS (burst mode)
- Glow: 300 particles @ 60 FPS
- Scanlines: 150-200 particles @ 60 FPS
- Bugs: 100-150 particles @ 60 FPS

---

## Creative Combinations

Try these effect parameters for unique visuals:

**Slow-motion Matrix:**
```nim
particleSetGravity("matrix", 20.0)  # Slower fall
particleSetLifeRange("matrix", 5.0, 8.0)  # Longer trails
```

**Explosive Corruption:**
```nim
particleSetVelocityRange("corruption", -80.0, -80.0, 80.0, 80.0)  # Faster spread
particleSetLifeRange("corruption", 0.3, 0.6)  # Quick bursts
```

**Thick Static:**
```nim
particleSetEmitRate("static", 300.0)  # Dense noise
particleSetLifeRange("static", 0.2, 0.4)  # Persistent
```
---
title: "Particle System Demo"
---

# Particle System Demo

High-performance native particle system capable of 1000+ particles at 60 FPS.

```nim on:init
# Get theme background color
var bgStyle = getStyle("default")
var bgR = int(bgStyle.bg.r)
var bgG = int(bgStyle.bg.g)
var bgB = int(bgStyle.bg.b)

# Initialize all particle systems
particleInit("snow", 500)
particleInit("fire", 300)
particleInit("rain", 400)
particleInit("sparkles", 300)
particleInit("explosion", 200)
particleInit("colorblast", 300)

# Set background color to match theme for all systems
var systems = @["snow", "fire", "rain", "sparkles", "explosion", "colorblast"]
for sys in systems:
  particleSetBackgroundColor(sys, bgR, bgG, bgB)

# Configure snow (with collision detection)
particleConfigureSnow("snow", 40.0)
particleSetEmitterPos("snow", float(termWidth / 2), 0.0)
particleSetEmitterSize("snow", float(termWidth), 1.0)
particleSetCollision("snow", true, 2)  # 2 = stick
particleSetStickChar("snow", ".")

# Configure fire
particleConfigureFire("fire", 80.0)
particleSetEmitterPos("fire", float(termWidth / 2), float(termHeight - 1))
particleSetEmitterSize("fire", 20.0, 1.0)

# Configure rain
particleConfigureRain("rain", 60.0)
particleSetEmitterPos("rain", 0.0, 0.0)
particleSetEmitterSize("rain", float(termWidth), 1.0)
particleSetCollision("rain", true, 3)  # 3 = destroy on collision

# Configure sparkles
particleConfigureSparkles("sparkles", 30.0)
particleSetEmitterPos("sparkles", float(termWidth / 2), float(termHeight / 2))

# Configure explosion (manual emission only)
particleConfigureExplosion("explosion")

# Configure colorblast (manual emission only)
particleConfigureColorblast("colorblast")

var currentEffect = "fire"
var showHelp = true
var mouseX = float(termWidth / 2)
var mouseY = float(termHeight / 2)
var mousePressed = false
var lastClickX = 0
var lastClickY = 0
var clickCount = 0
var particlesOnTop = false  # Toggle for rendering particles in front or behind UI
```

```nim on:update
# Update emitter positions to follow terminal size
particleSetEmitterPos("fire", float(termWidth / 2), float(termHeight - 1))
particleSetEmitterPos("snow", float(termWidth / 2), 0.0)
particleSetEmitterSize("snow", float(termWidth), 1.0)
particleSetEmitterPos("rain", 0.0, 0.0)
particleSetEmitterSize("rain", float(termWidth), 1.0)
particleSetEmitterPos("sparkles", mouseX, mouseY)

# Update only the active particle system
if currentEffect == "snow":
  particleUpdate("snow", deltaTime)
elif currentEffect == "fire":
  particleUpdate("fire", deltaTime)
elif currentEffect == "rain":
  particleUpdate("rain", deltaTime)
elif currentEffect == "sparkles":
  particleUpdate("sparkles", deltaTime)
elif currentEffect == "explosion":
  particleUpdate("explosion", deltaTime)
elif currentEffect == "colorblast":
  particleUpdate("colorblast", deltaTime)
```

```nim on:render
# Clear screen
clear()

# Render particles behind UI (if not on top)
if not particlesOnTop:
  if currentEffect == "snow":
    particleRender("snow", 0)
  elif currentEffect == "fire":
    particleRender("fire", 0)
  elif currentEffect == "rain":
    particleRender("rain", 0)
  elif currentEffect == "sparkles":
    particleRender("sparkles", 0)
  elif currentEffect == "explosion":
    particleRender("explosion", 0)
  elif currentEffect == "colorblast":
    particleRender("colorblast", 0)

# Show UI
var titleStyle = getStyle("heading")
var infoStyle = getStyle("info")
var activeStyle = getStyle("success")

draw(0, 2, 1, "PARTICLE SYSTEM DEMO", titleStyle)

if showHelp:
  draw(0, 2, 3, "Controls:", infoStyle)
  draw(0, 4, 5, "[1] Snow effect (collision)", getStyle("default"))
  draw(0, 4, 6, "[2] Fire effect", getStyle("default"))
  draw(0, 4, 7, "[3] Rain effect", getStyle("default"))
  draw(0, 4, 8, "[4] Sparkles (follows mouse)", getStyle("default"))
  draw(0, 4, 9, "[5] Explosion (click to burst)", getStyle("default"))
  draw(0, 4, 10, "[6] Colorblast (click to paint)", getStyle("default"))
  draw(0, 4, 11, "[C] Clear particles", getStyle("default"))
  draw(0, 4, 12, "[H] Toggle help", getStyle("default"))
  draw(0, 4, 13, "[Z] Toggle depth (particles on top/behind)", getStyle("default"))
  draw(0, 4, 14, "Click anywhere to spawn effects!", activeStyle)

# Show stats
var activeCount = particleGetCount(currentEffect)
var statsY = termHeight - 3

draw(0, 2, statsY, "Active: " & str(activeCount), infoStyle)
draw(0, 2, statsY + 1, "Effect: " & currentEffect & " | Depth: " & (if particlesOnTop: "FRONT" else: "BACK"), activeStyle)
draw(0, 2, statsY + 2, "Clicks: " & str(clickCount) & " Last: (" & str(lastClickX) & ", " & str(lastClickY) & ")", infoStyle)

# Render particles in front of UI (if on top)
if particlesOnTop:
  if currentEffect == "snow":
    particleRender("snow", 0)
  elif currentEffect == "fire":
    particleRender("fire", 0)
  elif currentEffect == "rain":
    particleRender("rain", 0)
  elif currentEffect == "sparkles":
    particleRender("sparkles", 0)
  elif currentEffect == "explosion":
    particleRender("explosion", 0)
  elif currentEffect == "colorblast":
    particleRender("colorblast", 0)
```

```nim on:input
# Handle keyboard input
if event.type == "text":
  var key = event.text
  if key == "1":
    particleClear(currentEffect)  # Clear old effect
    currentEffect = "snow"
    return true
  
  elif key == "2":
    particleClear(currentEffect)  # Clear old effect
    currentEffect = "fire"
    return true
  
  elif key == "3":
    particleClear(currentEffect)  # Clear old effect
    currentEffect = "rain"
    return true
  
  elif key == "4":
    particleClear(currentEffect)  # Clear old effect
    currentEffect = "sparkles"
    return true
  
  elif key == "5":
    # Switch to explosion mode and emit initial burst
    particleClear(currentEffect)  # Clear old effect
    currentEffect = "explosion"
    particleSetEmitterPos("explosion", float(termWidth / 2), float(termHeight / 2))
    particleEmit("explosion", 100)
    return true
  
  elif key == "6":
    # Switch to colorblast mode and emit initial burst
    particleClear(currentEffect)  # Clear old effect
    currentEffect = "colorblast"
    particleSetEmitterPos("colorblast", float(termWidth / 2), float(termHeight / 2))
    particleEmit("colorblast", 150)
    return true
  
  elif key == "c":
    particleClear("snow")
    particleClear("fire")
    particleClear("rain")
    particleClear("sparkles")
    particleClear("explosion")
    particleClear("colorblast")
    return true
  
  elif key == "h":
    showHelp = not showHelp
    return true
  
  elif key == "z":
    particlesOnTop = not particlesOnTop
    return true

# Handle mouse input
if event.type == "mouse":
  mouseX = float(event.x)
  mouseY = float(event.y)
  
  # Update sparkles emitter position
  if currentEffect == "sparkles":
    particleSetEmitterPos("sparkles", mouseX, mouseY)
  
  # Mouse click actions
  if event.action == "press":
    mousePressed = true
    lastClickX = int(mouseX)
    lastClickY = int(mouseY)
    clickCount = clickCount + 1
    
    # Spawn effects based on current mode
    if currentEffect == "explosion":
      particleSetEmitterPos("explosion", mouseX, mouseY)
      particleEmit("explosion", 100)
    
    elif currentEffect == "colorblast":
      particleSetEmitterPos("colorblast", mouseX, mouseY)
      particleEmit("colorblast", 150)
    
    elif currentEffect == "sparkles":
      # Extra burst on click
      particleEmit("sparkles", 30)
    
    elif currentEffect == "fire":
      # Spawn fire at mouse position
      particleSetEmitterPos("fire", mouseX, mouseY)
      particleEmit("fire", 50)
      particleSetEmitterPos("fire", float(termWidth / 2), float(termHeight - 1))
    
    return true
  
  elif event.action == "release":
    mousePressed = false
    return true

return false
```

---

## Performance Notes

This particle system is **100x faster** than script-based particle loops because:

1. **Native iteration** - All particles updated in tight Nim loop
2. **Zero boundary crossings** - No per-particle function calls to nimini
3. **Efficient memory** - Particle recycling, no allocations during update
4. **Optimized collision** - Direct buffer queries, no string conversions

**Real-world performance:**
- **Scripted approach:** 20 particles @ 60 FPS
- **Native system:** 2000+ particles @ 60 FPS

## Features Demonstrated

### All Particle Effects
1. **Snow** - Gentle falling with collision detection and sticking
2. **Fire** - Rising flames with turbulence and fade-out
3. **Rain** - Fast vertical drops that destroy on collision
4. **Sparkles** - Colorful bursts that follow mouse position
5. **Explosion** - Radial burst on mouse click
6. **Colorblast** - Paints existing cells with vibrant colors

### Mouse Interaction
- **Move mouse** - Sparkles follow cursor in real-time
- **Click** - Trigger explosions or colorblasts at cursor position
- **Click in fire mode** - Spawn temporary fire bursts

### Collision Detection
- **Snow** - Sticks to surfaces and accumulates
- **Rain** - Destroys on impact with obstacles

## API Reference

### Initialization
- `particleInit(name, maxParticles)` - Create particle system
- `particleClear(name)` - Remove all particles

### Update/Render
- `particleUpdate(name, deltaTime)` - Update physics (call in on:update)
- `particleRender(name, layerId)` - Render to layer (call in on:render)
- `particleEmit(name, count)` - Manually emit particles

### Environmental Parameters (Mutable!)
- `particleSetGravity(name, gravity)` - Vertical acceleration
- `particleSetWind(name, windX, windY)` - Constant force
- `particleSetTurbulence(name, strength)` - Noise-based chaos
- `particleSetDamping(name, factor)` - Air resistance (0-1)

### Emitter Configuration
- `particleSetEmitterPos(name, x, y)` - Spawn position
- `particleSetEmitRate(name, ratePerSec)` - Auto-emission rate
- `particleSetVelocityRange(name, minX, minY, maxX, maxY)` - Spawn velocities
- `particleSetLifeRange(name, minLife, maxLife)` - Spawn lifetimes

### Collision Detection
- `particleSetCollision(name, enabled, response)` - Enable collisions
  - Response: 0=none, 1=bounce, 2=stick, 3=destroy
- `particleSetStickChar(name, char)` - Character when stuck

### Presets
- `particleConfigureRain(name, intensity)` - Rain effect
- `particleConfigureSnow(name, intensity)` - Snow with collision
- `particleConfigureFire(name, intensity)` - Rising fire
- `particleConfigureSparkles(name, intensity)` - Sparkle burst
- `particleConfigureExplosion(name)` - One-shot explosion

### Queries
- `particleGetCount(name)` - Get active particle count
# Digital Clock Example

A real-time digital clock with large figlet-style digits that updates every frame.

```nim on:init
# Initialize figlet font
var fontLoaded = figletLoadFont("jazmine")
var debugMsg = "Font loaded: " & $fontLoaded

# Initialize rain particles using parallel arrays
var rainX = []
var rainY = []
var rainPrevY = []
var rainSpeed = []
var rainColor = []
var rainChar = []
var numRainParticles = 40

# Create rain particles
var i = 0
while i < numRainParticles:
  rainX = rainX + [randInt(80)]
  var startY = randInt(24)
  rainY = rainY + [startY]
  rainPrevY = rainPrevY + [startY]
  rainSpeed = rainSpeed + [1 + randInt(3)]
  rainColor = rainColor + [randInt(7)]
  rainChar = rainChar + [randInt(3)]
  i = i + 1
```

```nim on:render
# Clear the screen
clear()

# Update and draw rain particles
var i = 0
while i < numRainParticles:
  # Clear the previous position
  var prevPx = rainX[i]
  var prevPy = rainPrevY[i]
  if prevPx >= 0 and prevPx < termWidth and prevPy >= 0 and prevPy < termHeight:
    draw(0, prevPx, prevPy, " ", defaultStyle())
  
  # Save current position as previous
  rainPrevY[i] = rainY[i]
  
  # Update position
  rainY[i] = rainY[i] + rainSpeed[i]
  
  # Wrap around when particle goes off bottom
  if rainY[i] >= termHeight:
    rainY[i] = 0
    rainPrevY[i] = 0
    rainX[i] = randInt(termWidth)
  
  # Choose rain character
  var pChar = " "
  var charType = rainChar[i]
  if charType == 0:
    pChar = "|"
  if charType == 1:
    pChar = "!"
  if charType == 2:
    pChar = "."
  
  # Choose color based on particle color value and create style
  var pStyle = defaultStyle()
  var colorType = rainColor[i]
  if colorType == 0:
    pStyle.fg = cyan()
  if colorType == 1:
    pStyle.fg = blue()
  if colorType == 2:
    pStyle.fg = rgb(100, 150, 255)
  if colorType == 3:
    pStyle.fg = rgb(150, 200, 255)
  if colorType == 4:
    pStyle.fg = magenta()
  if colorType == 5:
    pStyle.fg = rgb(200, 100, 255)
  if colorType == 6:
    pStyle.fg = rgb(100, 255, 200)
  
  # Draw the rain particle
  var px = rainX[i]
  var py = rainY[i]
  if px >= 0 and px < termWidth and py >= 0 and py < termHeight:
    draw(0, px, py, pChar, pStyle)
  
  i = i + 1

# Get current time
var time = now()
var hour = time.hour
var minute = time.minute
var second = time.second

# Format time string
var timeStr = ""
if hour < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $hour & ":"
if minute < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $minute & ":"
if second < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $second

draw(0, 1, 2, "Time: " & timeStr)

# Try to render
var lines = figletRender("jazmine", timeStr)

# Center and draw
if len(lines) > 0:
  var clockWidth = len(lines[0])
  var clockHeight = len(lines)
  
  var startX = 0
  if clockWidth < termWidth:
    var diff = termWidth - clockWidth
    startX = diff / 2
  
  var startY = 10
  if clockHeight < termHeight:
    var diff = termHeight - clockHeight
    startY = diff / 2
  
  var y = startY
  for line in lines:
    draw(0, startX, y, line)
    y = y + 1
else:
  draw(0, 2, 8, "No lines to render!")
```

```figlet:jazmine
flf2a$ 8 4 14 0 21 0 16256
Cricket by Leslie Bates        Jan. 1, 1996
cricket9@aros.net       http://www.aros.net/~cricket9
I wish to thank Wade Fincher for the SIG that was used as a base for Cricket as
well as Chris Gill who designed the Square font, some of which was used in 
Cricket. And finally I wish to thank Paul Burton, who if it was not for his 
desire to create FIGWin, I may never have had the motivation to create a 
FIGfont.
 FIGWin is the Windows clone of FIGlet with a full featured FIGfont editor!
 Forget about doing the math to figure out the smushmode number.  Just check a
 few boxes for each smushing rule.  Forget about endmarks -- let the computer
 figure out how tall and how wide your font is.  Just draw FIGfonts with the
 mouse and wipe the smudgemarks off your screen from all that counting!

 FIGWin is full of features, but it's designed for use by a complete idiot.  If
 you qualify, visit the FIGWin website.  Screen shots are shown, and of course
 you can download it.  (FREE!)

                      http://home.earthlink.net/~solution

 Also see the FIGlet website:  http://st-www.cs.uiuc.edu/users/chai/figlet.html

 $$@
 $$@
 $$@
 $$@
 $$@
   @
   @
   @@
  __ @
 |  |@
 |__|@
 |__|@
     @
     @
     @
     @@
  ____ @
 | |  |@
  |_|_|@
       @
       @
       @
       @
       @@
    _____   @
  _|  |  |_ @
 |_       _|@
 |_       _|@
   |__|__|  @
            @
            @
            @@
  __,-,__ @
 |  ' '__|@
 |__     |@
 |_______|@
    |_|   @
          @
          @
          @@
  __ ___ @
 |__|   |@
 |    __|@
 |___|__|@
         @
         @
         @
         @@
  __,-,__ @
 |  ' '__|@
 |     __|@
 |_______|@
    |_|   @
          @
          @
          @@
  __ @
 |  |@
  |_|@
     @
     @
     @
     @
     @@
   ___ @
 ,'  _|@
 |  |  @
 |  |_ @
 `.___|@
       @
       @
       @@
  ___  @
 |_  `.@
   |  |@
  _|  |@
 |___,'@
       @
       @
       @@
  __ _ __ @
 |  | |  |@
  >     < @
 |__|_|__|@
          @
          @
          @
          @@
    __   @
  _|  |_ @
 |_    _|@
   |__|  @
         @
         @
         @
         @@
     @
     @
  __ @
 |  |@
  |_|@
     @
     @
     @@
         @
  ______ @
 |______|@
         @
         @
         @
         @
         @@
     @
     @
  __ @
 |__|@
     @
     @
     @
     @@
     ___@
    /  /@
  ,' ,' @
 /__/   @
        @
        @
        @
        @@
  _______ @
 |   _   |@
 |.  |   |@
 |.  |   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  _____ @
 | _   |@
 |.|   |@
 `-|.  |@
   |:  |@
   |::.|@
   `---'@
        @@
  _______ @
 |       |@
 |___|   |@
  /  ___/ @
 |:  1  \ @
 |::.. . |@
 `-------'@
          @@
  _______ @
 |   _   |@
 |___|   |@
  _(__   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  ___ ___ @
 |   Y   |@
 |   |   |@
 |____   |@
     |:  |@
     |::.|@
     `---'@
          @@
  _______ @
 |   _   |@
 |   1___|@
 |____   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  _______ @
 |   _   |@
 |   1___|@
 |.     \ @
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  _______ @
 |   _   |@
 |___|   |@
    /   / @
   |   |  @
   |   |  @
   `---'  @
          @@
  _______ @
 |   _   |@
 |.  |   |@
 |.  _   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  _______ @
 |   _   |@
 |   |   |@
  \___   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  __ @
 |__|@
  __ @
 |__|@
     @
     @
     @
     @@
  __ @
 |__|@
  __ @
 |  |@
  |_|@
     @
     @
     @@
    __ @
  ,' _|@
 /  /  @
 \  \_ @
  `.__|@
       @
       @
       @@
         @
  ______ @
 |______|@
 |______|@
         @
         @
         @
         @@
  __   @
 |_ `. @
   \  \@
  _/  /@
 |__,' @
       @
       @
       @@
  _____ @
 |__   |@
 ',  ,- @
  |--|  @
  '--   @
        @
        @
        @@
  _________ @
 |   ___   |@
 |  |  _   |@
 |  |______|@
 |_________|@
            @
            @
            @@
  _______ @
 |   _   |@
 |.  1   |@
 |.  _   |@
 |:  |   |@
 |::.|:. |@
 `--- ---'@
          @@
  _______  @
 |   _   \ @
 |.  1   / @
 |.  _   \ @
 |:  1    \@
 |::.. .  /@
 `-------' @
           @@
  _______ @
 |   _   |@
 |.  1___|@
 |.  |___ @
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  ______   @
 |   _  \  @
 |.  |   \ @
 |.  |    \@
 |:  1    /@
 |::.. . / @
 `------'  @
           @@
  _______ @
 |   _   |@
 |.  1___|@
 |.  __)_ @
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  _______ @
 |   _   |@
 |.  1___|@
 |.  __)  @
 |:  |    @
 |::.|    @
 `---'    @
          @@
  _______ @
 |   _   |@
 |.  |___|@
 |.  |   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  ___ ___ @
 |   Y   |@
 |.  1   |@
 |.  _   |@
 |:  |   |@
 |::.|:. |@
 `--- ---'@
          @@
  ___ @
 |   |@
 |.  |@
 |.  |@
 |:  |@
 |::.|@
 `---'@
      @@
  _______ @
 |   _   |@
 |___|   |@
 |.  |   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  ___ ___  @
 |   Y   ) @
 |.  1  /  @
 |.  _  \  @
 |:  |   \ @
 |::.| .  )@
 `--- ---' @
           @@
  ___     @
 |   |    @
 |.  |    @
 |.  |___ @
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  ___ ___ @
 |   Y   |@
 |.      |@
 |. \_/  |@
 |:  |   |@
 |::.|:. |@
 `--- ---'@
          @@
  ______  @
 |   _  \ @
 |.  |   |@
 |.  |   |@
 |:  |   |@
 |::.|   |@
 `--- ---'@
          @@
  _______ @
 |   _   |@
 |.  |   |@
 |.  |   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  _______ @
 |   _   |@
 |.  1   |@
 |.  ____|@
 |:  |    @
 |::.|    @
 `---'    @
          @@
  _______ @
 |   _   |@
 |.  |   |@
 |.  |   |@
 |:  1   |@
 |::..   |@
 `----|:.|@
      `--'@@
  _______ @
 |   _   \@
 |.  l   /@
 |.  _   1@
 |:  |   |@
 |::.|:. |@
 `--- ---'@
          @@
  _______ @
 |   _   |@
 |   1___|@
 |____   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  _______ @
 |       |@
 |.|   | |@
 `-|.  |-'@
   |:  |  @
   |::.|  @
   `---'  @
          @@
  ___ ___ @
 |   Y   |@
 |.  |   |@
 |.  |   |@
 |:  1   |@
 |::.. . |@
 `-------'@
          @@
  ___ ___ @
 |   Y   |@
 |.  |   |@
 |.  |   |@
 |:  1   |@
  \:.. ./ @
   `---'  @
          @@
  ___ ___ @
 |   Y   |@
 |.  |   |@
 |. / \  |@
 |:      |@
 |::.|:. |@
 `--- ---'@
          @@
   ___ ___  @
  (   Y   ) @
   \  1  /  @
   /  _  \  @
  /:  |   \ @
 (::. |:.  )@
  `--- ---' @
            @@
  ___ ___ @
 |   Y   |@
 |   1   |@
  \_   _/ @
   |:  |  @
   |::.|  @
   `---'  @
          @@
  _______ @
 |   _   |@
 |___|   |@
  /  ___/ @
 |:  1  \ @
 |::.. . |@
 `-------'@
          @@
  ____ @
 |   _|@
 |  |  @
 |  |_ @
 |____|@
       @
       @
       @@
 ___    @
 \  \   @
  `. `. @
    \__\@
        @
        @
        @
        @@
  ____ @
 |_   |@
   |  |@
  _|  |@
 |____|@
       @
       @
       @@
  ____ @
 |    |@
 |_/\_|@
       @
       @
       @
       @
       @@
         @
         @
         @
  ______ @
 |______|@
         @
         @
         @@
  __ @
 |  |@
 |_| @
     @
     @
     @
     @
     @@
        @
 .---.-.@
 |  _  |@
 |___._|@
        @
        @
        @
        @@
  __    @
 |  |--.@
 |  _  |@
 |_____|@
        @
        @
        @
        @@
       @
 .----.@
 |  __|@
 |____|@
       @
       @
       @
       @@
     __ @
 .--|  |@
 |  _  |@
 |_____|@
        @
        @
        @
        @@
        @
 .-----.@
 |  -__|@
 |_____|@
        @
        @
        @
        @@
   ___ @
 .'  _|@
 |   _|@
 |__|  @
       @
       @
       @
       @@
        @
 .-----.@
 |  _  |@
 |___  |@
 |_____|@
        @
        @
        @@
  __    @
 |  |--.@
 |     |@
 |__|__|@
        @
        @
        @
        @@
  __ @
 |__|@
 |  |@
 |__|@
     @
     @
     @
     @@
   __ @
  |__|@
  |  |@
  |  |@
 |___|@
      @
      @
      @@
  __    @
 |  |--.@
 |    < @
 |__|__|@
        @
        @
        @
        @@
  __ @
 |  |@
 |  |@
 |__|@
     @
     @
     @
     @@
           @
 .--------.@
 |        |@
 |__|__|__|@
           @
           @
           @
           @@
        @
 .-----.@
 |     |@
 |__|__|@
        @
        @
        @
        @@
        @
 .-----.@
 |  _  |@
 |_____|@
        @
        @
        @
        @@
        @
 .-----.@
 |  _  |@
 |   __|@
 |__|   @
        @
        @
        @@
        @
 .-----.@
 |  _  |@
 |__   |@
    |__|@
        @
        @
        @@
       @
 .----.@
 |   _|@
 |__|  @
       @
       @
       @
       @@
        @
 .-----.@
 |__ --|@
 |_____|@
        @
        @
        @
        @@
  __   @
 |  |_ @
 |   _|@
 |____|@
       @
       @
       @
       @@
        @
 .--.--.@
 |  |  |@
 |_____|@
        @
        @
        @
        @@
        @
 .--.--.@
 |  |  |@
  \___/ @
        @
        @
        @
        @@
           @
 .--.--.--.@
 |  |  |  |@
 |________|@
           @
           @
           @
           @@
        @
 .--.--.@
 |_   _|@
 |__.__|@
        @
        @
        @
        @@
        @
 .--.--.@
 |  |  |@
 |___  |@
 |_____|@
        @
        @
        @@
        @
 .-----.@
 |-- __|@
 |_____|@
        @
        @
        @
        @@
   ___ @
  |  _|@
 /  /  @
 \  \_ @
  |___|@
       @
       @
       @@
  __ @
 |  |@
 |  |@
 |  |@
 |__|@
     @
     @
     @@
  ___  @
 |_  | @
   \  \@
  _/  /@
 |___| @
       @
       @
       @@
   ___ @
  | ' |@
 |_,_| @
       @
       @
       @
       @
       @@
 .--.--.@
 |-----|@
 |  -  |@
 |__|__|@
        @
        @
        @
        @@
 .--.--.@
 |-----|@
 |  _  |@
 |_____|@
        @
        @
        @
        @@
 .--.--.@
 |--|--|@
 |  |  |@
 |_____|@
        @
        @
        @
        @@
 .--.--.@
 |---.-|@
 |  _  |@
 |___._|@
        @
        @
        @
        @@
 .--.--.@
 |-----|@
 |  _  |@
 |_____|@
        @
        @
        @
        @@
 .--.--.@
 |--|--|@
 |  |  |@
 |_____|@
        @
        @
        @
        @@
  _______ @
 |    __ \@
 |    __ <@
 |  |____/@
 |__|     @
          @
          @
          @@

```---
title: "Terminal Shaders Demo"
theme: "catppuccin"
minWidth: 40
minHeight: 10
---

# Terminal Shaders - Procedural Visual Effects

This demo showcases shader-like visual effects in the terminal using
native Nim rendering for maximum performance.

```nim on:init
# Initialize shader system
var currentEffect = 0
var numEffects = 7

# Shader names
var effectName0 = "Plasma - Sine wave interference"
var effectName1 = "Ripple - Concentric waves"
var effectName2 = "Fire - Rising flames"
var effectName3 = "Fractal Noise - Multi-octave"
var effectName4 = "Wave Pattern - Horizontal flow"
var effectName5 = "Tunnel - Perspective distortion"
var effectName6 = "Matrix Rain - Digital cascade"

# Initialize shader (effectId, layerId, x, y, width, height, reduction)
# reduction: 1=full res, 2=half res (2x faster), 4=quarter res (4x faster)
# Max useful reduction: ~8 (beyond that, too few pixels render)
var renderHeight = termHeight - 4
var reduction = 8  # Default to half resolution for better performance
initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)

print "Terminal shaders initialized with native rendering"
```

```nim on:update
# Update shader animation every frame
updateShader()
```

```nim on:render
# Draw the current shader effect
drawShader(0)

# Get effect name based on index
var effectName = "Unknown"
if currentEffect == 0:
  effectName = effectName0
elif currentEffect == 1:
  effectName = effectName1
elif currentEffect == 2:
  effectName = effectName2
elif currentEffect == 3:
  effectName = effectName3
elif currentEffect == 4:
  effectName = effectName4
elif currentEffect == 5:
  effectName = effectName5
elif currentEffect == 6:
  effectName = effectName6

# Draw UI footer
var footerY = termHeight - 2
var headerStyle = getStyle("heading")
var bodyStyle = getStyle("body")
var linkStyle = getStyle("link")

# Clear footer area
fillRect(0, 0, footerY, termWidth, 2, " ", bodyStyle)

# Effect name
draw(0, 2, footerY, effectName, headerStyle)

# Controls
var controls = "  [P] Prev  [N] Next  [+/-] Res  [S] Pause  [R] Reset  [Q] Quit  (Click left/right to navigate)"
draw(0, 2, footerY + 1, controls, linkStyle)

# Progress indicator
var resText = "Res: 1/" & $(reduction)
var progressText = "Effect " & $(currentEffect + 1) & "/" & $(numEffects) & "  " & resText
draw(0, termWidth - len(progressText) - 2, footerY + 1, progressText, bodyStyle)
```

```nim on:input
if event.type == "text":
  var key = event.text
  if key == "n" or key == "N":
    # Next effect
    currentEffect = (currentEffect + 1) mod numEffects
    var renderHeight = termHeight - 4
    initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
  elif key == "p" or key == "P":
    # Previous effect
    currentEffect = (currentEffect - 1 + numEffects) mod numEffects
    var renderHeight = termHeight - 4
    initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
  elif key == "+" or key == "=":
    # Increase resolution (decrease reduction)
    if reduction > 1:
      reduction = reduction div 2
      var renderHeight = termHeight - 4
      initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
      print "Resolution: " & $(termWidth div reduction) & "x" & $(renderHeight div reduction)
  elif key == "-" or key == "_":
    # Decrease resolution (increase reduction)
    if reduction < 8:
      reduction = reduction * 2
      var renderHeight = termHeight - 4
      initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
      print "Resolution: " & $(termWidth div reduction) & "x" & $(renderHeight div reduction)
  elif key == "s" or key == "S":
    # Toggle pause (changed from P to S to avoid conflict with Previous)
    pauseShader()
    print "Animation paused"
  elif key == "r" or key == "R":
    # Reset animation
    resetShader()
    print "Animation reset"

elif event.type == "mouse":
  if event.action == "press":
    var mouseX = event.x
    var leftThird = termWidth / 3
    var rightThird = (termWidth * 2) / 3
    
    if mouseX < leftThird:
      # Click on left side - previous effect
      currentEffect = (currentEffect - 1 + numEffects) mod numEffects
      var renderHeight = termHeight - 4
      initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
    elif mouseX > rightThird:
      # Click on right side - next effect
      currentEffect = (currentEffect + 1) mod numEffects
      var renderHeight = termHeight - 4
      initShader(currentEffect, 0, 0, 1, termWidth, renderHeight, reduction)
```

## Available Effects

**0. Plasma** - Multiple sine wave interference creating psychedelic patterns
   - Uses 4 sine waves at different frequencies
   - Rainbow color cycling
   - Character ramp: ` ‚ñë‚ñí‚ñì‚ñà`

**1. Ripple** - Concentric waves emanating from center
   - Distance-based wave calculation
   - Heatmap color gradient (black‚Üíred‚Üíyellow‚Üíwhite)
   - Smooth wave animation

**2. Fire** - Rising flames with turbulence
   - Height-based intensity
   - Procedural turbulence using hash functions
   - Fire gradient (black‚Üíred‚Üíorange‚Üíyellow)

**3. Fractal Noise** - Multi-octave Perlin-like noise
   - 4 octaves of smooth noise
   - Cool-warm color gradient
   - Fine-grained Braille characters for detail

**4. Wave** - Horizontal sine wave pattern
   - Simple directional wave
   - Ocean color palette (deep blue‚Üícyan)
   - Block characters for smooth gradient: `‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà`

**5. Tunnel** - Rotating perspective distortion
   - Polar coordinate transformation
   - Distance and angle-based patterns
   - Neon cyan-magenta colors

**6. Matrix Rain** - Digital rain cascade
   - Column-based falling animation
   - Random character generation
   - Green matrix-style coloring

## Technical Implementation

All effects are rendered **natively in Nim** for maximum performance:
- Direct buffer manipulation (no per-pixel nimini calls)
- Tight loops run at native speed
- Character and color computed inline
- Simple API: `initShader()`, `updateShader()`, `drawShader()`

Compare this to the manual implementation where each pixel required:
- A nimini function call
- Style object creation
- Color calculation in interpreted code
- Individual draw() call

The native implementation is **orders of magnitude faster** and can easily
render at 60+ FPS on modern terminals!

## How It Works

**Character-as-Pixel Concept:**
- Each terminal cell acts as a "pixel" with:
  - **Density** (character choice): ` ‚ñë‚ñí‚ñì‚ñà` or `‚°Ä‚°Ñ‚°Ü‚°á‚£á‚£ß‚£∑‚£ø`
  - **Color** (RGB values): Full true color support

**Procedural Techniques:**
- **Distance Fields**: Ripple and Tunnel effects based on `dist(x, y, centerX, centerY)`
- **Sine Waves**: Plasma uses multiple sine wave interference patterns
- **Procedural Noise**: Fractal/Perlin-style generation with `intHash2D` and `fractalNoise2D`
- **Time-based Animation**: All shaders accept a frame counter for motion

**Color Palettes:**
- `heatmap()`: Black ‚Üí Red ‚Üí Yellow ‚Üí White
- `plasma()`: Rainbow gradient
- `ocean()`: Deep blue ‚Üí Cyan
- `fire()`: Black ‚Üí Red ‚Üí Orange ‚Üí Yellow
- `neon()`: Cyan ‚Üí Magenta with high saturation

**Character Ramps:**
```nim
DENSITY_ASCII   = [" ", ".", ":", "-", "=", "+", "*", "#", "%", "@"]
DENSITY_SMOOTH  = [" ", "‚ñë", "‚ñí", "‚ñì", "‚ñà"]
DENSITY_BLOCKS  = [" ", "‚ñÅ", "‚ñÇ", "‚ñÉ", "‚ñÑ", "‚ñÖ", "‚ñÜ", "‚ñá", "‚ñà"]
DENSITY_BRAILLE = [" ", "‚°Ä", "‚°Ñ", "‚°Ü", "‚°á", "‚£á", "‚£ß", "‚£∑", "‚£ø"]
```

See `lib/terminal_shaders.nim` for full implementation!
---
title: "Displacement Shaders Demo"
theme: "catppuccin"
minWidth: 60
minHeight: 20
---

# Displacement Shaders - Content Distortion Effects

This demo showcases displacement effects that warp and distort existing terminal
content in real-time. Click left/right or use arrow keys to cycle through effects!

```nim on:init
# Initialize displacement system
var currentEffect = 0
var numEffects = 8
var intensity = 1.0

# Effect names
var effectName0 = "Horizontal Wave - Ocean waves"
var effectName1 = "Vertical Wave - Curtain ripple"
var effectName2 = "Ripple - Water drop impact"
var effectName3 = "Noise - Organic turbulence"
var effectName4 = "Heat Haze - Desert shimmer"
var effectName5 = "Swirl - Vortex rotation"
var effectName6 = "Fisheye - Lens distortion"
var effectName7 = "Bulge - Animated pulse"

# Render area dimensions
var renderHeight = termHeight - 4
var contentLayer = 0
var displayLayer = 1

# Initialize displacement
initDisplacement(currentEffect, displayLayer, 0, 1, termWidth, renderHeight, intensity)

print "Displacement shaders initialized"
```

```nim on:update
# Update displacement animation every frame
updateDisplacement()
```

```nim on:render
# First, draw content to layer 0 (source)
clear(contentLayer)

# Draw a grid pattern with text as content to distort
var gridStyle = getStyle("body")
var headingStyle = getStyle("heading")
var linkStyle = getStyle("link")
var commentStyle = getStyle("comment")

# Title in the middle
var titleY = renderHeight / 2 - 5
draw(contentLayer, termWidth / 2 - 15, titleY, "DISPLACEMENT SHADERS", headingStyle)
draw(contentLayer, termWidth / 2 - 20, titleY + 2, "Real-time content distortion effects", linkStyle)

# Draw a grid of text for distortion
var gridSpacing = 4
var y = 4
while y < renderHeight - 4:
  var x = 5
  while x < termWidth - 10:
    if (x / gridSpacing) mod 2 == 0 and (y / gridSpacing) mod 2 == 0:
      draw(contentLayer, x, y, "‚Ä¢", commentStyle)
    elif (x / gridSpacing) mod 2 == 1 and (y / gridSpacing) mod 2 == 1:
      draw(contentLayer, x, y, "‚óã", gridStyle)
    x = x + gridSpacing
  y = y + gridSpacing

# Draw border frame
var borderStyle = getStyle("link")
var borderY = 2
var borderH = renderHeight - 4
# Top and bottom
var bx = 2
while bx < termWidth - 2:
  draw(contentLayer, bx, borderY, "‚îÄ", borderStyle)
  draw(contentLayer, bx, borderY + borderH, "‚îÄ", borderStyle)
  bx = bx + 1

# Sides
var by = borderY
while by <= borderY + borderH:
  draw(contentLayer, 2, by, "‚îÇ", borderStyle)
  draw(contentLayer, termWidth - 3, by, "‚îÇ", borderStyle)
  by = by + 1

# Corners
draw(contentLayer, 2, borderY, "‚îå", borderStyle)
draw(contentLayer, termWidth - 3, borderY, "‚îê", borderStyle)
draw(contentLayer, 2, borderY + borderH, "‚îî", borderStyle)
draw(contentLayer, termWidth - 3, borderY + borderH, "‚îò", borderStyle)

# Add some ASCII art elements
if termWidth > 60:
  draw(contentLayer, 10, 6, "  ‚ïî‚ïê‚ïê‚ïê‚ïó  ", linkStyle)
  draw(contentLayer, 10, 7, "  ‚ïë ‚óâ ‚ïë  ", linkStyle)
  draw(contentLayer, 10, 8, "  ‚ïö‚ïê‚ïê‚ïê‚ïù  ", linkStyle)
  
  draw(contentLayer, termWidth - 20, 6, "  ‚ï≠‚îÄ‚îÄ‚îÄ‚ïÆ  ", commentStyle)
  draw(contentLayer, termWidth - 20, 7, "  ‚îÇ ‚òÖ ‚îÇ  ", commentStyle)
  draw(contentLayer, termWidth - 20, 8, "  ‚ï∞‚îÄ‚îÄ‚îÄ‚ïØ  ", commentStyle)

# Add some text labels
if termHeight > 15:
  draw(contentLayer, 6, renderHeight - 8, "WAVE", gridStyle)
  draw(contentLayer, termWidth - 20, renderHeight - 8, "DISTORT", gridStyle)
  draw(contentLayer, termWidth / 2 - 4, 5, "CONTENT", headingStyle)

# Clear display layer
clear(displayLayer)

# Apply displacement from content layer to display layer
drawDisplacement(displayLayer, contentLayer)

# Get effect name
var effectName = "Unknown"
if currentEffect == 0:
  effectName = effectName0
elif currentEffect == 1:
  effectName = effectName1
elif currentEffect == 2:
  effectName = effectName2
elif currentEffect == 3:
  effectName = effectName3
elif currentEffect == 4:
  effectName = effectName4
elif currentEffect == 5:
  effectName = effectName5
elif currentEffect == 6:
  effectName = effectName6
elif currentEffect == 7:
  effectName = effectName7

# Draw UI footer on display layer
var footerY = termHeight - 2
var headerStyle = getStyle("heading")
var bodyStyle = getStyle("body")

# Clear footer area
fillRect(displayLayer, 0, footerY, termWidth, 2, " ", bodyStyle)

# Effect name
draw(displayLayer, 2, footerY, effectName, headerStyle)

# Controls
var controls = "  [P] Prev  [N] Next  [+/-] Intensity  [S] Pause  [R] Reset  (Click left/right to navigate)"
draw(displayLayer, 2, footerY + 1, controls, linkStyle)

# Progress indicator
var intensityText = "Intensity: " & $(int(intensity * 100.0)) & "%"
var progressText = "Effect " & $(currentEffect + 1) & "/" & $(numEffects) & "  " & intensityText
draw(displayLayer, termWidth - len(progressText) - 2, footerY + 1, progressText, bodyStyle)
```

```nim on:input
if event.type == "text":
  var key = event.text
  if key == "n" or key == "N":
    # Next effect
    currentEffect = (currentEffect + 1) mod numEffects
    var renderHeight = termHeight - 4
    initDisplacement(currentEffect, displayLayer, 0, 1, termWidth, renderHeight, intensity)
  elif key == "p" or key == "P":
    # Previous effect
    currentEffect = (currentEffect - 1 + numEffects) mod numEffects
    var renderHeight = termHeight - 4
    initDisplacement(currentEffect, displayLayer, 0, 1, termWidth, renderHeight, intensity)
  elif key == "+" or key == "=":
    # Increase intensity
    if intensity < 3.0:
      intensity = intensity + 0.2
      setDisplacementIntensity(intensity)
      print "Intensity: " & $(int(intensity * 100.0)) & "%"
  elif key == "-" or key == "_":
    # Decrease intensity
    if intensity > 0.2:
      intensity = intensity - 0.2
      setDisplacementIntensity(intensity)
      print "Intensity: " & $(int(intensity * 100.0)) & "%"
  elif key == "s" or key == "S":
    # Toggle pause
    pauseDisplacement()
    print "Animation paused/resumed"
  elif key == "r" or key == "R":
    # Reset animation
    resetDisplacement()
    print "Animation reset"

elif event.type == "key":
  if event.keyCode == 10002:  # Left arrow
    currentEffect = (currentEffect - 1 + numEffects) mod numEffects
    var renderHeight = termHeight - 4
    initDisplacement(currentEffect, displayLayer, 0, 1, termWidth, renderHeight, intensity)
  elif event.keyCode == 10003:  # Right arrow
    currentEffect = (currentEffect + 1) mod numEffects
    var renderHeight = termHeight - 4
    initDisplacement(currentEffect, displayLayer, 0, 1, termWidth, renderHeight, intensity)

elif event.type == "mouse":
  if event.action == "press":
    var mouseX = event.x
    var leftThird = termWidth / 3
    var rightThird = (termWidth * 2) / 3
    
    if mouseX < leftThird:
      # Click on left side - previous effect
      currentEffect = (currentEffect - 1 + numEffects) mod numEffects
      var renderHeight = termHeight - 4
      initDisplacement(currentEffect, displayLayer, 0, 1, termWidth, renderHeight, intensity)
    elif mouseX > rightThird:
      # Click on right side - next effect
      currentEffect = (currentEffect + 1) mod numEffects
      var renderHeight = termHeight - 4
      initDisplacement(currentEffect, displayLayer, 0, 1, termWidth, renderHeight, intensity)
```

## Available Displacement Effects

**0. Horizontal Wave** üåä
   - Sine wave distortion along X-axis
   - Creates ocean wave effect
   - Perfect for liquid/water simulations

**1. Vertical Wave** üìè
   - Sine wave distortion along Y-axis
   - Curtain or flag ripple effect
   - Smooth vertical undulation

**2. Ripple** üíß
   - Radial waves from center point
   - Water drop impact simulation
   - Distance-based wave propagation

**3. Noise Distortion** üå™Ô∏è
   - Multi-octave Perlin-like noise
   - Organic, turbulent distortion
   - Great for heat/air distortion effects

**4. Heat Haze** üî•
   - Wavy vertical shimmer
   - Desert mirage effect
   - Combines noise with wave motion

**5. Swirl/Vortex** üåÄ
   - Rotational distortion around center
   - Whirlpool or tornado effect
   - Angle-based displacement

**6. Fisheye Lens** üîç
   - Radial scaling distortion
   - Camera lens effect
   - Distance-based magnification

**7. Animated Bulge** ü´ß
   - Pulsing bubble effect
   - Rhythmic expansion/contraction
   - Time-animated displacement

## How Displacement Works

**Displacement vs Drawing:**
Unlike traditional shaders that draw new patterns, displacement shaders **reposition
existing content** by calculating offset vectors for each cell.

**The Algorithm:**
```
For each cell (x, y):
  1. Calculate displacement offset: (dx, dy) = displacementFunc(x, y, time)
  2. Sample source content at: (x + dx, y + dy)
  3. Write sampled content to: (x, y)
```

**Advantages:**
- ‚úÖ Preserves original content (text, colors, styles)
- ‚úÖ More efficient than redrawing patterns
- ‚úÖ Can combine with any visual content
- ‚úÖ Creates realistic distortion effects
- ‚úÖ Lower computational cost than color shaders

**Real-World Applications:**
- UI transitions and animations
- Water/liquid surface effects
- Heat shimmer and atmospheric effects
- Lens and camera distortions
- Portal/wormhole effects
- Gravity well visualizations

## Performance

Displacement shaders are optimized for real-time rendering:
- **Native Nim implementation** - No per-pixel script calls
- **Direct buffer access** - Efficient memory operations
- **Bounds checking** - Safe edge handling
- **Configurable intensity** - Fine-tune distortion strength

The system renders at **60+ FPS** even with complex multi-octave noise functions!

## API Usage

```nim
# Initialize
initDisplacement(effectId, layerId, x, y, width, height, intensity)

# Update animation
updateDisplacement()

# Render
drawDisplacement(destLayer, sourceLayer)
# or
drawDisplacementInPlace(layer)

# Controls
setDisplacementEffect(newEffectId)
setDisplacementIntensity(0.0 to 3.0)
pauseDisplacement() / resumeDisplacement()
resetDisplacement()
```

## Try It!

- **Click left/right** edges to navigate effects
- **Arrow keys** also work for navigation
- **+/-** to adjust distortion intensity
- **P/N** for previous/next effect
- **S** to pause/resume animation
- **R** to reset to beginning

Experiment with different intensities to see how extreme distortions can create
surreal and artistic effects!
---
title: "Shader Primitives - Build Your Own Effects"
theme: "catppuccin"
minWidth: 40
minHeight: 10
---

# Shader Primitives - Compose Your Own Effects

This demo shows how to use shader primitives to build custom visual effects
from scratch. Unlike the monolithic shader system, these primitives let you
combine waves, colors, and patterns in creative ways.

```nim on:init
# Initialize variables
var frame = 0
var paused = 0
var currentDemo = 0
var numDemos = 3

# Demo names
var demoName0 = "Plasma - Sine wave composition"
var demoName1 = "Ripple - Polar coordinates"
var demoName2 = "Custom - Wave mixing"

# Character ramps for intensity mapping
var densityRamp = " .'`^\,:;Il!i><~+_-?][}{1)(|\\/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$"

print "Shader primitives demo initialized"
```

```nim on:update
if paused == 0:
  frame = frame + 1
```

```nim on:render
# Clear the render area
var renderHeight = termHeight - 4
fillRect(0, 0, 1, termWidth, renderHeight, " ", getStyle("body"))

# Demo 0: Plasma effect using sine wave composition
if currentDemo == 0:
  var y = 0
  while y < renderHeight:
    var x = 0
    while x < termWidth:
      # Calculate 4 sine waves at different frequencies and phases
      var wave1 = isin((x * 10 + frame * 3) mod 3600)      # Horizontal
      var wave2 = isin((y * 15 + frame * 2) mod 3600)      # Vertical
      var wave3 = isin((x * 8 + y * 8 + frame * 4) mod 3600)  # Diagonal
      var wave4 = isin(((x - termWidth / 2) * (x - termWidth / 2) + (y - renderHeight / 2) * (y - renderHeight / 2)) mod 3600)
      
      # Combine waves (they're in range -1000..1000)
      var combined = waveAdd(wave1, wave2)
      combined = waveAdd(combined, wave3)
      combined = waveAdd(combined, wave4)
      
      # Map to 0..255 range for color lookup
      var value = (combined + 4000) / 31  # Scale to 0..255
      value = clamp(value, 0, 255)
      
      # Get plasma color (returns packed RGB integer)
      var colorInt = colorPlasma(value)
      
      # Unpack to color map for use with style
      var color = unpackColor(colorInt)
      
      # Create style with color
      var style = defaultStyle()
      style.fg = color
      
      # Map to character intensity
      var intensity = value / 4  # 0..63 for character ramp
      var charIdx = clamp(intensity, 0, 63)
      var char = " "
      if charIdx == 0:
        char = " "
      elif charIdx == 1:
        char = "."
      elif charIdx == 2:
        char = "'"
      elif charIdx >= 3 and charIdx < 10:
        char = ":"
      elif charIdx >= 10 and charIdx < 20:
        char = "+"
      elif charIdx >= 20 and charIdx < 30:
        char = "="
      elif charIdx >= 30 and charIdx < 40:
        char = "#"
      elif charIdx >= 40 and charIdx < 50:
        char = "@"
      else:
        char = "‚ñà"
      
      # Draw character with color
      draw(0, x, y + 1, char, style)
      x = x + 1
    y = y + 1

# Demo 1: Ripple effect using polar coordinates
elif currentDemo == 1:
  var centerX = termWidth / 2
  var centerY = renderHeight / 2
  
  var y = 0
  while y < renderHeight:
    var x = 0
    while x < termWidth:
      # Get distance and angle from center
      var dist = polarDistance(x, y, centerX, centerY)
      var angle = polarAngle(x, y, centerX, centerY)
      
      # Create ripple pattern
      var ripple = isin((dist * 20 - frame * 10) mod 3600)
      
      # Add spiral component using angle
      var spiral = isin((angle + dist * 5 + frame * 5) mod 3600)
      
      # Combine
      var combined = waveAdd(ripple, spiral)
      
      # Map to 0..255
      var value = (combined + 2000) / 16
      value = clamp(value, 0, 255)
      
      # Get ocean color (packed RGB integer) and unpack
      var color = unpackColor(colorOcean(value))
      
      # Create style with color
      var style = defaultStyle()
      style.fg = color
      
      # Map to character
      var char = " "
      if value < 200:
        char = " "
      elif value < 400:
        char = "."
      elif value < 600:
        char = "~"
      elif value < 800:
        char = "="
      else:
        char = "‚âà"
      
      draw(0, x, y + 1, char, style)
      x = x + 1
    y = y + 1

# Demo 2: Custom wave mixing
elif currentDemo == 2:
  var y = 0
  while y < renderHeight:
    var x = 0
    while x < termWidth:
      # Create two different wave patterns
      var wave1 = isin((x * 12 + frame * 4) mod 3600)
      var wave2 = icos((y * 20 - frame * 3) mod 3600)
      
      # Mix them based on position
      var mixFactor = (x * 1000) / termWidth  # 0..1000 across screen
      var mixed = waveMix(wave1, wave2, mixFactor)
      
      # Map to 0..255
      var value = (mixed + 1000) / 8
      value = clamp(value, 0, 255)
      
      # Get neon color (packed RGB integer) and unpack
      var color = unpackColor(colorNeon(value))
      
      # Create style with color
      var style = defaultStyle()
      style.fg = color
      
      # Map to character
      var char = " "
      if value < 150:
        char = " "
      elif value < 300:
        char = "."
      elif value < 450:
        char = ":"
      elif value < 600:
        char = "+"
      elif value < 750:
        char = "="
      elif value < 900:
        char = "#"
      else:
        char = "‚ñà"
      
      draw(0, x, y + 1, char, style)
      x = x + 1
    y = y + 1

# Draw UI footer
var footerY = termHeight - 2
var headerStyle = getStyle("heading")
var bodyStyle = getStyle("body")
var linkStyle = getStyle("link")

# Clear footer area
fillRect(0, 0, footerY, termWidth, 2, " ", bodyStyle)

# Effect name
var effectName = "Unknown"
if currentDemo == 0:
  effectName = demoName0
elif currentDemo == 1:
  effectName = demoName1
elif currentDemo == 2:
  effectName = demoName2

draw(0, 2, footerY, effectName, headerStyle)

# Controls
var controls = "  [P] Prev  [N] Next  [S] Pause  [R] Reset  [Q] Quit  (Click left/right to navigate)"
draw(0, 2, footerY + 1, controls, linkStyle)

# Progress indicator
var progressText = "Demo " & $(currentDemo + 1) & "/" & $(numDemos) & "  Frame: " & $(frame)
draw(0, termWidth - len(progressText) - 2, footerY + 1, progressText, bodyStyle)
```

```nim on:input
if event.type == "text":
  var key = event.text
  if key == "n" or key == "N":
    # Next demo
    currentDemo = (currentDemo + 1) mod numDemos
    frame = 0
  elif key == "p" or key == "P":
    # Previous demo
    currentDemo = (currentDemo - 1 + numDemos) mod numDemos
    frame = 0
  elif key == "s" or key == "S":
    # Toggle pause (changed from P to S)
    if paused == 0:
      paused = 1
    else:
      paused = 0
  elif key == "r" or key == "R":
    # Reset animation
    frame = 0

elif event.type == "mouse":
  if event.action == "press":
    var mouseX = event.x
    var leftThird = termWidth / 3
    var rightThird = (termWidth * 2) / 3
    
    if mouseX < leftThird:
      # Click on left side - previous demo
      currentDemo = (currentDemo - 1 + numDemos) mod numDemos
      frame = 0
    elif mouseX > rightThird:
      # Click on right side - next demo
      currentDemo = (currentDemo + 1) mod numDemos
      frame = 0
```

## Available Primitives

This demo showcases composable shader primitives that you can use to create your own effects:

### Trigonometry Functions
- `isin(angle)` - Integer sine (-1000..1000 for angle 0..3600 decidegrees)
- `icos(angle)` - Integer cosine (-1000..1000 for angle 0..3600 decidegrees)

### Polar Coordinates
- `polarDistance(x, y, centerX, centerY)` - Distance from center point
- `polarAngle(x, y, centerX, centerY)` - Angle from center (0..3600 decidegrees)

### Wave Operations
- `waveAdd(w1, w2)` - Add two waves with clamping
- `waveMultiply(w1, w2)` - Multiply two waves
- `waveMix(w1, w2, t)` - Mix two waves (t=0..1000 is blend factor)

### Color Palettes
- `colorHeatmap(v)` - Black ‚Üí Red ‚Üí Yellow ‚Üí White
- `colorPlasma(v)` - Blue ‚Üí Purple ‚Üí Red ‚Üí Orange
- `colorCoolWarm(v)` - Blue ‚Üí White ‚Üí Red
- `colorFire(v)` - Black ‚Üí Red ‚Üí Orange ‚Üí Yellow
- `colorOcean(v)` - Deep Blue ‚Üí Cyan ‚Üí White
- `colorNeon(v)` - Purple ‚Üí Pink ‚Üí Cyan ‚Üí Green
- `colorMatrix(v)` - Matrix-style green
- `colorGrayscale(v)` - Black ‚Üí White

All color functions take values 0..255 and return a packed RGB integer (0xRRGGBB).
Use the `unpackColor()` helper to convert for use with styles:
```nim
var colorInt = colorPlasma(value)  # Get packed color
var color = unpackColor(colorInt)  # Unpack to {r, g, b} map
var style = defaultStyle()
style.fg = color
draw(0, x, y, char, style)
```

Alternatively, extract components manually:
```nim
var colorInt = colorPlasma(value)
var r = (colorInt / 65536) mod 256  # Extract red
var g = (colorInt / 256) mod 256    # Extract green  
var b = colorInt mod 256            # Extract blue
var style = defaultStyle()
style.fg = rgb(r, g, b)
```

## Tips for Building Effects

1. **Combine Multiple Waves**: Use `waveAdd()` to layer sine waves at different frequencies
2. **Use Polar Coordinates**: Create radial patterns with `polarDistance()` and `polarAngle()`
3. **Animate with Frame Counter**: Add frame to wave calculations for movement
4. **Scale Coordinates**: Multiply x/y by constants to change pattern frequency
5. **Map Values**: Use `map()` or manual scaling to convert wave ranges to 0..255 for colors
6. **Character Mapping**: Map intensity values to character ramps for ASCII art effects
7. **Mix Techniques**: Combine Cartesian waves with polar coordinates for complex patterns

These primitives work in both nimini scripts AND exported native code, making them ideal
for procedurally generated content that needs to export to production builds.
---
title: "Simple Rooms - Deterministic"
author: "Guaranteed identical results"
minWidth: 80
minHeight: 25
---

# Simple Room Generator

Press **R** to regenerate with new seed.

Using only procgen primitives - **same seed = same rooms**!

```nim on:init
const WALL = 0
const FLOOR = 1
const WIDTH = 79
const HEIGHT = 24

var grid: seq
var seed = 12345
var roomCount = 0

proc generateRooms() =
  # Initialize grid
  grid = newSeq(HEIGHT)
  for y in 0..<HEIGHT:
    var row = newSeq(WIDTH)
    for x in 0..<WIDTH:
      row[x] = WALL
    grid[y] = row
  
  # Get seed from param or use default
  if hasParam("seed"):
    seed = getParamInt("seed", 12345)
  
  # Create isolated RNG
  var rng = initRand(seed)
  
  # Generate 8 rooms using primitives
  roomCount = 8
  for i in 0..<roomCount:
    # Use primitives for all calculations
    var roomW = clamp(rng.rand(5, 15), 5, 15)
    var roomH = clamp(rng.rand(4, 8), 4, 8)
    var roomX = clamp(rng.rand(1, WIDTH - roomW - 1), 1, WIDTH - roomW - 1)
    var roomY = clamp(rng.rand(1, HEIGHT - roomH - 1), 1, HEIGHT - roomH - 1)
    
    # Carve room
    for ry in roomY..<(roomY + roomH):
      for rx in roomX..<(roomX + roomW):
        if ry >= 0 and ry < HEIGHT and rx >= 0 and rx < WIDTH:
          grid[ry][rx] = FLOOR

generateRooms()
```

```nim on:render
clear()

for y in 0..<HEIGHT:
  for x in 0..<WIDTH:
    var ch = "#"
    if grid[y][x] == FLOOR:
      ch = "¬∑"
    draw(0, x, y, ch)

draw(0, 0, HEIGHT, "Seed: " & str(seed) & "  Rooms: " & str(roomCount))
draw(0, 0, HEIGHT + 1, "Using ONLY procgen primitives!")
draw(0, 0, HEIGHT + 2, "Press R to regenerate with same seed")
```

```nim on:input
if event.type == "text":
  var key = event.text
  if key == "r" or key == "R":
    generateRooms()
    return true

return false
```
---
title: "Canvas Presentation Demo"
author: "Maddest Labs"
theme: "catppuccin"
fontsize: 24
---

```nim on:init
# Canvas-based Presentation System using Nimini
# Navigate with arrow keys: Left/Right for main topics, Up/Down for subtopics

print "Presentation initialized"

# Initialize canvas in presentation mode
# Second parameter = starting section (1 for first real section)
# Third parameter = presentation mode (true)
initCanvas(1, true)
```

```nim on:input
# Handle keyboard and mouse input for canvas navigation

if event.type == "key":
  if event.action == "press":
    # Pass key events to canvas system
    var handled = canvasHandleKey(event.keyCode, 0)
    if handled:
      return true
  return false

elif event.type == "mouse":
  if event.action == "release":
    var handled = canvasHandleMouse(event.x, event.y, event.button, false)
    if handled:
      return true
  return false

return false
```

```nim on:render
clear()
canvasRender()
```

```nim on:update
canvasUpdate()
```

# Canvas Presentations

This demo showcases the presentation mode of the canvas system, where arrow keys navigate between slides instead of following links.
‚†Ä
### Navigation Guide
‚†Ä
- **Left/Right arrows**: Navigate between main topics (# headings)
- **Up/Down arrows**: Navigate between subtopics (## headings)
- **Mouse/Touch**: Click/tap left side of screen to go back, right side to go forward
‚†Ä
Let's explore the features!

# Feature Overview
‚†Ä
The canvas presentation system provides:
‚†Ä
- **Hierarchical navigation** based on markdown heading levels
- **Smooth camera transitions** between slides
- **All sections visible** by default (no hidden slides)
- **Dual-mode operation** - can switch between presentation and interactive fiction modes
‚†Ä
This allows you to create engaging slide decks with the same markdown format used for interactive stories.

## Visual Design
‚†Ä
The presentation system inherits all the visual capabilities of TStorie:
‚†Ä
- **Themed styling** with built-in color schemes
- **Terminal graphics** with Unicode box drawing
- **Responsive layout** that adapts to terminal size
- **Rich text formatting** with markdown support

## Code Integration
‚†Ä
Presentations can include live Nim code blocks:
‚†Ä
```nim
var slideCount = 0
slideCount += 1
print "You're viewing slide: " & $slideCount
```
‚†Ä
This allows for interactive demonstrations and live coding examples during presentations.

## Smooth Animations
‚†Ä
The camera system provides smooth easing transitions between slides, making navigation feel natural and professional.
‚†Ä
The animation system uses **quadratic ease-out** for smooth, non-linear motion that feels responsive and polished.

# Use Cases
‚†Ä
Canvas presentations are perfect for:
‚†Ä
- **Technical talks** with code examples
- **Interactive tutorials** that respond to user input
- **Documentation** that readers can navigate freely
- **Story outlines** and narrative structures
- **Educational content** with progressive disclosure

## Conference Presentations
‚†Ä
Present your technical work with:
‚†Ä
- Live code execution
- Interactive demonstrations
- Terminal-based aesthetics
- No dependency on GUI presentation software

## Educational Materials
‚†Ä
Create engaging learning experiences:
‚†Ä
- Progressive concept introduction
- Interactive code examples
- Self-paced navigation
- Integrated exercises

## Documentation
‚†Ä
Build navigable documentation:
‚†Ä
- Hierarchical topic organization
- Quick navigation between sections
- Rich formatting support
- Code and text integration

# Technical Details
‚†Ä
The presentation mode is implemented as a flag in the canvas system's state management.
‚†Ä
When `presentationMode: true`, the keyboard handler changes behavior:
- Arrow keys navigate between sections by heading level
- All sections are made visible on initialization
- Link navigation is disabled (can be re-enabled if needed)

## Implementation
‚†Ä
Key components:
‚†Ä
1. **Section hierarchy detection** - Analyzes markdown heading levels
2. **Level-based navigation** - Finds next/previous sections at specified levels
3. **Camera control** - Smooth panning between slides
4. **State management** - Tracks current slide and navigation history

## Backward Compatibility
‚†Ä
The presentation mode is fully backward compatible:
‚†Ä
- Existing interactive fiction demos continue to work
- Default mode is interactive (link-based navigation)
- No breaking changes to existing APIs
- Simple opt-in via boolean parameter

# Future Enhancements
‚†Ä
Potential additions to the presentation system:
‚†Ä
- **Slide transitions** with different animation styles
- **Speaker notes** that don't appear on main view
- **Timers** and progress indicators
- **Export formats** (HTML, PDF via terminal rendering)
- **Remote control** via network commands

## Animation System
‚†Ä
Additional transitions could include:
‚†Ä
- Fade effects
- Slide-in/slide-out
- Zoom transitions
- Custom easing functions

## Collaboration Features
‚†Ä
Multi-user presentation capabilities:
‚†Ä
- Follow-along mode for audiences
- Real-time slide synchronization
- Collaborative editing
- Q&A integration

# Conclusion
‚†Ä
The canvas presentation system demonstrates the flexibility of TStorie's architecture.
‚†Ä
By adding a simple mode flag, we've created an entirely new use case while preserving all existing functionality.
‚†Ä
**Thank you for exploring this demo!**
‚†Ä
Feel free to create your own presentations using this system. Just set `initCanvas(1, true)` in your init block.
‚†Ä
*Press Left/Right arrows to navigate back through the slides.*
---
title: "Stone Garden"
alttitle: "Áü≥Â∫≠/Sekitei"
author: "Maddest Labs"
minWidth: 20
minHeight: 10
chars: "Â≤©ÂÉßÁü≥Â∫ßÂõ∫ÂÉß„ÉªËãîÈúßÊùæÁ´πÊ¢Ö"
doubleWidth: true
theme: "stonegarden"
font: "LXGW+WenKai+Mono+TC"
shaders: "sand+clouds+gradualblur"
---

# Stone Garden‚†Ä
```txt
; Level 1 - Getting started
#######
#     ####
#        #
# @  $ . #
#        #
##########
;
; 2
##########
##@#######
# $   ####
# ..$$ ###
#  $.  ###
#. #    ##
##########
;
; 3
##########
#### ##  #
##  .    #
### $    #
####  .$ #
  ##.@   #
  ##    .#
  ## $$ ##
  ##     #
  ########
;
; 4
##########
##########
##########
# ##### ##
#@.$  . .#
# $ $    #
#   ## . #
# $#######
#  #######
##########
;
; 5
##########
##   #####
### ######
## .#. ###
## .   $@#
#   $  ###
# $$  ####
#. #  ####
####  ####
##########
;
; 6
##########
#     ..##
#  $  .  #
#        #
####### ##
######  ##
######$$##
#### $ . #
####   @##
##########
;
; 7
##########
#    .  @#
#   $  . #
# #####  #
# $    $ #
# .$ # . #
#   ######
##########
##########
##########
;
; 8
##########
##### #. #
#### $   #
####@$  .#
###### $ #
#######  #
####  .  #
#### $  .#
#####    #
##########
;
; 9
##########
####     #
####  @$ #
#### $.  #
###.  $. #
####   $ #
#### .####
##########
##########
##########
;
; 10
##########
##########
####### ##
###      #
###$ . @ #
# .   .$ #
#  .  $  #
#     $  #
#    ### #
##########
;
; 11
##########
##      .#
## $.# $ #
##   #   #
##     $.#
###      #
### ######
## $ #####
## @.#####
##########
;
; 12
##########
##  # ####
#   $ .  #
#   #@$  #
### ## .##
#.$  $   #
#    .   #
##########
##########
##########
;
; 13
##########
#   @.   #
# $      #
# ##  # ##
# $ .#####
# $$. ####
#    #####
#.########
# ########
##########
;
; 14
##########
##########
# ########
#   ######
#.$@  $  #
#        #
##### $$ #
##### .. #
######.  #
##########
;
; 15
##########
#        #
#.$  $ $ #
#    #. @#
#.  $. # #
##     ###
##########
##########
##########
##########
;
; 16
##########
####### ##
######   #
#. $  $ ##
#       .#
#   # $ ##
# $.  . @#
#      ###
##########
##########
;
; 17
##########
##########
##########
#      ###
#.$$ #####
# #.  ####
#   .@####
#.$ $ ####
#  #######
##########
;
; 18
##########
##########
##########
##  ######
## $ #####
##   #  ##
## .## $##
##  . $  #
#  $. .@ #
##########
;
; 19
##########
#     .###
#   $ $###
# $      #
# . .$  @#
##### .###
##########
##########
##########
##########
;
; 20
##########
######@$.#
######.  #
#####  ###
##### $ ##
###### ###
#####  $ #
### .  $ #
#### .   #
##########
;
; 21
##########
#       .#
##  $ $$ #
#### #   #
# $   . .#
# #.  # ##
#@########
# ########
# ########
##########
;
; 22
##########
##########
#  #######
#  #######
#..#######
#  # #####
#  @$..###
#$ $$ ####
#      ###
##########
;
; 23
##########
####   .##
#### $.$##
#####.$ ##
######   #
####### ##
####     #
##### $  #
##@.     #
##########
;
; 24
##########
######.@##
#####  .##
##### $.##
####    ##
###### ###
### # $###
# $ $ .###
#      ###
##########
;;
; 25
##########
# @      #
#.    $$ #
#     #  #
#######. #
######## #
#######. #
##### #$ #
#    . $ #
##########
;
; 26
##########
#     @ .#
#  # ..###
# $##$$###
#  ##    #
# $  .   #
#   ##   #
##########
##########
##########
;
; 27
##########
#  . #####
# $.  ## #
#  $$    #
# .  #   #
#    #####
#.$ @#####
#    #####
##  ######
##########
;
; 28
##########
####### ##
##  . . ##
# $  $   #
#@$     .#
#######  #
######  .#
###### $ #
######   #
##########
;
; 29
##########
######## #
## @##.# #
##  ##   #
##  .#   #
##  .#  .#
##  ## $ #
### $ $$ #
###      #
##########
;
; 30
##########
######   #
#####@$ ##
#####   ##
####  .$ #
####     #
#### . $ #
####. .$ #
####    ##
##########
```

```nim on:init
# Parse character set from front matter
var wallChar = "#"
var boxChar = "$"
var playerChar = "@"
var goalChar = "."
var boxOnGoalChar = "*"
var playerOnGoalChar = "+"
var floorChar = " "
var outsideChars = ["~", ".", ":", "¬∑", "‚àô"]  # Array of 5 outside chars for random selection

if len(chars) >= 8:
  # Parse chars string with proper UTF-8 multi-byte character handling
  var charsList = []
  var i = 0
  while i < len(chars):
    var b = ord(chars[i])
    
    var charLen = 1
    # Detect UTF-8 character length based on first byte
    if b < 128:
      charLen = 1
    elif b >= 192 and b < 224:
      charLen = 2
    elif b >= 224 and b < 240:
      charLen = 3
    elif b >= 240:
      charLen = 4
    
    var endIdx = i + charLen
    if endIdx > len(chars):
      endIdx = len(chars)
    
    var ch = ""
    var j = i
    while j < endIdx:
      ch = ch & chars[j]
      j = j + 1
    
    charsList = charsList + [ch]
    i = endIdx
  
  # Assign characters (order: wall, player, box, goal, boxOnGoal, playerOnGoal, floor, outside1-5)
  if len(charsList) > 0:
    wallChar = charsList[0]
  if len(charsList) > 1:
    playerChar = charsList[1]
  if len(charsList) > 2:
    boxChar = charsList[2]
  if len(charsList) > 3:
    goalChar = charsList[3]
  if len(charsList) > 4:
    boxOnGoalChar = charsList[4]
  if len(charsList) > 5:
    playerOnGoalChar = charsList[5]
  if len(charsList) > 6:
    floorChar = charsList[6]
  # Parse 5 outside characters (indices 7-11)
  if len(charsList) > 7:
    var tempOutsideChars = []
    var oc = 7
    while oc < len(charsList) and oc < 12:
      tempOutsideChars = tempOutsideChars + [charsList[oc]]
      oc = oc + 1
    # Only replace if we got at least one character
    if len(tempOutsideChars) > 0:
      outsideChars = tempOutsideChars
      # If we got fewer than 5, duplicate the last one
      while len(outsideChars) < 5:
        outsideChars = outsideChars + [outsideChars[len(outsideChars) - 1]]

var charWidth = 1
# Calculate character width for rendering
if doubleWidth:
  charWidth = 2

# Random outside character selection
proc getRandomOutsideChar(x: int, y: int, offset: int): string =
  # Hash-based wave pattern - pseudo-random with wave-like structure
  var hash = (x * 73 + y * 37) mod 997  # Prime-based hash for randomness
  var wave = (x + y * 2) div 3  # Gentle diagonal wave component
  var idx = (hash + wave + offset) mod len(outsideChars)
  return outsideChars[idx]

# Get style objects - use theme defaults, unless user defines custom styles
# Available theme styles: default, accent1, accent2, accent3, border, info, dim, etc.
var styleWall = getStyle("bright")
var stylePlayer = getStyle("accent1")
var styleBox = getStyle("dim")
var styleGoal = getStyle("accent2")
var styleBoxGoal = getStyle("accent2")
var stylePlayerGoal = getStyle("accent2")
var styleFloor = brightness(getStyle("default"), 0.3)
var styleOutside = brightness(getStyle("default"), 0.3)

# Swap foreground and background colors for styleWall
var temp = styleWall.fg
styleWall.fg = styleWall.bg
styleWall.bg = temp

#temp = styleBox.fg
#styleBox.fg = styleBox.bg
#styleBox.bg = temp

# Apply inverse for boxGoal and playerGoal (defaults to true)
styleBoxGoal.inverse = true
stylePlayerGoal.inverse = true

# Game state
var playerX = 0
var playerY = 0
var boxes = []  # Each box is [x, y]
var goals = []  # Each goal is [x, y]
var walls = []  # Each wall is [x, y]
var reachableArea = []  # Cells reachable from player start [x, y]
var levelWidth = 0
var levelHeight = 0
var moveCount = 0
var gameWon = false
var currentLevelData = ""
var frameCount = 0  # Animation frame counter

# Level pack state
var levelPack = []  # Array of level strings
var currentLevelIndex = 0
var isLevelPack = false

# Mouse/input state
var nextMoveDX = 0
var nextMoveDY = 0

# Check if cell is in reachable area
proc isReachable(x: int, y: int): bool =
  var i = 0
  while i < len(reachableArea):
    if reachableArea[i][0] == x and reachableArea[i][1] == y:
      return true
    i = i + 1
  return false

# Parse level from string (standard Sokoban format)
proc parseLevel(levelData: string) =
  boxes = []
  goals = []
  walls = []
  reachableArea = []
  playerX = 0
  playerY = 0
  moveCount = 0
  gameWon = false
  
  if len(levelData) == 0:
    return
  
  # Split by newline
  var lines = split(levelData, "\n")
  
  levelHeight = len(lines)
  levelWidth = 0
  
  var y = 0
  while y < len(lines):
    var line = lines[y]
    if len(line) > levelWidth:
      levelWidth = len(line)
    
    var x = 0
    while x < len(line):
      var ch = ""
      if x < len(line):
        ch = ch & line[x]
      
      if ch == "@" or ch == playerChar:
        playerX = x
        playerY = y
      elif ch == "+" or ch == playerOnGoalChar:
        playerX = x
        playerY = y
        goals = goals + [[x, y]]
      elif ch == "$" or ch == boxChar:
        boxes = boxes + [[x, y]]
      elif ch == "*" or ch == boxOnGoalChar:
        boxes = boxes + [[x, y]]
        goals = goals + [[x, y]]
      elif ch == "." or ch == goalChar:
        goals = goals + [[x, y]]
      elif ch == "#" or ch == wallChar:
        walls = walls + [[x, y]]
      
      x = x + 1
    y = y + 1
  
  # Flood-fill from player start to find all reachable cells
  # This helps identify "outside" areas in irregular maps
  var floodQueue = [[playerX, playerY]]
  reachableArea = [[playerX, playerY]]
  
  while len(floodQueue) > 0:
    var current = floodQueue[0]
    var cx = current[0]
    var cy = current[1]
    
    # Remove from queue
    var newQueue = []
    var i = 1
    while i < len(floodQueue):
      newQueue = newQueue + [floodQueue[i]]
      i = i + 1
    floodQueue = newQueue
    
    # Check all 4 directions
    var directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]
    var d = 0
    while d < 4:
      var nx = cx + directions[d][0]
      var ny = cy + directions[d][1]
      
      # If valid position, not a wall, and not already visited
      if nx >= 0 and ny >= 0 and nx < levelWidth and ny < levelHeight:
        if not hasWall(nx, ny) and not isReachable(nx, ny):
          reachableArea = reachableArea + [[nx, ny]]
          floodQueue = floodQueue + [[nx, ny]]
      
      d = d + 1

# Parse level pack (semicolon-separated format)
proc parseLevelPack(packData: string): seq[string] =
  var levels = []
  var currentLevel = []
  var lines = split(packData, "\n")
  
  var j = 0
  while j < len(lines):
    var line = lines[j]
    var trimmed = strip(line)
    
    # Skip comments and empty lines before level data
    if len(trimmed) == 0 or (len(trimmed) > 0 and trimmed[0] == ';'):
      # If we have accumulated level data, this marks the end
      if len(currentLevel) > 0:
        levels = levels + [join(currentLevel, "\n")]
        currentLevel = []
      j = j + 1
    else:
      # This is level data
      currentLevel = currentLevel + [line]
      j = j + 1
  
  # Add final level if any
  if len(currentLevel) > 0:
    levels = levels + [join(currentLevel, "\n")]
  
  return levels

# Check if position has a wall
proc hasWall(x: int, y: int): bool =
  if x < 0 or y < 0 or x >= levelWidth or y >= levelHeight:
    return true
  var i = 0
  while i < len(walls):
    if walls[i][0] == x and walls[i][1] == y:
      return true
    i = i + 1
  return false

# Check if position has a box
proc hasBox(x: int, y: int): bool =
  if x < 0 or y < 0 or x >= levelWidth or y >= levelHeight:
    return false
  var i = 0
  while i < len(boxes):
    if boxes[i][0] == x and boxes[i][1] == y:
      return true
    i = i + 1
  return false

# Get box index at position
proc getBoxIndex(x: int, y: int): int =
  var i = 0
  while i < len(boxes):
    if boxes[i][0] == x and boxes[i][1] == y:
      return i
    i = i + 1
  return -1

# Check if position is a goal
proc isGoal(x: int, y: int): bool =
  var i = 0
  while i < len(goals):
    if goals[i][0] == x and goals[i][1] == y:
      return true
    i = i + 1
  return false

# Check if all boxes are on goals
proc checkWin(): bool =
  var i = 0
  while i < len(boxes):
    if not isGoal(boxes[i][0], boxes[i][1]):
      return false
    i = i + 1
  return true

# Try to move player
proc tryMove(dx: int, dy: int): bool =
  if gameWon:
    return false
  
  var newX = playerX + dx
  var newY = playerY + dy
  
  # Check wall collision
  if hasWall(newX, newY):
    return false
  
  # Check box collision
  if hasBox(newX, newY):
    var boxNewX = newX + dx
    var boxNewY = newY + dy
    
    # Can't push box into wall or another box
    if hasWall(boxNewX, boxNewY) or hasBox(boxNewX, boxNewY):
      return false
    
    # Move the box
    var boxIdx = getBoxIndex(newX, newY)
    boxes[boxIdx] = [boxNewX, boxNewY]
  
  # Move player
  playerX = newX
  playerY = newY
  moveCount = moveCount + 1
  
  # Check win
  gameWon = checkWin()
  
  return true

# Simple pathfinding (BFS) to target
proc findPath(targetX: int, targetY: int): bool =
  if gameWon:
    return false
  
  # BFS queue
  var queueX = [playerX]
  var queueY = [playerY]
  var queueFirstMoveX = [0]
  var queueFirstMoveY = [0]
  var visited = []
  
  while len(queueX) > 0:
    # Dequeue
    var cx = queueX[0]
    var cy = queueY[0]
    var firstMoveX = queueFirstMoveX[0]
    var firstMoveY = queueFirstMoveY[0]
    
    var i = 1
    var newQX = []
    var newQY = []
    var newFMX = []
    var newFMY = []
    while i < len(queueX):
      newQX = newQX + [queueX[i]]
      newQY = newQY + [queueY[i]]
      newFMX = newFMX + [queueFirstMoveX[i]]
      newFMY = newFMY + [queueFirstMoveY[i]]
      i = i + 1
    queueX = newQX
    queueY = newQY
    queueFirstMoveX = newFMX
    queueFirstMoveY = newFMY
    
    # Check if reached target
    if cx == targetX and cy == targetY:
      nextMoveDX = firstMoveX
      nextMoveDY = firstMoveY
      return true
    
    # Check if visited
    var visitKey = $cx & "," & $cy
    var alreadyVisited = false
    var j = 0
    while j < len(visited):
      if visited[j] == visitKey:
        alreadyVisited = true
      j = j + 1
    
    if not alreadyVisited:
      visited = visited + [visitKey]
      
      # Try all 4 directions
      var directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]
      var d = 0
      while d < 4:
        var nx = cx + directions[d][0]
        var ny = cy + directions[d][1]
        
        if not hasWall(nx, ny) and not hasBox(nx, ny):
          var moveX = directions[d][0]
          var moveY = directions[d][1]
          if firstMoveX == 0 and firstMoveY == 0:
            queueX = queueX + [nx]
            queueY = queueY + [ny]
            queueFirstMoveX = queueFirstMoveX + [moveX]
            queueFirstMoveY = queueFirstMoveY + [moveY]
          else:
            queueX = queueX + [nx]
            queueY = queueY + [ny]
            queueFirstMoveX = queueFirstMoveX + [firstMoveX]
            queueFirstMoveY = queueFirstMoveY + [firstMoveY]
        d = d + 1
  
  nextMoveDX = 0
  nextMoveDY = 0
  return false

# Handle mouse click for movement
proc handleClick(gridX: int, gridY: int): bool =
  if gameWon:
    return false
  
  # Validate grid position
  if gridX < 0 or gridX >= levelWidth or gridY < 0 or gridY >= levelHeight:
    return false
  
  # If clicking on current player position, do nothing
  if gridX == playerX and gridY == playerY:
    return false
  
  # If clicking on a wall, do nothing
  if hasWall(gridX, gridY):
    return false
  
  # If clicking on a box, try to push it
  if hasBox(gridX, gridY):
    var dx = gridX - playerX
    var dy = gridY - playerY
    
    # Check if adjacent
    if (dx == 0 and (dy == 1 or dy == -1)) or (dy == 0 and (dx == 1 or dx == -1)):
      return tryMove(dx, dy)
    else:
      # Try to move adjacent to box first
      var adjacent = [[gridX - 1, gridY], [gridX + 1, gridY], [gridX, gridY - 1], [gridX, gridY + 1]]
      var a = 0
      while a < 4:
        var adjX = adjacent[a][0]
        var adjY = adjacent[a][1]
        if not hasWall(adjX, adjY) and not hasBox(adjX, adjY):
          if findPath(adjX, adjY):
            return tryMove(nextMoveDX, nextMoveDY)
        a = a + 1
      return false
  
  # Move to clicked position - execute the first move
  if findPath(gridX, gridY):
    return tryMove(nextMoveDX, nextMoveDY)
  
  return false

# Load next level from pack
proc loadNextLevel() =
  if not isLevelPack or len(levelPack) == 0:
    return
  
  currentLevelIndex = currentLevelIndex + 1
  if currentLevelIndex >= len(levelPack):
    currentLevelIndex = 0
  
  parseLevel(levelPack[currentLevelIndex])

# Load previous level from pack
proc loadPrevLevel() =
  if not isLevelPack or len(levelPack) == 0:
    return
  
  currentLevelIndex = currentLevelIndex - 1
  if currentLevelIndex < 0:
    currentLevelIndex = len(levelPack) - 1
  
  parseLevel(levelPack[currentLevelIndex])

# Load level data from txt block in first section (preserves newlines!)
var levelData = getCodeBlockText(0, "txt", 0)

currentLevelData = levelData

levelPack = parseLevelPack(levelData)
isLevelPack = true
currentLevelIndex = 0
if len(levelPack) > 0:
  parseLevel(levelPack[0])

# Auto-scale font to maximize game view
# Calculate maximum dimensions across all levels to ensure all fit
var maxWidth = levelWidth
var maxHeight = levelHeight
var i = 1
while i < len(levelPack):
  # Temporarily parse each level to get dimensions
  var tempLines = split(levelPack[i], "\n")
  var tempHeight = len(tempLines)
  var tempWidth = 0
  var j = 0
  while j < len(tempLines):
    if len(tempLines[j]) > tempWidth:
      tempWidth = len(tempLines[j])
    j = j + 1
  
  if tempWidth > maxWidth:
    maxWidth = tempWidth
  if tempHeight > maxHeight:
    maxHeight = tempHeight
  i = i + 1

# Calculate required terminal cells for game content using max dimensions
var requiredWidth = maxWidth * charWidth
var requiredHeight = maxHeight + 8  # Extra space for status/controls

# Get viewport and font metrics
var viewportWidth = getViewportPixelWidth()
var viewportHeight = getViewportPixelHeight()
var charPixelWidth = getCharPixelWidth()
var charPixelHeight = getCharPixelHeight()

# Calculate optimal scale to fit game in viewport
var scaleX = viewportWidth / (requiredWidth * charPixelWidth)
var scaleY = viewportHeight / (requiredHeight * charPixelHeight)

# Use the smaller scale to ensure everything fits
var scale = scaleX
if scaleY < scaleX:
  scale = scaleY

# Apply scale (clamp to reasonable range)
if scale > 1.0 and scale < 3.0:
  setFontScale(scale)
```

```nim on:input
# Handle input
if event.type == "mouse":
  var mouseAction = event.action
  
  if mouseAction == "press":
    # Mouse position is available as global variables mouseX and mouseY
    # (they are automatically injected by the runtime)
    
    # Check if clicking on button areas at top
    var buttonY = 0
    if mouseY == buttonY:
      # Ââç button (chars 2-4)
      if mouseX >= 2 and mouseX <= 4:
        if isLevelPack:
          loadPrevLevel()
          return true
      # Ê¨° button (chars 7-9)
      elif mouseX >= 7 and mouseX <= 9:
        if isLevelPack:
          loadNextLevel()
          return true
      # Âæ©‚Üª button (right-aligned)
      elif mouseX >= termWidth - 4:
        if isLevelPack and len(levelPack) > 0:
          parseLevel(levelPack[currentLevelIndex])
        else:
          parseLevel(currentLevelData)
        return true
    
    # Calculate offset to match rendering
    var offsetX = (termWidth - (levelWidth * charWidth)) / 2
    var availableHeight = termHeight - 2
    var offsetY = (availableHeight - levelHeight) / 2 + 1
    
    # Convert screen coordinates to grid coordinates (accounting for charWidth)
    var gridX = (mouseX - offsetX) / charWidth
    var gridY = mouseY - offsetY
    
    # Validate grid position
    if gridX >= 0 and gridX < levelWidth and gridY >= 0 and gridY < levelHeight:
      var handled = handleClick(gridX, gridY)
      if handled:
        return true
  
  return false

elif event.type == "text":
  var key = event.text
  
  # Restart
  if key == "r" or key == "R":
    if isLevelPack and len(levelPack) > 0:
      parseLevel(levelPack[currentLevelIndex])
    else:
      parseLevel(currentLevelData)
    return true
  
  # Level pack navigation - Next
  elif key == "n" or key == "N" or key == "+":
    if isLevelPack:
      loadNextLevel()
      return true
  # Level pack navigation - Previous
  elif key == "p" or key == "P" or key == "-":
    if isLevelPack:
      loadPrevLevel()
      return true
  
  return false

elif event.type == "key":
  if event.action == "press":
    var code = event.keyCode
    
    # Arrow keys - use KEY_* constants for portability
    if code == KEY_UP:
      if tryMove(0, -1):
        return true
    elif code == KEY_DOWN:
      if tryMove(0, 1):
        return true
    elif code == KEY_LEFT:
      if tryMove(-1, 0):
        return true
    elif code == KEY_RIGHT:
      if tryMove(1, 0):
        return true
    # Next level: Enter/Return
    elif code == KEY_ENTER:
      if isLevelPack:
        loadNextLevel()
        return true
    # Previous level: Backspace or Delete
    elif code == KEY_BACKSPACE or code == KEY_DELETE:
      if isLevelPack:
        loadPrevLevel()
        return true
  
  return false

return false
```

```nim on:render
# Clear screen
clear()

# Increment frame counter for smooth animation every frame
frameCount = frameCount + 1

# Calculate animation offset for win state
var animOffset = 0
if gameWon:
  var time = now()
  var second = time.second
  # Cycle through array positions every second
  animOffset = second mod len(outsideChars)

# Calculate rendering offset to center the level (both horizontal and vertical)
# For double-width chars, ensure offsetX aligns to character boundaries
var offsetX = (termWidth - (levelWidth * charWidth)) / 2
if charWidth == 2 and (offsetX mod 2) != 0:
  offsetX = offsetX - 1  # Align to even position for double-width chars
# Reserve line 0 for status, line termHeight-1 for buttons
var availableHeight = termHeight - 2
var offsetY = (availableHeight - levelHeight) / 2 + 1

# Fill top area with outside chars (if offsetY > 1)
var topY = 1
while topY < offsetY:
  var fillX = 0
  while fillX < termWidth:
    draw(0, fillX, topY, getRandomOutsideChar(fillX, topY, animOffset), styleOutside)
    fillX = fillX + charWidth
  topY = topY + 1

# Render the game area with outside borders
var y = 0
while y < levelHeight:
  # Draw outside area on the left
  var leftX = 0
  while leftX < offsetX:
    draw(0, leftX, offsetY + y, getRandomOutsideChar(leftX, offsetY + y, animOffset), styleOutside)
    leftX = leftX + charWidth
  
  # Draw the game grid
  var x = 0
  while x < levelWidth:
    var ch = floorChar
    var style = styleFloor
    
    # Check player position first (highest priority)
    if x == playerX and y == playerY:
      if isGoal(x, y):
        ch = playerOnGoalChar
        style = stylePlayerGoal
      else:
        ch = playerChar
        style = stylePlayer
    # Check box position
    elif hasBox(x, y):
      if isGoal(x, y):
        ch = boxOnGoalChar
        style = styleBoxGoal
      else:
        ch = boxChar
        style = styleBox
    # Check goal position
    elif isGoal(x, y):
      ch = goalChar
      style = styleGoal
    # Check wall position
    elif hasWall(x, y):
      ch = wallChar
      style = styleWall
    # Check if unreachable area (outside)
    elif not isReachable(x, y):
      ch = getRandomOutsideChar(x, y, animOffset)
      style = styleOutside
    
    # Draw the character (layer 0, accounting for charWidth)
    draw(0, offsetX + (x * charWidth), offsetY + y, ch, style)
    x = x + 1
  
  # Draw outside area on the right
  var rightX = offsetX + (levelWidth * charWidth)
  while rightX < termWidth:
    draw(0, rightX, offsetY + y, getRandomOutsideChar(rightX, offsetY + y, animOffset), styleOutside)
    rightX = rightX + charWidth
  
  y = y + 1

# Fill bottom area with outside chars
var bottomY = offsetY + levelHeight
while bottomY < termHeight - 1:
  var fillX = 0
  while fillX < termWidth:
    draw(0, fillX, bottomY, getRandomOutsideChar(fillX, bottomY, animOffset), styleOutside)
    fillX = fillX + charWidth
  bottomY = bottomY + 1

# Show clickable buttons at top (line 0) with kanji
var buttonY = 0
var accentStyle = getStyle("accent2")
# Left buttons: Previous and Next
draw(0, 0, buttonY, "< ", defaultStyle())
draw(0, 2, buttonY, "Ââç", accentStyle)
draw(0, 4, buttonY, " | ", defaultStyle())
draw(0, 7, buttonY, "Ê¨°", accentStyle)
draw(0, 9, buttonY, " >", defaultStyle())
# Right button: Restart with circular arrow
var restartX = termWidth - 4
if restartX > 0:
  draw(0, restartX, buttonY, "Âæ©", accentStyle)
  draw(0, restartX + 2, buttonY, "‚Üª", defaultStyle())

# Show win message below the level
var statusY = offsetY + levelHeight + 1
if gameWon:
  var winText = "ÂÆå Level Complete!"
  var winX = offsetX + ((levelWidth * charWidth) - len(winText)) / 2
  draw(0, winX, statusY, winText, stylePlayer)

# Show level indicator and move count on bottom line (plain ASCII only, centered)
var statusY = termHeight - 1
if isLevelPack:
  var levelNum = $(currentLevelIndex + 1) & "/" & $len(levelPack)
  var statusText = levelNum
  # Add move counter if there are moves
  if moveCount > 0:
    statusText = statusText & " > " & $moveCount
  var statusX = (termWidth - len(statusText)) / 2
  draw(0, statusX, statusY, statusText, defaultStyle())
```
---
title: "Style System Demo"
targetFPS: 30
styles.heading1.fg: "#FFFF00"
styles.heading1.bold: "true"
styles.heading2.fg: "#00FFFF"
styles.heading2.bold: "true"
styles.success.fg: "#00FF00"
styles.success.bold: "true"
styles.error.fg: "#FF0000"
styles.error.bold: "true"
styles.warning.fg: "#FFA500"
styles.info.fg: "#64C8FF"
styles.muted.fg: "#808080"
styles.muted.dim: "true"
styles.counter.fg: "#FFFFFF"
styles.counter.bg: "#0000ff"
theme: "catppuccin"
---

# Styles Demo

This example demonstrates t|Storie's style system with front matter configuration. Theme selection sets defaults which are overriden by specifying styles during draw() operations.


```nim on:init
var counter = 0
```

```nim on:update
counter = counter + 1
```

```nim on:render
clear()

# Use predefined styles from front matter
var h1Style = getStyle("heading1")
var h2Style = getStyle("heading2")
var successStyle = getStyle("success")
var errorStyle = getStyle("error")
var warningStyle = getStyle("warning")
var infoStyle = getStyle("info")
var mutedStyle = getStyle("muted")
var counterStyle = getStyle("counter")

# Title with heading style
draw(0, 5, 2, "=== STYLE SYSTEM DEMO ===", h1Style)

# Section headings
draw(0, 5, 4, "Message Types:", h2Style)

# Different message styles
draw(0, 7, 6, "[SUCCESS] Operation completed", successStyle)
draw(0, 7, 7, "[ERROR] Something went wrong", errorStyle)
draw(0, 7, 8, "[WARNING] Please check this", warningStyle)
draw(0, 7, 9, "[INFO] For your information", infoStyle)

# Normal text
draw(0, 5, 11, "Counter with default style: " & $counter, counterStyle)

# Muted footer
draw(0, 5, 13, "Tip: Edit styles in the front matter!", mutedStyle)

# Color palette demo
draw(0, 5, 15, "Available Colors:", h2Style)
draw(0, 7, 17, "Red      ", getStyle("error"))
draw(0, 7, 18, "Green    ", getStyle("success"))
draw(0, 7, 19, "Yellow   ", getStyle("heading1"))
draw(0, 7, 20, "Cyan     ", getStyle("heading2"))
draw(0, 7, 21, "Orange   ", getStyle("warning"))
draw(0, 7, 22, "Blue     ", getStyle("info"))
draw(0, 7, 23, "Gray     ", getStyle("muted"))
```
# Progressive Loading Test - ASCII Only

This demo uses only ASCII characters to test that the core build is sufficient.

## Test Cases

### 1. Simple ASCII Text
```nimini
var message = "Hello, World!"
echo message
```

### 2. ASCII Art
```nimini
echo """
  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  ‚ïë  ASCII TEST   ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
"""
```

### 3. Progress Animation
```nimini
for i in 0..10:
  write "\r["
  write "=".repeat(i)
  write " ".repeat(10-i)
  write "] " & $i & "0%"
  sleep 100
echo ""
```

### Expected Behavior

‚úÖ Should load **ONLY** core module (1.9MB)
‚úÖ Should render immediately (~800ms)
‚úÖ Should NOT load TTF module
‚úÖ Should show "No additional plugins needed"

---

**Test Status:** ASCII-only content
**Expected Size:** 1.9MB
**Expected Modules:** core only
# Progressive Loading Test - Unicode Required

This demo uses Unicode and emoji to trigger TTF loading.

## Test Cases

### 1. Emoji Test üöÄ
```nimini
echo "Progressive loading works! üéâ"
echo "Fast startup: ‚ö°"
echo "Smart loading: üß†"
```

### 2. Unicode Characters
```nimini
echo "Japanese: „Åì„Çì„Å´„Å°„ÅØ‰∏ñÁïå"
echo "Chinese: ‰Ω†Â•Ω‰∏ñÁïå"
echo "Arabic: ŸÖÿ±ÿ≠ÿ®ÿß ÿ®ÿßŸÑÿπÿßŸÑŸÖ"
```

### 3. Mixed Content
```nimini
echo "ASCII: Hello"
echo "Unicode: ‰Ω†Â•Ω"
echo "Emoji: üòÄüî•‚ú®"
```

### Expected Behavior

‚úÖ Should load core first (1.9MB, ~800ms)
‚úÖ Should START RENDERING with ASCII
‚úÖ Should detect unicode/emoji in content
‚úÖ Should load TTF module in background (3.4MB total)
‚úÖ Should seamlessly upgrade to TTF rendering
‚úÖ Should show "Loading plugins: ttf..."

---

**Test Status:** Unicode content detected
**Expected Size:** 3.4MB (core + TTF)
**Expected Modules:** core, ttf
**Progressive:** Core renders first, TTF loads in background
---
title: "Edit Demo Key Test"
theme: "catppuccin"
---

Quick test for edit.md key handling system.

```nim on:init
var testResults: seq[string] = @[]
var testsPassed = 0
var testsFailed = 0

# Test that KEY constants are accessible
proc testKeyConstants() =
  # Arrow keys (1000-1003)
  if KEY_UP == 1000:
    add(testResults, "‚úì KEY_UP = 1000")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_UP != 1000")
    testsFailed = testsFailed + 1
  
  if KEY_DOWN == 1001:
    add(testResults, "‚úì KEY_DOWN = 1001")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_DOWN != 1001")
    testsFailed = testsFailed + 1
  
  if KEY_LEFT == 1002:
    add(testResults, "‚úì KEY_LEFT = 1002")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_LEFT != 1002")
    testsFailed = testsFailed + 1
  
  if KEY_RIGHT == 1003:
    add(testResults, "‚úì KEY_RIGHT = 1003")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_RIGHT != 1003")
    testsFailed = testsFailed + 1
  
  # Navigation keys
  if KEY_HOME == 1004:
    add(testResults, "‚úì KEY_HOME = 1004")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_HOME != 1004")
    testsFailed = testsFailed + 1
  
  if KEY_END == 1005:
    add(testResults, "‚úì KEY_END = 1005")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_END != 1005")
    testsFailed = testsFailed + 1
  
  if KEY_PAGEUP == 1006:
    add(testResults, "‚úì KEY_PAGEUP = 1006")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_PAGEUP != 1006")
    testsFailed = testsFailed + 1
  
  if KEY_PAGEDOWN == 1007:
    add(testResults, "‚úì KEY_PAGEDOWN = 1007")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_PAGEDOWN != 1007")
    testsFailed = testsFailed + 1
  
  # Function keys
  if KEY_F1 == 1100:
    add(testResults, "‚úì KEY_F1 = 1100")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_F1 != 1100")
    testsFailed = testsFailed + 1
  
  # Control keys
  if KEY_ESCAPE == 27:
    add(testResults, "‚úì KEY_ESCAPE = 27")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_ESCAPE != 27")
    testsFailed = testsFailed + 1
  
  if KEY_RETURN == 13:
    add(testResults, "‚úì KEY_RETURN = 13")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_RETURN != 13")
    testsFailed = testsFailed + 1
  
  if KEY_BACKSPACE == 8:
    add(testResults, "‚úì KEY_BACKSPACE = 8")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_BACKSPACE != 8")
    testsFailed = testsFailed + 1
  
  if KEY_DELETE == 127:
    add(testResults, "‚úì KEY_DELETE = 127")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_DELETE != 127")
    testsFailed = testsFailed + 1
  
  # Letter keys
  if KEY_S == 83:
    add(testResults, "‚úì KEY_S = 83")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_S != 83")
    testsFailed = testsFailed + 1
  
  if KEY_O == 79:
    add(testResults, "‚úì KEY_O = 79")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_O != 79")
    testsFailed = testsFailed + 1
  
  if KEY_Q == 81:
    add(testResults, "‚úì KEY_Q = 81")
    testsPassed = testsPassed + 1
  else:
    add(testResults, "‚úó KEY_Q != 81")
    testsFailed = testsFailed + 1

# Run tests
testKeyConstants()
```

```nim on:render
clear()

moveCursor(0, 0)
setFg(3)  # cyan
write("=== Edit.md Key Constant Test ===")

var y = 2
var i = 0
while i < len(testResults):
  moveCursor(0, y)
  let result = testResults[i]
  if result[0] == '‚úì':
    setFg(2)  # green
  else:
    setFg(1)  # red
  write(result)
  y = y + 1
  i = i + 1

moveCursor(0, y + 1)
setFg(7)
write("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")

moveCursor(0, y + 2)
if testsFailed == 0:
  setFg(2)
  write("‚úì All tests passed! (" & str(testsPassed) & "/" & str(testsPassed) & ")")
else:
  setFg(1)
  write("‚úó Some tests failed: " & str(testsPassed) & " passed, " & str(testsFailed) & " failed")

moveCursor(0, y + 4)
setFg(7)
write("Press Q or ESC to quit")
```

```nim on:input
if event.type == "key":
  if event.keyCode == KEY_Q or event.keyCode == KEY_ESCAPE:
    exit()
return false
```
---
title: "Theme Demo"
author: "Maddest Labs"
minWidth: 80
minHeight: 24
theme: "catpuccin"
---

```nim on:init
# Canvas-based Presentation System using Nimini
# Navigate with arrow keys: Left/Right for main topics, Up/Down for subtopics

# Get available themes
var themes = getThemes()
var currentThemeIndex = 0

# Find index of current theme
var currentTheme = getCurrentTheme()
if currentTheme == "":
  currentTheme = "catppuccin"

var i = 0
while i < len(themes):
  if themes[i] == currentTheme:
    currentThemeIndex = i
  i = i + 1

# Initialize canvas in presentation mode
# Second parameter = starting section (1 for first real section)
# Third parameter = presentation mode (true)
initCanvas(1, true)
```

```nim on:input
# Handle keyboard and mouse input for canvas navigation

if event.type == "key":
  lastKeyCode = event.keyCode
  lastKey = str(lastKeyCode)
  lastAction = event.action
  if lastKeyCode == 9:
    currentThemeIndex = (currentThemeIndex + 1) % len(themes)
    var newTheme = themes[currentThemeIndex]
    switchTheme(newTheme)
    clear()
    return true
    
    # Pass key events to canvas system
    var handled = canvasHandleKey(event.keyCode, 0)
    if handled:
      return true
  return false

elif event.type == "mouse":
  if event.action == "press":
    # Pass mouse events to canvas system (only on press, not release)
    var handled = canvasHandleMouse(event.x, event.y, event.button, true)
    if handled:
      return true
  return false

return false
```

```nim on:render
clear()

canvasRender()

# Show current theme name in top-right corner
var style = defaultStyle()
style.fg = rgb(255, 255, 100)
style.bold = true
var themeName = themes[currentThemeIndex]
draw(0, termWidth - len(themeName) - 15, 1, "Theme: " & themeName, style)
draw(0, termWidth - 15, 2, "Press TAB to cycle", style)
```

```nim on:update
canvasUpdate()
```

# üé® Theme System Demo

Welcome to the TStorie theme system! This demo uses the **Catppuccin Mocha** theme by default.

**‚ú® NEW: Live Theme Switching! ‚ú®**  
Press **T** to cycle through all available themes in real-time!

## What Are Themes?

Themes provide a complete color palette for your documents. Instead of manually defining colors for every element, just set:

```
theme: "catppuccin"
```

And you get beautiful, accessible colors automatically!

## Available Themes

Try these in your own documents (or press **T** to see them live!):

- **catppuccin** - Soft, modern (current theme!)
- **nord** - Cool Arctic palette
- **dracula** - Vibrant developer favorite
- **miami-vice** - Bold 80s cyberpunk
- **outrun** - Neon synthwave aesthetic
- **cyberpunk** - Classic duotone
- **terminal** - Classic green CRT
- **solarized-dark** - Elegant Solarized

## Live Theme Switching API

You can switch themes at runtime using Nimini functions:

```nim
# Get list of available themes
var themes = getThemes()

# Switch to a specific theme
switchTheme("nord")

# Get current theme name
var current = getCurrentTheme()
```

This enables:
- Interactive theme pickers
- Dynamic theme changes based on user input
- Theme cycling in presentations
- Context-aware theming

## Features

### Automatic Styling

All these elements are automatically styled:

- **Bold text** uses accent colors
- *Italic text* maintains readability
- `Code snippets` have distinct backgrounds
- Regular text is optimized for long reading

### Interactive Elements

Navigation links are automatically themed too:

- [Home](#home)
- [About](#about)
- [Contact](#contact)

### Hierarchical Headings

Headings at different levels use different accent colors:

#### This is an H4
##### This is an H5
###### This is an H6

## Override When Needed

You can still override individual styles:

```markdown
---
theme: "catppuccin"
styles.heading.fg: "#FF0080"  # Custom hot pink!
---
```

## Why Use Themes?

‚úÖ **Instant visual consistency**  
‚úÖ **Professional color harmony**  
‚úÖ **Accessible contrast ratios**  
‚úÖ **Easy to change entire look**  
‚úÖ **Focus on content, not colors**

## Try It Yourself!

Edit this file's front matter to try different themes:

```yaml
---
theme: "nord"        # Try this!
# or
theme: "miami-vice"  # Or this!
# or
theme: "cyberpunk"   # Or this!
---
```

Each theme provides a completely different aesthetic while maintaining readability and usability!

---

*This demo showcases the theme system. See THEME_GUIDE.md for complete documentation.*
---
title: "ToxiClock"
author: "Maddest Labs"
fontsize: 26
---
# Highly Toxic Digital Clock with Embedded Figlet Font

```nim on:init
var fontLoaded = figletLoadFont("poison")
var debugMsg = "Font loaded: " & $fontLoaded

# Pre-calculate static centering using widest possible time string
var maxWidthLines = figletRender("poison", "88:88:88")

# Initialize particle system for rising bubbles effect
particleInit("toxins", 100)
var accentStyle = getStyle("accent1")
var defaultStyle = getStyle("default")

# Configure fire effect rising from bottom
particleConfigureFire("toxins", 10.0, false)
particleSetBackgroundFromStyle("toxins", defaultStyle)
particleSetForegroundFromStyle("toxins", accentStyle)
particleSetEmitterPos("toxins", 0, termHeight)
particleSetEmitterSize("toxins", termWidth, float(termHeight) / 2)
particleSetLifeRange("toxins", 3.0, 5.0)
particleSetVelocityRange("toxins", 0.0, -10.0, 0.0, -25.0)
particleSetChars("toxins", "....o")

# Initialize displacement shader for watery distortion effect
# Effect 0 = Horizontal Wave (ocean waves)
var displayLayer = 0
initDisplacement(0, displayLayer, 0, 0, termWidth, termHeight, 0.6)

# Dripping character effect system
type DripChar = object
  char: string
  startX: int
  startY: int
  currentY: float
  age: float
  lifetime: float

type CharPos = object
  x: int
  y: int
  char: string

var dripChars: seq[DripChar] = @[]
var timeSinceLastDrip = 0.0
var dripInterval = 1.5  # seconds between drips
var maxDrips = 15  # maximum concurrent drips

# Store clock position for drip calculations
var clockStartX = 0
var clockStartY = 10
```

```nim on:render
clear()

# Render particle effect in background
particleRender("toxins", "default")

# Get current time
var time = now()
var hour = time.hour
var minute = time.minute
var second = time.second

# Format time string
var timeStr = ""
if hour < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $hour & ":"
if minute < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $minute & ":"
if second < 10:
  timeStr = timeStr & "0"
timeStr = timeStr & $second

# Render and draw figlet text
var lines = figletRender("poison", timeStr)

# Calculate centering
var clockWidth = 0
var clockHeight = len(lines)
if clockHeight > 0:
  clockWidth = len(lines[0])
var startX = 0
if clockWidth < termWidth:
  var diff = termWidth - clockWidth
  startX = diff / 2

var startY = 10
if clockHeight < termHeight:
  var diff = termHeight - clockHeight
  startY = diff / 2

# Store for drip calculations
clockStartX = startX
clockStartY = startY

# Draw using helper function
if clockHeight > 0:
  drawFigletText(0, startX, startY, "poison", timeStr, 0, getStyle("accent1"))
else:
  draw(0, 2, 8, "No lines to render!")

# Render dripping characters on top
for drip in dripChars:
  if drip.age <= drip.lifetime:
    # Easing function: ease-out cubic for smooth deceleration
    var t = drip.age / drip.lifetime
    var easedT = 1.0 - pow(1.0 - t, 3.0)
    
    # Calculate drop distance (fall off screen)
    var dropDistance = float(termHeight - drip.startY + 5)
    var yPos = int(float(drip.startY) + easedT * dropDistance)
    
    # Fade out as it falls (optional - adds to the toxic dissolution effect)
    var alpha = 1.0 - (t * 0.7)  # fade to 30% opacity
    
    if yPos < termHeight:
      draw(0, drip.startX, yPos, drip.char, getStyle("accent1"))

# Apply watery displacement effect to entire screen
drawDisplacementInPlace("default")
```

```nim on:update
# Update displacement animation for watery wave effect
updateDisplacement()

# Update particle emitter position at bottom of screen
particleSetEmitterPos("toxins", 0.0, float(termHeight - 1))
particleSetEmitterSize("toxins", float(termWidth), 1.0)
particleUpdate("toxins", deltaTime)

# Update dripping characters
timeSinceLastDrip = timeSinceLastDrip + deltaTime

# Create new drip every 1-2 seconds
if timeSinceLastDrip >= dripInterval and len(dripChars) < maxDrips:
  # Get current time for figlet rendering
  var time = now()
  var hour = time.hour
  var minute = time.minute
  var second = time.second
  
  var timeStr = ""
  if hour < 10:
    timeStr = timeStr & "0"
  timeStr = timeStr & $hour & ":"
  if minute < 10:
    timeStr = timeStr & "0"
  timeStr = timeStr & $minute & ":"
  if second < 10:
    timeStr = timeStr & "0"
  timeStr = timeStr & $second
  
  # Render the figlet text to get character positions
  var figletLines = figletRender("poison", timeStr)
  
  if len(figletLines) > 0:
    # Collect all non-space characters with their positions
    var charPositions: seq[CharPos] = @[]
    
    for lineIdx in 0..<len(figletLines):
      var line = figletLines[lineIdx]
      for colIdx in 0..<len(line):
        var ch = $line[colIdx]
        if ch != " " and ch != "$":
          var pos: CharPos
          pos.x = clockStartX + colIdx
          pos.y = clockStartY + lineIdx
          pos.char = ch
          charPositions.add(pos)
    
    # Pick a random character to drip
    if len(charPositions) > 0:
      var randomIdx = rand(len(charPositions) - 1)
      var selectedChar = charPositions[randomIdx]
      
      # Create new dripping character
      var newDrip: DripChar
      newDrip.char = selectedChar.char
      newDrip.startX = selectedChar.x
      newDrip.startY = selectedChar.y
      newDrip.currentY = float(selectedChar.y)
      newDrip.age = 0.0
      newDrip.lifetime = 2.0 + rand(1.0)  # 2-3 seconds to fall
      
      dripChars.add(newDrip)
      
      # Randomize next drip interval (1-2 seconds)
      dripInterval = 1.0 + rand(1.0)
      timeSinceLastDrip = 0.0

# Update existing drips
var activeDrips: seq[DripChar] = @[]
for drip in dripChars:
  var updatedDrip = drip
  updatedDrip.age = updatedDrip.age + deltaTime
  
  # Keep drip if it's still active
  if updatedDrip.age <= updatedDrip.lifetime + 0.5:  # keep a bit longer for complete fall
    activeDrips.add(updatedDrip)

dripChars = activeDrips
```

```figlet:poison
flf2a$ 12 10 20 -1 14
poison.flf composed into figlet by Vinney Thai <ssfiit@eris.cc.umb.edu>
poison font (numbers & puntuation marks) composed by Vinney Thai
poison font (uppercase characters) composed David Issel <dissel@nunic.nu.edu>
date: Oct 23, 1994
Explanation of first line:
flf2 - "magic number" for file identification
a    - should always be `a', for now
$    - the "hardblank" -- prints as a blank, but can't be smushed
12   - height of a character
10   - height of a character, not including descenders
20   - max line length (excluding comment lines) + a fudge factor
-1   - default smushmode for this font (like "-m 0" on command line)
15   - number of comment lines

$ $@
$ $@
$ $@
$ $@
$ $@
$ $@
$ $@
$ $@
$ $@
$ $@
$ $@
$ $@@
     @
@@@ $@
@@@ $@
@@! $@
!@  $@
@!@ $@
!!! $@
     @
:!: $@
 :: $@
::: $@
     @@
         @
@@@ @@@ $@
@@@ @@@ $@
@@! @@! $@
 @!  @! $@
  $   $  @
  $   $  @
  $   $  @
  $   $  @
  $   $  @
  $   $  @
         @@
              @
  @@@  @@@ $  @
  @@@  @@@ $  @
@!@@!@!@@@@! $@
!@!@!!@@!@!@ $@
  @!@  !@! $  @
  !!!  !!! $  @
!:!!:!:!!!!: $@
:!:!::!!:!:! $@
  ::   ::: $  @
   :   : : $  @
              @@
            @
    @@ $    @
 @@@@@@@@@ $@
!@@!@@!@@! $@
!@! !@ $    @
!!!@@!!!! $ @
 !!!@@@!!! $@
    !: !:! $@
!:!!:!: :! $@
: :::: :: $ @
    :: $    @
            @@
              @
@@@@     @@@ $@
@@@@    @@@ $ @
@@!@   @@! $  @
      !@! $   @
     @!! $    @
    !!! $     @
   !!: $      @
  ::!   ::!: $@
  ::    :::  $@
: :     : :: $@
              @@
             @
  @@@@@ $    @
 @@@@@@@ $   @
@@!   @@@ $  @
 !@  @!@ $   @
  @!@!@ $    @
  !!!@  !!! $@
 !!:!!:!!: $ @
:!:  !:!: $  @
::: :::::: $ @
 ::: :: ::: $@
             @@
     @
@@@ $@
 @@ $@
@! $ @
 $   @
 $   @
 $   @
 $   @
 $   @
 $   @
 $   @
     @@
        @
   @@@ $@
  @@@ $ @
 @@! $  @
!@! $   @
!!@ $   @
!!! $   @
!!: $   @
 :!: $  @
   :: $ @
     : $@
        @@
        @
@@@ $   @
 @@@ $  @
  @@! $ @
   !@! $@
   !!@ $@
   !!! $@
   !!: $@
  :!: $ @
 :: $   @
: $     @
        @@
            @
            @
@@!    !@@ $@
 !@!  @!! $ @
  !@@!@! $  @
@!@!@!!@!! $@
  !: :!! $  @
 :!:  !:! $ @
:::    ::: $@
            @
            @
            @@
           @
           @
           @
   @@! $   @
   !@! $   @
@!@!@!@!@ $@
!!!@!@!!! $@
   !!: $   @
   :!: $   @
           @
           @
           @@
     @
     @
     @
     @
     @
     @
     @
     @
:!: $@
 :: $@
:: $ @
     @@
           @
           @
           @
           @
           @
@!@!@!@!@ $@
!!!@!@!!! $@
           @
           @
           @
           @
           @@
     @
     @
     @
     @
     @
     @
     @
     @
:!: $@
::: $@
::: $@
     @@
              @
         @@@ $@
        @@@ $ @
       @@! $  @
      !@! $   @
     @!! $    @
    !!! $     @
   !!: $      @
  ::! $       @
  :: $        @
: : $         @
              @@
            @
 @@@@@@@@ $ @
@@@@@@@@@@ $@
@@!   @@@@ $@
!@!  @!@!@ $@
@!@ @! !@! $@
!@!!!  !!! $@
!!:!   !!! $@
:!:    !:! $@
::::::: :: $@
 : : :  : $ @
            @@
       @
  @@@ $@
 @@@@ $@
@@@!! $@
  !@! $@
  @!@ $@
  !@! $@
  !!: $@
  :!: $@
  ::: $@
   :: $@
       @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
     @@@ $@
    @!@ $ @
   !!@ $  @
  !!: $   @
 !:! $    @
:!: $     @
:: ::::: $@
:: : ::: $@
          @@
         @
@@@@@@ $ @
@@@@@@@ $@
    @@@ $@
    @!@ $@
@!@!!@ $ @
!!@!@! $ @
    !!: $@
    :!: $@
:: :::: $@
 : : : $ @
         @@
           @
     @@@ $ @
    @@@@ $ @
   @@!@! $ @
  !@!!@! $ @
 @!! @!! $ @
!!!  !@! $ @
:!!:!:!!: $@
!:::!!::: $@
     ::: $ @
     ::: $ @
           @@
         @
@@@@@@@ $@
@@@@@@@ $@
!@@ $    @
!@! $    @
!!@@!! $ @
@!!@!!! $@
    !:! $@
    !:! $@
:::: :: $@
:: : : $ @
         @@
          @
  @@@@@@ $@
 @@@@@@@ $@
!@@ $     @
!@! $     @
!!@@!@! $ @
@!!@!!!! $@
!:!  !:! $@
:!:  !:! $@
:::: ::: $@
 :: : : $ @
          @@
          @
@@@@@@@@ $@
@@@@@@@@ $@
     @@! $@
    !@! $ @
   @!! $  @
  !!! $   @
 !!: $    @
:!: $     @
 :: $     @
: : $     @
          @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
 !@!!@! $ @
 !!@!!! $ @
!!:  !!! $@
:!:  !:! $@
::::: :: $@
 : :  : $ @
          @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
!!@!!@!! $@
  !!@!!! $@
     !!! $@
     !:! $@
::::: :: $@
 : :  : $ @
          @@
     @
     @
     @
     @
@!@ $@
!@! $@
!:! $@
 $$  @
:!: $@
::: $@
::: $@
     @@
     @
     @
     @
     @
@!@  @
!@! $@
:!: $@
 $$  @
:!: $@
 :: $@
:: $ @
     @@
             @
        @@@ $@
      @@@ $  @
    @@! $    @
  !@! $      @
!!@ $        @
!!! $        @
  !!: $      @
    :!: $    @
      :: $   @
        : $  @
             @@
           @
           @
           @
           @
!@!!@!!@! $@
@!@!@!@!@ $@
 $      $  @
!!:!!::!! $@
::!:!:!!: $@
           @
           @
           @@
             @
@@@ $        @
  @@@ $      @
    @@! $    @
      !@! $  @
        !!@ $@
        !!! $@
      !!: $  @
    :!: $    @
  :: $       @
: $          @
             @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
    @!@ $ @
   !!@ $  @
  !!@ $   @
          @
  !:! $   @
   :: $   @
  ::: $   @
          @@
            @
 @@@@@@@@ $ @
@@@@@@@@@@ $@
@@!    @@@ $@
!@! @!@!!@ $@
@!@ !@@!@! $@
!@! @@!@!! $@
!!:  !:!! $ @
:!: $       @
:::::::::: $@
 : : :: : $ @
            @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@!@!@! $@
!!!@!!!! $@
!!:  !!! $@
:!:  !:! $@
::   ::: $@
 :   : : $@
          @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@   @!@ $@
@!@!@!@ $ @
!!!@!!!! $@
!!:  !!! $@
:!:  !:! $@
 :: :::: $@
:: : :: $ @
          @@
          @
 @@@@@@@ $@
@@@@@@@@ $@
!@@ $     @
!@! $     @
!@! $     @
!!! $     @
:!! $     @
:!: $     @
 ::: ::: $@
 :: :: : $@
          @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
 :::: :: $@
:: :  : $ @
          @@
          @
@@@@@@@@ $@
@@@@@@@@ $@
@@! $     @
!@! $     @
@!!!:! $  @
!!!!!: $  @
!!: $     @
:!: $     @
 :: :::: $@
: :: :: $ @
          @@
          @
@@@@@@@@ $@
@@@@@@@@ $@
@@! $     @
!@! $     @
@!!!:! $  @
!!!!!: $  @
!!: $     @
:!: $     @
 :: $     @
 : $      @
          @@
           @
 @@@@@@@@ $@
@@@@@@@@@ $@
!@@ $      @
!@! $      @
!@! @!@!@ $@
!!! !!@!! $@
:!!   !!: $@
:!:   !:: $@
 ::: :::: $@
 :: :: : $ @
           @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@!@!@! $@
!!!@!!!! $@
!!:  !!! $@
:!:  !:! $@
::   ::: $@
 :   : : $@
          @@
     @
@@@ $@
@@@ $@
@@! $@
!@! $@
!!@ $@
!!! $@
!!: $@
:!: $@
 :: $@
: $  @
     @@
          @
     @@@ $@
     @@@ $@
     @@! $@
     !@! $@
     !!@ $@
     !!! $@
     !!: $@
!!:  :!: $@
::: : :: $@
 : ::: $  @
          @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  !@@ $@
!@!  @!! $@
@!@@!@! $ @
!!@!!! $  @
!!: :!! $ @
:!:  !:! $@
 ::  ::: $@
 :   ::: $@
          @@
          @
@@@      $@
@@@      $@
@@!      $@
!@!      $@
@!!      $@
!!!      $@
!!:      $@
 :!:     $@
 :: :::: $@
: :: : : $@
          @@
             @
@@@@@@@@@@ $ @
@@@@@@@@@@@ $@
@@! @@! @@! $@
!@! !@! !@! $@
@!! !!@ @!@ $@
!@!   ! !@! $@
!!:     !!: $@
:!:     :!: $@
:::     :: $ @
 :      : $  @
             @@
          @
@@@  @@@ $@
@@@@ @@@ $@
@@!@!@@@ $@
!@!!@!@! $@
@!@ !!@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
 ::   :: $@
::    : $ @
          @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
::::: :: $@
 : :  : $ @
          @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@@!@! $ @
!!@!!! $  @
!!: $     @
:!: $     @
 :: $     @
 : $      @
          @@
           @
 @@@@@@ $  @
@@@@@@@@ $ @
@@!  @@@ $ @
!@!  @!@ $ @
@!@  !@! $ @
!@!  !!! $ @
!!:!!:!: $ @
:!: :!:  $ @
::::: :! $ @
 : :  ::: $@
           @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@!!@! $ @
!!@!@! $  @
!!: :!! $ @
:!:  !:! $@
::   ::: $@
 :   : : $@
          @@
          @
 @@@@@@ $ @
@@@@@@@ $ @
!@@ $     @
!@! $     @
!!@@!! $  @
 !!@!!! $ @
     !:! $@
    !:! $ @
:::: :: $ @
:: : : $  @
          @@
         @
@@@@@@@ $@
@@@@@@@ $@
  @@! $  @
  !@! $  @
  @!! $  @
  !!! $  @
  !!: $  @
  :!: $  @
   :: $  @
   : $   @
         @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
::::: :: $@
 : :  : $ @
          @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
:!:  !!: $@
 ::!!:! $ @
  :::: $  @
   : $    @
          @@
               @
@@@  @@@  @@@ $@
@@@  @@@  @@@ $@
@@!  @@!  @@! $@
!@!  !@!  !@! $@
@!!  !!@  @!@ $@
!@!  !!!  !@! $@
!!:  !!:  !!: $@
:!:  :!:  :!: $@
 :::: :: ::: $ @
  :: :  : : $  @
               @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  !@@ $@
!@!  @!! $@
 !@@!@! $ @
  @!!! $  @
 !: :!! $ @
:!:  !:! $@
 ::  ::: $@
 :   :: $ @
          @@
         @
@@@ @@@ $@
@@@ @@@ $@
@@! !@@ $@
!@! @!! $@
 !@!@! $ @
  @!!! $ @
  !!: $  @
  :!: $  @
   :: $  @
   : $   @
         @@
          @
@@@@@@@@ $@
@@@@@@@@ $@
     @@! $@
    !@! $ @
   @!! $  @
  !!! $   @
 !!: $    @
:!: $     @
 :: :::: $@
: :: : : $@
          @@
       @
@@@@@ $@
@@@@@ $@
@@! $  @
!@! $  @
@!@ $  @
!!! $  @
!!: $  @
:!: $  @
::::: $@
 : : $ @
       @@
               @
 @@@ $         @
  @@@ $        @
   @@! $       @
    !@! $      @
     @!! $     @
      !!! $    @
       !!: $   @
        ::! $  @
         :: $  @
          : : $@
               @@
       @
@@@@@ $@
@@@@@ $@
  @@! $@
  !@! $@
  @!@ $@
  !!! $@
  !!: $@
  :!: $@
::::: $@
 : : $ @
       @@
                @
     @@@@@ $    @
   @@@@ @@@@ $  @
 @!@!     @!@! $@
   $        $   @
   $        $   @
   $        $   @
   $        $   @
   $        $   @
   $        $   @
   $        $   @
                @@
               @
              $@
              $@
              $@
              $@
              $@
              $@
              $@
              $@
::::::::::::: $@
::::::::::::: $@
               @@
     @
@@@ $@
@@ $ @
 @! $@
  $  @
  $  @
  $  @
  $  @
  $  @
  $  @
  $  @
     @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@!@!@! $@
!!!@!!!! $@
!!:  !!! $@
:!:  !:! $@
::   ::: $@
 :   : : $@
          @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@   @!@ $@
@!@!@!@ $ @
!!!@!!!! $@
!!:  !!! $@
:!:  !:! $@
 :: :::: $@
:: : :: $ @
          @@
          @
 @@@@@@@ $@
@@@@@@@@ $@
!@@ $     @
!@! $     @
!@! $     @
!!! $     @
:!! $     @
:!: $     @
 ::: ::: $@
 :: :: : $@
          @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
 :::: :: $@
:: :  : $ @
          @@
          @
@@@@@@@@ $@
@@@@@@@@ $@
@@! $     @
!@! $     @
@!!!:! $  @
!!!!!: $  @
!!: $     @
:!: $     @
 :: :::: $@
: :: :: $ @
          @@
          @
@@@@@@@@ $@
@@@@@@@@ $@
@@! $     @
!@! $     @
@!!!:! $  @
!!!!!: $  @
!!: $     @
:!: $     @
 :: $     @
 : $      @
          @@
           @
 @@@@@@@@ $@
@@@@@@@@@ $@
!@@ $      @
!@! $      @
!@! @!@!@ $@
!!! !!@!! $@
:!!   !!: $@
:!:   !:: $@
 ::: :::: $@
 :: :: : $ @
           @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@!@!@! $@
!!!@!!!! $@
!!:  !!! $@
:!:  !:! $@
::   ::: $@
 :   : : $@
          @@
     @
@@@ $@
@@@ $@
@@! $@
!@! $@
!!@ $@
!!! $@
!!: $@
:!: $@
 :: $@
: $  @
     @@
          @
     @@@ $@
     @@@ $@
     @@! $@
     !@! $@
     !!@ $@
     !!! $@
     !!: $@
!!:  :!: $@
::: : :: $@
 : ::: $  @
          @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  !@@ $@
!@!  @!! $@
@!@@!@! $ @
!!@!!! $  @
!!: :!! $ @
:!:  !:! $@
 ::  ::: $@
 :   ::: $@
          @@
          @
@@@      $@
@@@      $@
@@!      $@
!@!      $@
@!!      $@
!!!      $@
!!:      $@
 :!:     $@
 :: :::: $@
: :: : : $@
          @@
             @
@@@@@@@@@@ $ @
@@@@@@@@@@@ $@
@@! @@! @@! $@
!@! !@! !@! $@
@!! !!@ @!@ $@
!@!   ! !@! $@
!!:     !!: $@
:!:     :!: $@
:::     :: $ @
 :      : $  @
             @@
          @
@@@  @@@ $@
@@@@ @@@ $@
@@!@!@@@ $@
!@!!@!@! $@
@!@ !!@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
 ::   :: $@
::    : $ @
          @@
          @
 @@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
::::: :: $@
 : :  : $ @
          @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@@!@! $ @
!!@!!! $  @
!!: $     @
:!: $     @
 :: $     @
 : $      @
          @@
           @
 @@@@@@ $  @
@@@@@@@@ $ @
@@!  @@@ $ @
!@!  @!@ $ @
@!@  !@! $ @
!@!  !!! $ @
!!:!!:!: $ @
:!: :!:  $ @
::::: :! $ @
 : :  ::: $@
           @@
          @
@@@@@@@ $ @
@@@@@@@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@!!@! $ @
!!@!@! $  @
!!: :!! $ @
:!:  !:! $@
::   ::: $@
 :   : : $@
          @@
          @
 @@@@@@ $ @
@@@@@@@ $ @
!@@ $     @
!@! $     @
!!@@!! $  @
 !!@!!! $ @
     !:! $@
    !:! $ @
:::: :: $ @
:: : : $  @
          @@
         @
@@@@@@@ $@
@@@@@@@ $@
  @@! $  @
  !@! $  @
  @!! $  @
  !!! $  @
  !!: $  @
  :!: $  @
   :: $  @
   : $   @
         @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
!!:  !!! $@
:!:  !:! $@
::::: :: $@
 : :  : $ @
          @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  @@@ $@
!@!  @!@ $@
@!@  !@! $@
!@!  !!! $@
:!:  !!: $@
 ::!!:! $ @
  :::: $  @
   : $    @
          @@
               @
@@@  @@@  @@@ $@
@@@  @@@  @@@ $@
@@!  @@!  @@! $@
!@!  !@!  !@! $@
@!!  !!@  @!@ $@
!@!  !!!  !@! $@
!!:  !!:  !!: $@
:!:  :!:  :!: $@
 :::: :: ::: $ @
  :: :  : : $  @
               @@
          @
@@@  @@@ $@
@@@  @@@ $@
@@!  !@@ $@
!@!  @!! $@
 !@@!@! $ @
  @!!! $  @
 !: :!! $ @
:!:  !:! $@
 ::  ::: $@
 :   :: $ @
          @@
         @
@@@ @@@ $@
@@@ @@@ $@
@@! !@@ $@
!@! @!! $@
 !@!@! $ @
  @!!! $ @
  !!: $  @
  :!: $  @
   :: $  @
   : $   @
         @@
          @
@@@@@@@@ $@
@@@@@@@@ $@
     @@! $@
    !@! $ @
   @!! $  @
  !!! $   @
 !!: $    @
:!: $     @
 :: :::: $@
: :: : : $@
          @@
          @
   @@@@@ $@
   @@@@@ $@
  @@! $   @
  !@! $   @
@!@ $     @
!!! $     @
  !!: $   @
  :!: $   @
   ::::: $@
    : : $ @
          @@
     @
@@@ $@
@@@ $@
@@! $@
!@! $@
 $$  @
!!! $@
!!: $@
:!: $@
:: $ @
 : $ @
     @@
          @
@@@@@ $   @
@@@@@ $   @
   @@! $  @
   !@! $  @
     @!@ $@
     !!! $@
   !!: $  @
   :!: $  @
::::: $   @
 : : $    @
          @@
               @
               @
   !@!    @!@ $@
 @!@!@!@!@!@ $ @
!!!    !@! $   @
  $      $     @
  $      $     @
  $      $     @
  $      $     @
  $      $     @
  $      $     @
               @@
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @@
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @@
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @@
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @@
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @@
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @@
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @
  @@
```---
title: "Scripted TUI Demo"
minWidth: 60
minHeight: 35
# Theme-aware demo - works with any theme!
# Try: neotopia (default), catppuccin, nord, dracula, miami-vice, outrun, etc.
theme: "neotopia"
# Custom highlight style inherits background from theme
styles.highlight.fg: "#FFFF00"
styles.highlight.bold: "true"
---

# Comprehensive TUI System

A full-featured UI widget system built with scripting of core drawing functions. This demo automatically adapts to the active theme, using standard style names that are defined for all themes: `border`, `info`, `default`, `button`, and `warning`.

```nim on:init
# ===================================================================
# Helper function to draw boxes
# ===================================================================
proc drawBox(x, y, w, h: int, style: Style) =
  draw(0, x, y, "‚îå", style)
  draw(0, x + w - 1, y, "‚îê", style)
  draw(0, x, y + h - 1, "‚îî", style)
  draw(0, x + w - 1, y + h - 1, "‚îò", style)
  
  var dx = 1
  while dx < w - 1:
    draw(0, x + dx, y, "‚îÄ", style)
    draw(0, x + dx, y + h - 1, "‚îÄ", style)
    dx = dx + 1
  
  var dy = 1
  while dy < h - 1:
    draw(0, x, y + dy, "‚îÇ", style)
    draw(0, x + w - 1, y + dy, "‚îÇ", style)
    dy = dy + 1

# ===================================================================
# Widget Types & State Arrays
# ===================================================================
# Widget types: 0=TextBox, 1=Button, 2=Slider, 3=Checkbox
var widgetTypes = @[0, 0, 2, 2, 3, 3, 1, 1]
var widgetX = @[10, 10, 10, 10, 12, 12, 15, 32]
var widgetY = @[5, 9, 13, 17, 21, 22, 26, 26]
var widgetW = @[30, 30, 30, 30, 30, 30, 15, 15]
var widgetH = @[3, 3, 3, 3, 1, 1, 3, 3]

# TextBox data (indices 0, 1)
var tbLabels = @["Name:", "Email:"]
var tbTexts = @["", ""]
var tbCursors = @[0, 0]

# Button data (indices 6, 7)
var btnLabels = @["Submit", "Clear"]

# Slider data (indices 2, 3)
var sliderLabels = @["Volume:", "Brightness:"]
var sliderMins = @[0.0, 0.0]
var sliderMaxs = @[100.0, 100.0]
var sliderValues = @[50.0, 75.0]
var sliderDragging = @[false, false]

# Checkbox data (indices 4, 5)
var cbLabels = @["Opt-in to newsletter", "Enable notifications"]
var cbChecked = @[false, true]

# Focus management
var focusIndex = 0
var widgetCount = 8

# Global state
var message = "Tab/Shift+Tab to navigate | Space/Enter to activate"
var lastEvent = ""

# Button press tracking
var btnPressed = @[false, false]
var btnWasClicked = @[false, false]
```

```nim on:render
# ===================================================================
# Handle button clicks
# ===================================================================
if btnWasClicked[0]:  # Submit button
  btnWasClicked[0] = false
  if tbTexts[0] == "":
    message = "Please enter a name!"
  else:
    var opts = ""
    if cbChecked[0]:
      opts = opts & " +Newsletter"
    if cbChecked[1]:
      opts = opts & " +Notify"
    message = "Submitted: " & tbTexts[0] & opts

if btnWasClicked[1]:  # Clear button
  btnWasClicked[1] = false
  tbTexts[0] = ""
  tbTexts[1] = ""
  tbCursors[0] = 0
  tbCursors[1] = 0
  sliderValues[0] = 50.0
  sliderValues[1] = 75.0
  cbChecked[0] = false
  cbChecked[1] = true
  message = "Form cleared!"

# ===================================================================
# Render
# ===================================================================
clear()

let infoStyle = getStyle("info")
let warningStyle = getStyle("warning")

draw(0, 5, 2, "Comprehensive TUI System - Tab/Shift+Tab to navigate", infoStyle)
draw(0, 5, 31, "Message: " & message, warningStyle)
draw(0, 5, 32, "Last event: " & lastEvent, infoStyle)

# Render all widgets
var i = 0
while i < widgetCount:
  let x = widgetX[i]
  let y = widgetY[i]
  let w = widgetW[i]
  let h = widgetH[i]
  let focused = i == focusIndex
  let wType = widgetTypes[i]
  
  # TextBox
  if wType == 0:
    let tbIndex = i
    let tbStyle = if focused: getStyle("highlight") else: getStyle("border")
    drawBox(x, y, w, h, tbStyle)
    
    let labelStyle = getStyle("info")
    draw(0, x + 1, y, tbLabels[tbIndex], labelStyle)
    
    let textStyle = getStyle("default")
    draw(0, x + 2, y + 1, tbTexts[tbIndex], textStyle)
    
    if focused:
      let cursorStyle = getStyle("highlight")
      draw(0, x + 2 + tbCursors[tbIndex], y + 1, "_", cursorStyle)
  
  # Button
  elif wType == 1:
    let btnIndex = i - 6
    let btnStyle = if focused: getStyle("info") else: getStyle("border")
    
    if btnPressed[btnIndex]:
      let fillStyle = getStyle("button")
      fillRect(0, x, y, w, h, "#", fillStyle)
    else:
      drawBox(x, y, w, h, btnStyle)
    
    let label = btnLabels[btnIndex]
    let labelX = x + (w - len(label)) div 2
    let labelY = y + h div 2
    draw(0, labelX, labelY, label, btnStyle)
  
  # Slider
  elif wType == 2:
    let sliderIndex = i - 2
    let sliderStyle = if focused: getStyle("highlight") else: getStyle("border")
    drawBox(x, y, w, h, sliderStyle)
    
    let labelStyle = getStyle("info")
    draw(0, x + 1, y, sliderLabels[sliderIndex], labelStyle)
    
    let sliderY = y + 1
    let sliderX = x + 2
    let sliderWidth = w - 4
    
    let minVal = sliderMins[sliderIndex]
    let maxVal = sliderMaxs[sliderIndex]
    let curVal = sliderValues[sliderIndex]
    let percent = (curVal - minVal) / (maxVal - minVal)
    let handlePos = int(percent * float(sliderWidth - 1))
    
    var dx = 0
    while dx < sliderWidth:
      let ch = if dx == handlePos: "O" else: "‚îÄ"
      let chStyle = if dx == handlePos: getStyle("warning") else: getStyle("default")
      draw(0, sliderX + dx, sliderY, ch, chStyle)
      dx = dx + 1
    
    let valueText = str(int(curVal))
    draw(0, x + w - len(valueText) - 2, y + 2, valueText, getStyle("default"))
  
  # Checkbox
  elif wType == 3:
    let cbIndex = i - 4
    let cbStyle = if focused: getStyle("highlight") else: getStyle("default")
    let checkChar = if cbChecked[cbIndex]: "X" else: " "
    draw(0, x, y, "[" & checkChar & "]", cbStyle)
    draw(0, x + 4, y, cbLabels[cbIndex], getStyle("default"))
  
  i = i + 1
```

```nim on:input
var handled = false

# ===================================================================
# Text Input (for TextBox widgets)
# ===================================================================
if event.type == "text":
  if widgetTypes[focusIndex] == 0:  # TextBox
    let tbIndex = focusIndex
    tbTexts[tbIndex] = tbTexts[tbIndex] & event.text
    tbCursors[tbIndex] = tbCursors[tbIndex] + 1
    lastEvent = "text: " & event.text
    return true
  
  return false

# ===================================================================
# Key Input
# ===================================================================
elif event.type == "key":
  let keyCode = event.keyCode
  lastEvent = "key: " & str(keyCode)
  
  # Tab - cycle focus forward
  if keyCode == 9:
    if event.shift:
      # Shift+Tab - cycle backward
      focusIndex = (focusIndex - 1 + widgetCount) mod widgetCount
    else:
      # Tab - cycle forward
      focusIndex = (focusIndex + 1) mod widgetCount
    lastEvent = if event.shift: "shift-tab" else: "tab"
    return true
  
  # Backspace (for TextBox)
  if keyCode == 127 or keyCode == 8:
    if widgetTypes[focusIndex] == 0:
      let tbIndex = focusIndex
      if tbCursors[tbIndex] > 0 and len(tbTexts[tbIndex]) > 0:
        tbTexts[tbIndex] = tbTexts[tbIndex][0..<len(tbTexts[tbIndex]) - 1]
        tbCursors[tbIndex] = tbCursors[tbIndex] - 1
      return true
  
  # Space or Enter (for Button and Checkbox)
  if keyCode == 32 or keyCode == 13:
    if widgetTypes[focusIndex] == 1:  # Button
      let btnIndex = focusIndex - 6
      btnWasClicked[btnIndex] = true
      return true
    elif widgetTypes[focusIndex] == 3:  # Checkbox
      let cbIndex = focusIndex - 4
      cbChecked[cbIndex] = not cbChecked[cbIndex]
      return true
  
  # Arrow keys (for Slider)
  if keyCode >= 37 and keyCode <= 40:  # Arrow keys
    if widgetTypes[focusIndex] == 2:
      let sliderIndex = focusIndex - 2
      let range = sliderMaxs[sliderIndex] - sliderMins[sliderIndex]
      let step = range / 10.0
      
      if keyCode == 37 or keyCode == 40:  # Left or Down
        sliderValues[sliderIndex] = sliderValues[sliderIndex] - step
        if sliderValues[sliderIndex] < sliderMins[sliderIndex]:
          sliderValues[sliderIndex] = sliderMins[sliderIndex]
        return true
      elif keyCode == 39 or keyCode == 38:  # Right or Up
        sliderValues[sliderIndex] = sliderValues[sliderIndex] + step
        if sliderValues[sliderIndex] > sliderMaxs[sliderIndex]:
          sliderValues[sliderIndex] = sliderMaxs[sliderIndex]
        return true
  
  return false

# ===================================================================
# Mouse Input
# ===================================================================
elif event.type == "mouse":
  let mx = event.x
  let my = event.y
  let action = event.action
  
  lastEvent = "mouse " & action & " (" & str(mx) & "," & str(my) & ")"
  
  # Check which widget was clicked
  var clickedWidget = -1
  var i = 0
  while i < widgetCount:
    let x = widgetX[i]
    let y = widgetY[i]
    let w = widgetW[i]
    let h = widgetH[i]
    
    if mx >= x and mx < x + w and my >= y and my < y + h:
      clickedWidget = i
      break
    
    i = i + 1
  
  # Handle mouse press
  if action == "press":
    if clickedWidget >= 0:
      # Update focus
      focusIndex = clickedWidget
      
      # Button press
      if widgetTypes[clickedWidget] == 1:
        let btnIndex = clickedWidget - 6
        btnPressed[btnIndex] = true
        return true
      
      # Slider drag start
      elif widgetTypes[clickedWidget] == 2:
        let sliderIndex = clickedWidget - 2
        sliderDragging[sliderIndex] = true
        
        # Update slider value based on mouse position
        let sliderX = widgetX[clickedWidget] + 2
        let sliderWidth = widgetW[clickedWidget] - 4
        let relX = mx - sliderX
        var percent = float(relX) / float(sliderWidth - 1)
        if percent < 0.0:
          percent = 0.0
        if percent > 1.0:
          percent = 1.0
        
        let minVal = sliderMins[sliderIndex]
        let maxVal = sliderMaxs[sliderIndex]
        sliderValues[sliderIndex] = minVal + percent * (maxVal - minVal)
        return true
      
      # Checkbox toggle
      elif widgetTypes[clickedWidget] == 3:
        let cbIndex = clickedWidget - 4
        cbChecked[cbIndex] = not cbChecked[cbIndex]
        return true
  
  # Handle mouse drag
  elif action == "drag":
    # Update slider during drag
    var i = 0
    while i < 2:
      if sliderDragging[i]:
        let widgetIndex = i + 2
        let sliderX = widgetX[widgetIndex] + 2
        let sliderWidth = widgetW[widgetIndex] - 4
        let relX = mx - sliderX
        var percent = float(relX) / float(sliderWidth - 1)
        if percent < 0.0:
          percent = 0.0
        if percent > 1.0:
          percent = 1.0
        
        let minVal = sliderMins[i]
        let maxVal = sliderMaxs[i]
        sliderValues[i] = minVal + percent * (maxVal - minVal)
        return true
      i = i + 1
  
  # Handle mouse release
  elif action == "release":
    # Check button clicks
    var i = 0
    while i < 2:
      if btnPressed[i]:
        btnPressed[i] = false
        let widgetIndex = i + 6
        let x = widgetX[widgetIndex]
        let y = widgetY[widgetIndex]
        let w = widgetW[widgetIndex]
        let h = widgetH[widgetIndex]
        
        if mx >= x and mx < x + w and my >= y and my < y + h:
          btnWasClicked[i] = true
        return true
      i = i + 1
    
    # Stop slider dragging
    sliderDragging[0] = false
    sliderDragging[1] = false
    return true
  
  return false

return false
```

Complete TUI system with focus management, keyboard navigation, and mouse interaction!
---
title: "TUI Demo v2 - Using Built-in Helpers"
minWidth: 60
minHeight: 35
theme: "neotopia"
styles.highlight.fg: "#FFFF00"
styles.highlight.bold: "true"
---

# TUI System Using Built-in Helpers

This demo recreates the comprehensive TUI system using the new built-in helper functions. Much simpler code with the same functionality!

```nim on:init
# ===================================================================
# Widget State Arrays
# ===================================================================
# Widget types: 0=TextBox, 1=Button, 2=Slider, 3=Checkbox
var widgetTypes = @[0, 0, 2, 2, 3, 3, 1, 1]
var widgetX = @[10, 10, 10, 10, 12, 12, 15, 32]
var widgetY = @[5, 9, 13, 17, 21, 22, 26, 26]
var widgetW = @[30, 30, 30, 30, 30, 30, 15, 15]
var widgetH = @[3, 3, 3, 3, 1, 1, 3, 3]

# TextBox data (indices 0, 1)
var tbLabels = @["Name:", "Email:"]
var tbTexts = @["", ""]
var tbCursors = @[0, 0]

# Button data (indices 6, 7)
var btnLabels = @["Submit", "Clear"]
var btnPressed = @[false, false]
var btnWasClicked = @[false, false]

# Slider data (indices 2, 3)
var sliderLabels = @["Volume:", "Brightness:"]
var sliderMins = @[0.0, 0.0]
var sliderMaxs = @[100.0, 100.0]
var sliderValues = @[50.0, 75.0]
var sliderDragging = @[false, false]

# Checkbox data (indices 4, 5)
var cbLabels = @["Opt-in to newsletter", "Enable notifications"]
var cbChecked = @[false, true]

# Focus management
var focusIndex = 0
var widgetCount = 8

# Global state
var message = "Tab/Shift+Tab to navigate | Space/Enter to activate"
var lastEvent = ""
```

```nim on:render
# ===================================================================
# Handle button clicks
# ===================================================================
if btnWasClicked[0]:  # Submit button
  btnWasClicked[0] = false
  if tbTexts[0] == "":
    message = "Please enter a name!"
  else:
    var opts = ""
    if cbChecked[0]:
      opts = opts & " +Newsletter"
    if cbChecked[1]:
      opts = opts & " +Notify"
    message = "Submitted: " & tbTexts[0] & opts

if btnWasClicked[1]:  # Clear button
  btnWasClicked[1] = false
  tbTexts[0] = ""
  tbTexts[1] = ""
  tbCursors[0] = 0
  tbCursors[1] = 0
  sliderValues[0] = 50.0
  sliderValues[1] = 75.0
  cbChecked[0] = false
  cbChecked[1] = true
  message = "Form cleared!"

# ===================================================================
# Render
# ===================================================================
clear()

# Header
drawLabel(0, 5, 2, "TUI v2 - Using Built-in Helpers", getStyle("info"))
drawLabel(0, 5, 31, "Message: " & message, getStyle("warning"))
drawLabel(0, 5, 32, "Last event: " & lastEvent, getStyle("info"))

# Render all widgets
var i = 0
while i < widgetCount:
  let x = widgetX[i]
  let y = widgetY[i]
  let w = widgetW[i]
  let h = widgetH[i]
  let focused = i == focusIndex
  let wType = widgetTypes[i]
  
  # TextBox
  if wType == 0:
    let tbIndex = i
    # Draw label above the box
    drawLabel(0, x + 1, y, tbLabels[tbIndex], getStyle("info"))
    # Draw the textbox itself
    drawTextBox(0, x, y, w, h, tbTexts[tbIndex], tbCursors[tbIndex], focused, "single")
  
  # Button
  elif wType == 1:
    let btnIndex = i - 6
    drawButton(0, x, y, w, h, btnLabels[btnIndex], focused, btnPressed[btnIndex], "single")
  
  # Slider
  elif wType == 2:
    let sliderIndex = i - 2
    # Draw box around slider
    let sliderStyle = if focused: getStyle("highlight") else: getStyle("border")
    drawBoxSimple(0, x, y, w, h, sliderStyle)
    
    # Draw label
    drawLabel(0, x + 1, y, sliderLabels[sliderIndex], getStyle("info"))
    
    # Draw slider inside box
    let sliderY = y + 1
    let sliderX = x + 2
    let sliderWidth = w - 4
    drawSlider(0, sliderX, sliderY, sliderWidth, sliderValues[sliderIndex], sliderMins[sliderIndex], sliderMaxs[sliderIndex], focused)
  
  # Checkbox
  elif wType == 3:
    let cbIndex = i - 4
    drawCheckBox(0, x, y, cbLabels[cbIndex], cbChecked[cbIndex], focused)
  
  i = i + 1
```

```nim on:input
var handled = false

# ===================================================================
# Text Input (for TextBox widgets)
# ===================================================================
if event.type == "text":
  if widgetTypes[focusIndex] == 0:  # TextBox
    let tbIndex = focusIndex
    tbTexts[tbIndex] = tbTexts[tbIndex] & event.text
    tbCursors[tbIndex] = tbCursors[tbIndex] + 1
    lastEvent = "text: " & event.text
    return true
  
  return false

# ===================================================================
# Key Input
# ===================================================================
elif event.type == "key":
  let keyCode = event.keyCode
  lastEvent = "key: " & str(keyCode)
  
  # Tab - cycle focus forward
  if keyCode == 9:
    if event.shift:
      # Shift+Tab - cycle backward
      focusIndex = (focusIndex - 1 + widgetCount) mod widgetCount
    else:
      # Tab - cycle forward
      focusIndex = (focusIndex + 1) mod widgetCount
    lastEvent = if event.shift: "shift-tab" else: "tab"
    return true
  
  # Backspace (for TextBox)
  if keyCode == 127 or keyCode == 8:
    if widgetTypes[focusIndex] == 0:
      let tbIndex = focusIndex
      if tbCursors[tbIndex] > 0 and len(tbTexts[tbIndex]) > 0:
        tbTexts[tbIndex] = tbTexts[tbIndex][0..<len(tbTexts[tbIndex]) - 1]
        tbCursors[tbIndex] = tbCursors[tbIndex] - 1
      return true
  
  # Space or Enter (for Button and Checkbox)
  if keyCode == 32 or keyCode == 13:
    if widgetTypes[focusIndex] == 1:  # Button
      let btnIndex = focusIndex - 6
      btnWasClicked[btnIndex] = true
      return true
    elif widgetTypes[focusIndex] == 3:  # Checkbox
      let cbIndex = focusIndex - 4
      cbChecked[cbIndex] = not cbChecked[cbIndex]
      return true
  
  # Arrow keys (for Slider)
  if keyCode >= 37 and keyCode <= 40:  # Arrow keys
    if widgetTypes[focusIndex] == 2:
      let sliderIndex = focusIndex - 2
      let range = sliderMaxs[sliderIndex] - sliderMins[sliderIndex]
      let step = range / 10.0
      
      if keyCode == 37 or keyCode == 40:  # Left or Down
        sliderValues[sliderIndex] = sliderValues[sliderIndex] - step
        if sliderValues[sliderIndex] < sliderMins[sliderIndex]:
          sliderValues[sliderIndex] = sliderMins[sliderIndex]
        return true
      elif keyCode == 39 or keyCode == 38:  # Right or Up
        sliderValues[sliderIndex] = sliderValues[sliderIndex] + step
        if sliderValues[sliderIndex] > sliderMaxs[sliderIndex]:
          sliderValues[sliderIndex] = sliderMaxs[sliderIndex]
        return true
  
  return false

# ===================================================================
# Mouse Input
# ===================================================================
elif event.type == "mouse":
  let mx = event.x
  let my = event.y
  let action = event.action
  
  lastEvent = "mouse " & action & " (" & str(mx) & "," & str(my) & ")"
  
  # Check which widget was clicked
  var clickedWidget = -1
  var i = 0
  while i < widgetCount:
    let x = widgetX[i]
    let y = widgetY[i]
    let w = widgetW[i]
    let h = widgetH[i]
    
    if mx >= x and mx < x + w and my >= y and my < y + h:
      clickedWidget = i
      break
    
    i = i + 1
  
  # Handle mouse press
  if action == "press":
    if clickedWidget >= 0:
      # Update focus
      focusIndex = clickedWidget
      
      # Button press
      if widgetTypes[clickedWidget] == 1:
        let btnIndex = clickedWidget - 6
        btnPressed[btnIndex] = true
        return true
      
      # Slider drag start
      elif widgetTypes[clickedWidget] == 2:
        let sliderIndex = clickedWidget - 2
        sliderDragging[sliderIndex] = true
        
        # Update slider value based on mouse position
        let sliderX = widgetX[clickedWidget] + 2
        let sliderWidth = widgetW[clickedWidget] - 4
        let relX = mx - sliderX
        var percent = float(relX) / float(sliderWidth - 1)
        if percent < 0.0:
          percent = 0.0
        if percent > 1.0:
          percent = 1.0
        
        let minVal = sliderMins[sliderIndex]
        let maxVal = sliderMaxs[sliderIndex]
        sliderValues[sliderIndex] = minVal + percent * (maxVal - minVal)
        return true
      
      # Checkbox toggle
      elif widgetTypes[clickedWidget] == 3:
        let cbIndex = clickedWidget - 4
        cbChecked[cbIndex] = not cbChecked[cbIndex]
        return true
  
  # Handle mouse drag
  elif action == "drag":
    # Update slider during drag
    var i = 0
    while i < 2:
      if sliderDragging[i]:
        let widgetIndex = i + 2
        let sliderX = widgetX[widgetIndex] + 2
        let sliderWidth = widgetW[widgetIndex] - 4
        let relX = mx - sliderX
        var percent = float(relX) / float(sliderWidth - 1)
        if percent < 0.0:
          percent = 0.0
        if percent > 1.0:
          percent = 1.0
        
        let minVal = sliderMins[i]
        let maxVal = sliderMaxs[i]
        sliderValues[i] = minVal + percent * (maxVal - minVal)
        return true
      i = i + 1
  
  # Handle mouse release
  elif action == "release":
    # Check button clicks
    var i = 0
    while i < 2:
      if btnPressed[i]:
        btnPressed[i] = false
        let widgetIndex = i + 6
        let x = widgetX[widgetIndex]
        let y = widgetY[widgetIndex]
        let w = widgetW[widgetIndex]
        let h = widgetH[widgetIndex]
        
        if mx >= x and mx < x + w and my >= y and my < y + h:
          btnWasClicked[i] = true
        return true
      i = i + 1
    
    # Stop slider dragging
    sliderDragging[0] = false
    sliderDragging[1] = false
    return true
  
  return false

return false
```

## Code Comparison

**Before (tui.md):** ~120 lines just for the `drawBox` helper function!

**After (tui2.md):** Uses built-in `drawBoxSimple()`, `drawButton()`, `drawTextBox()`, `drawSlider()`, and `drawCheckBox()` - **40% less code** with the same functionality!

## Benefits

1. **Cleaner code** - No need to manually draw box borders
2. **Consistent styling** - All widgets use theme styles automatically
3. **Less error-prone** - Pre-tested widget functions
4. **Easier to maintain** - Updates to widgets happen in one place
---
title: "Advanced TUI Widgets Demo"
minWidth: 80
minHeight: 40
theme: "neotopia"
---

# Advanced TUI Widgets Showcase

This demo showcases the new advanced TUI widgets: radio buttons, dropdowns, lists, tabs, and more!

```nim on:init
# ===================================================================
# State Management
# ===================================================================
# Radio button group
var radioOptions = @["Small", "Medium", "Large"]
var radioSelected = 1
var radioFocusIndex = -1

# Dropdown
var dropdownOptions = @["Option 1", "Option 2", "Option 3", "Option 4"]
var dropdownSelected = 0
var dropdownOpen = false
var dropdownFocused = false

# List widget
var listItems = @["Item A", "Item B", "Item C", "Item D", "Item E", "Item F", "Item G", "Item H", "Item I", "Item J"]
var listSelected = 0
var listScrollOffset = 0
var listFocused = false

# Tab container
var tabs = @["Settings", "Profile", "Help"]
var activeTab = 0

# Text area
var textLines = @["Line 1: Hello!", "Line 2: This is a", "Line 3: multi-line", "Line 4: text area!"]
var textCursorLine = 0
var textCursorCol = 0
var textScrollY = 0
var textAreaFocused = false

# Form with enhanced text box
var formName = ""
var formNameCursor = 0
var formNameScroll = 0
var formEmail = ""
var formEmailCursor = 0
var formEmailScroll = 0
var formFocusIndex = 0

# Focus areas: 0=radio, 1=dropdown, 2=list, 3=form, 4=textarea
var focusArea = 0
var message = "Tab to cycle focus | Arrow keys to navigate | Space/Enter to select"

# Helper function for string slicing (since substr is not available)
proc sliceStr(s: string, startIdx: int, endIdx: int): string =
  if startIdx < 0 or startIdx >= len(s):
    return ""
  let actualEnd = min(endIdx + 1, len(s))
  if startIdx >= actualEnd:
    return ""
  var result = ""
  var i = startIdx
  while i < actualEnd:
    result = result & chr(ord(s[i]))
    i = i + 1
  return result
```

```nim on:render
# ===================================================================
# Render
# ===================================================================
clear()

let w = termWidth
let h = termHeight

# Title
drawLabel(0, 5, 2, "Advanced TUI Widgets - Tab to cycle focus areas", getStyle("info"))
drawLabel(0, 5, h - 2, message, getStyle("warning"))

# Left column - Radio buttons
drawPanel(0, 5, 4, 25, 8, "Size Selection", "single")
var dy = 0
while dy < len(radioOptions):
  let isSelected = dy == radioSelected
  let isFocused = focusArea == 0 and dy == radioFocusIndex
  drawRadioButton(0, 7, 6 + dy, radioOptions[dy], isSelected, isFocused)
  dy = dy + 1

# Dropdown
drawPanel(0, 5, 13, 25, 9, "Dropdown Menu", "single")
drawDropdown(0, 7, 15, 21, dropdownOptions, dropdownSelected, dropdownOpen, focusArea == 1)

# Right column - List
drawPanel(0, 35, 4, 30, 12, "Scrollable List", "single")
drawList(0, 37, 6, 26, 9, listItems, listSelected, listScrollOffset, focusArea == 2)

# Tab container
drawTabBar(0, 35, 17, 40, tabs, activeTab)
drawTabContent(0, 35, 19, 40, 8, "single")

# Tab content varies by active tab
if activeTab == 0:
  drawLabel(0, 37, 21, "Settings Panel", getStyle("info"))
  drawLabel(0, 37, 22, "Configure your preferences here", getStyle("default"))
elif activeTab == 1:
  drawLabel(0, 37, 21, "Profile Panel", getStyle("info"))
  drawLabel(0, 37, 22, "View and edit your profile", getStyle("default"))
else:
  drawLabel(0, 37, 21, "Help Panel", getStyle("info"))
  drawLabel(0, 37, 22, "Get assistance and documentation", getStyle("default"))

# Bottom - Form with enhanced text boxes
drawPanel(0, 5, 23, 65, 12, "Contact Form", "single")

# Use form layout helper
let formLayouts = layoutForm(7, 25, 10, 30, 3, 1, 2)
let nameLayout = formLayouts[0]
let emailLayout = formLayouts[1]

# Name field
drawLabel(0, nameLayout.labelX, nameLayout.labelY, "Name:", getStyle("info"))
formNameScroll = drawTextBoxWithScroll(0, nameLayout.fieldX, nameLayout.fieldY, 30, 3, 
                                       formName, formNameCursor, formNameScroll, 
                                       focusArea == 3 and formFocusIndex == 0, "single")

# Email field
drawLabel(0, emailLayout.labelX, emailLayout.labelY, "Email:", getStyle("info"))
formEmailScroll = drawTextBoxWithScroll(0, emailLayout.fieldX, emailLayout.fieldY, 30, 3,
                                        formEmail, formEmailCursor, formEmailScroll,
                                        focusArea == 3 and formFocusIndex == 1, "single")

# Text area in bottom right
drawPanel(0, 5, 36, 40, 8, "Multi-line Text", "single")
drawTextArea(0, 7, 38, 36, 5, textLines, textCursorLine, textCursorCol, textScrollY, focusArea == 4)
```

```nim on:input
# ===================================================================
# Key Input Handling
# ===================================================================
if event.type == "key":
  let keyCode = event.keyCode
  let isShift = contains(event.mods, "shift")
  
  # Tab - cycle focus areas (support Shift+Tab for reverse)
  if keyCode == 9:
    if isShift:
      focusArea = (focusArea - 1 + 5) mod 5
    else:
      focusArea = (focusArea + 1) mod 5
    
    # Reset sub-focus when changing areas
    radioFocusIndex = if focusArea == 0: 0 else: -1
    message = "Focus area: " & str(focusArea) & (if isShift: " (Shift+Tab)" else: " (Tab)")
    return true
  
  # Handle input based on focus area
  if focusArea == 0:  # Radio buttons
    if keyCode == 10000 or keyCode == 10001:  # Up/Down arrows
      if keyCode == 10000:  # Up
        radioFocusIndex = (radioFocusIndex - 1 + len(radioOptions)) mod len(radioOptions)
      elif keyCode == 10001:  # Down
        radioFocusIndex = (radioFocusIndex + 1) mod len(radioOptions)
      return true
    
    if keyCode == 32 or keyCode == 13:  # Space or Enter
      if radioFocusIndex >= 0:
        radioSelected = radioFocusIndex
        message = "Selected: " & radioOptions[radioSelected]
      return true
  
  elif focusArea == 1:  # Dropdown
    if keyCode == 32 or keyCode == 13:  # Space or Enter
      dropdownOpen = not dropdownOpen
      message = if dropdownOpen: "Dropdown opened" else: "Dropdown closed"
      return true
    
    if dropdownOpen and (keyCode == 10000 or keyCode == 10001):  # Up/Down
      if keyCode == 10000:  # Up
        dropdownSelected = (dropdownSelected - 1 + len(dropdownOptions)) mod len(dropdownOptions)
      elif keyCode == 10001:  # Down
        dropdownSelected = (dropdownSelected + 1) mod len(dropdownOptions)
      message = "Selected: " & dropdownOptions[dropdownSelected]
      return true
  
  elif focusArea == 2:  # List
    if keyCode == 10000 or keyCode == 10001:  # Up/Down arrows
      if keyCode == 10000:  # Up
        if listSelected > 0:
          listSelected = listSelected - 1
          # Auto-scroll when selection moves out of view
          if listSelected < listScrollOffset:
            listScrollOffset = listSelected
          message = "Selected: " & listItems[listSelected]
      elif keyCode == 10001:  # Down
        if listSelected < len(listItems) - 1:
          listSelected = listSelected + 1
          # Auto-scroll when selection moves out of view
          if listSelected >= listScrollOffset + 9:
            listScrollOffset = listSelected - 8
          message = "Selected: " & listItems[listSelected]
      return true
    
    # Page Up/Down for faster scrolling
    if keyCode == 33:  # Page Up
      listSelected = max(0, listSelected - 5)
      listScrollOffset = max(0, listScrollOffset - 5)
      message = "Selected: " & listItems[listSelected]
      return true
    elif keyCode == 34:  # Page Down
      listSelected = min(len(listItems) - 1, listSelected + 5)
      if listSelected >= listScrollOffset + 9:
        listScrollOffset = min(len(listItems) - 9, listScrollOffset + 5)
      message = "Selected: " & listItems[listSelected]
      return true
  
  elif focusArea == 3:  # Form
    # Arrow keys to switch between fields
    if keyCode == 10000 or keyCode == 10001:  # Up/Down
      if keyCode == 10000:  # Up
        formFocusIndex = (formFocusIndex - 1 + 2) mod 2
      elif keyCode == 10001:  # Down
        formFocusIndex = (formFocusIndex + 1) mod 2
      return true
    
    # Backspace
    if keyCode == 127 or keyCode == 8:
      if formFocusIndex == 0:
        let result = handleBackspace(formNameCursor, formName)
        formNameCursor = result[0]
        formName = result[1]
      else:
        let result = handleBackspace(formEmailCursor, formEmail)
        formEmailCursor = result[0]
        formEmail = result[1]
      return true
  
  elif focusArea == 4:  # Text area
    # Arrow key navigation
    if keyCode == 10000:  # Up
      if textCursorLine > 0:
        textCursorLine = textCursorLine - 1
        # Clamp cursor column to new line length
        if textCursorCol > len(textLines[textCursorLine]):
          textCursorCol = len(textLines[textCursorLine])
      return true
    elif keyCode == 10001:  # Down
      if textCursorLine < len(textLines) - 1:
        textCursorLine = textCursorLine + 1
        # Clamp cursor column to new line length
        if textCursorCol > len(textLines[textCursorLine]):
          textCursorCol = len(textLines[textCursorLine])
      return true
    elif keyCode == 10002:  # Left
      if textCursorCol > 0:
        textCursorCol = textCursorCol - 1
      elif textCursorLine > 0:
        textCursorLine = textCursorLine - 1
        textCursorCol = len(textLines[textCursorLine])
      return true
    elif keyCode == 10003:  # Right
      if textCursorCol < len(textLines[textCursorLine]):
        textCursorCol = textCursorCol + 1
      elif textCursorLine < len(textLines) - 1:
        textCursorLine = textCursorLine + 1
        textCursorCol = 0
      return true
    
    # Backspace
    if keyCode == 127 or keyCode == 8:
      if textCursorCol > 0:
        # Delete character before cursor
        let line = textLines[textCursorLine]
        textLines[textCursorLine] = sliceStr(line, 0, textCursorCol - 2) & sliceStr(line, textCursorCol, len(line) - 1)
        textCursorCol = textCursorCol - 1
      elif textCursorLine > 0:
        # Merge with previous line
        let currentLine = textLines[textCursorLine]
        textCursorCol = len(textLines[textCursorLine - 1])
        textLines[textCursorLine - 1] = textLines[textCursorLine - 1] & currentLine
        # Remove current line
        var newLines = @[""]
        var i = 0
        while i < len(textLines):
          if i != textCursorLine:
            push(newLines, textLines[i])
          i = i + 1
        textLines = newLines
        textCursorLine = textCursorLine - 1
      return true
    
    # Enter - insert new line
    if keyCode == 13:
      let currentLine = textLines[textCursorLine]
      let beforeCursor = sliceStr(currentLine, 0, textCursorCol - 1)
      let afterCursor = sliceStr(currentLine, textCursorCol, len(currentLine) - 1)
      textLines[textCursorLine] = beforeCursor
      # Insert new line after current
      var newLines = @[""]
      var i = 0
      while i <= len(textLines):
        if i <= textCursorLine:
          push(newLines, textLines[i])
        elif i == textCursorLine + 1:
          push(newLines, afterCursor)
        elif i < len(textLines):
          push(newLines, textLines[i])
        i = i + 1
      textLines = newLines
      textCursorLine = textCursorLine + 1
      textCursorCol = 0
      return true
  
  return false

# ===================================================================
# Text Input Handling
# ===================================================================
elif event.type == "text":
  if focusArea == 3:  # Form
    if formFocusIndex == 0:
      let result = handleTextInput(event.text, formNameCursor, formName)
      formNameCursor = result[0]
      formName = result[1]
    else:
      let result = handleTextInput(event.text, formEmailCursor, formEmail)
      formEmailCursor = result[0]
      formEmail = result[1]
    return true
  
  elif focusArea == 4:  # Text area
    # Insert text at cursor position
    let currentLine = textLines[textCursorLine]
    let beforeCursor = sliceStr(currentLine, 0, textCursorCol - 1)
    let afterCursor = sliceStr(currentLine, textCursorCol, len(currentLine) - 1)
    textLines[textCursorLine] = beforeCursor & event.text & afterCursor
    textCursorCol = textCursorCol + len(event.text)
    return true
  
  return false

# ===================================================================
# Mouse Input Handling
# ===================================================================
elif event.type == "mouse":
  let mx = event.x
  let my = event.y
  let action = event.action
  
  if action == "press":
    # Check which area was clicked
    # Radio buttons
    if mx >= 5 and mx < 30 and my >= 4 and my < 12:
      focusArea = 0
      let radioY = my - 6
      if radioY >= 0 and radioY < len(radioOptions):
        radioFocusIndex = radioY
        radioSelected = radioY
        message = "Selected: " & radioOptions[radioSelected]
      return true
    
    # Dropdown
    if mx >= 5 and mx < 30 and my >= 13 and my < 22:
      focusArea = 1
      dropdownFocused = true
      if my == 15:  # Clicked on dropdown header
        dropdownOpen = not dropdownOpen
        message = if dropdownOpen: "Dropdown opened" else: "Dropdown closed"
      elif dropdownOpen and my >= 16 and my < 16 + len(dropdownOptions):
        let optionIndex = my - 16
        if optionIndex >= 0 and optionIndex < len(dropdownOptions):
          dropdownSelected = optionIndex
          dropdownOpen = false
          message = "Selected: " & dropdownOptions[dropdownSelected]
      return true
    
    # List (clickable items)
    if mx >= 35 and mx < 65 and my >= 4 and my < 16:
      focusArea = 2
      let itemY = my - 6
      if itemY >= 0 and itemY < 9:
        let itemIndex = listScrollOffset + itemY
        if itemIndex < len(listItems):
          listSelected = itemIndex
          message = "Selected: " & listItems[listSelected]
      return true
  
  # Handle mouse wheel for list scrolling
  if action == "wheel":
    if mx >= 35 and mx < 65 and my >= 4 and my < 16:
      focusArea = 2
      # event.wheelDelta: positive = scroll up, negative = scroll down
      if event.wheelDelta > 0:
        # Scroll up
        if listScrollOffset > 0:
          listScrollOffset = listScrollOffset - 1
          if listSelected > listScrollOffset + 8:
            listSelected = listScrollOffset + 8
          message = "Scrolled up: " & listItems[listSelected]
      else:
        # Scroll down
        if listScrollOffset < len(listItems) - 9:
          listScrollOffset = listScrollOffset + 1
          if listSelected < listScrollOffset:
            listSelected = listScrollOffset
          message = "Scrolled down: " & listItems[listSelected]
      return true
    
  # Tabs
  if action == "press":
    if mx >= 35 and mx < 75 and my >= 17 and my < 19:
      # Simple tab hit detection
      let relX = mx - 36
      if relX < 10:
        activeTab = 0
      elif relX < 20:
        activeTab = 1
      else:
        activeTab = 2
      message = "Active tab: " & tabs[activeTab]
      return true
    
    # Form clicks
    if mx >= 5 and mx < 70 and my >= 23 and my < 35:
      focusArea = 3
      if my >= 25 and my < 28:
        formFocusIndex = 0
      elif my >= 29 and my < 32:
        formFocusIndex = 1
      message = "Form field focused"
      return true
    
    # Text area clicks
    if mx >= 5 and mx < 45 and my >= 36 and my < 44:
      focusArea = 4
      # Could calculate cursor position from click coordinates here
      message = "Text area focused"
      return true
  
  return false

return false
```

## Features Demonstrated

### New Widgets:
- **Radio Buttons** - Single selection from multiple options
- **Dropdown Menu** - Expandable selection widget
- **Scrollable List** - Long list with keyboard navigation
- **Tab Container** - Multi-panel interface
- **Enhanced Text Box** - Horizontal scrolling for long text
- **Text Area** - Multi-line text editing
- **Form Layout** - Automatic field positioning

### New Helper Functions:
- `drawRadioButton()` / `drawRadioGroup()` - Radio button widgets
- `drawDropdown()` - Dropdown/select widget
- `drawList()` - Scrollable list with selection
- `drawTabBar()` / `drawTabContent()` - Tabbed interface
- `drawTextArea()` - Multi-line text editor
- `drawTextBoxWithScroll()` - Auto-scrolling text input
- `layoutForm()` - Automatic form layout
- `handleTextInput()` / `handleBackspace()` - Input helpers

All widgets are theme-aware and integrate seamlessly with the existing TUI system!
---
title: "Unicode & Emoji Test"
theme: "default"
---

```nim on:init
print "Init: Testing unicode and emoji rendering"
```

```nim on:render
# Clear and draw unicode characters
clear()

# ASCII baseline
draw(0, 2, 2, "ASCII: Hello World!", defaultStyle())

# Unicode characters
draw(0, 2, 4, "Unicode: H√©llo W√∂rld! Êó•Êú¨Ë™û ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", defaultStyle())

# Box drawing
draw(0, 2, 6, "Box: ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ BOX ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò", defaultStyle())

# Emoji (if supported)
draw(0, 2, 8, "Emoji: üòÄ üé® üöÄ ‚≠ê üíª üåà", defaultStyle())

# Math symbols
draw(0, 2, 10, "Math: œÄ ‚âà 3.14159 ‚àë ‚à´ ‚àö ‚àû", defaultStyle())

# Arrows and symbols
draw(0, 2, 12, "Arrows: ‚Üí ‚Üê ‚Üë ‚Üì ‚áí ‚áê ‚Üî", defaultStyle())
```
---
title: "Welcome to t|Stauri"
author: "Maddest Labs"
theme: "default"
---

# Welcome to t|Stauri Desktop

A terminal-based storytelling environment powered by **t|Storie**.

```nim on:init
# Get theme background and accent colors
var bgStyle = getStyle("default")
var bgR = int(bgStyle.bg.r)
var bgG = int(bgStyle.bg.g)
var bgB = int(bgStyle.bg.b)

# Get accent1 color for rain particles
var accentStyle = getStyle("accent1")

# Initialize rain particle system
particleInit("rain", 150)
particleSetBackgroundColor("rain", bgR, bgG, bgB)
particleConfigureRain("rain", 30.0)
particleSetEmitterPos("rain", 0.0, 0.0)
particleSetEmitterSize("rain", float(termWidth), 1.0)
particleSetCollision("rain", false, 0)

# Set rain color to theme accent1
particleSetForegroundFromStyle("rain", accentStyle)

# Animation state variables
var pulsePhase = 0.0
var instructionBlink = 0.0
```

```nim on:update
# Update particle emitter size based on terminal width
particleSetEmitterSize("rain", float(termWidth), 1.0)

# Frame-independent animation timing
pulsePhase = pulsePhase + (deltaTime * 2.0)
instructionBlink = instructionBlink + (deltaTime * 4.0)

# Update rain particle system
particleUpdate("rain", deltaTime)
```

```nim on:render
# Clear screen
clear()

# Render rain particles behind UI
particleRender("rain", 0)

# Calculate pulsing values for animations
var pulse = (sin(pulsePhase) + 1.0) / 2.0
var blinkVal = (sin(instructionBlink) + 1.0) / 2.0

# Header styles
var titleStyle = getStyle("heading")
var infoStyle = getStyle("info")
var successStyle = getStyle("success")

# Title box at center-top
var centerX = termWidth / 2
var titleY = 3

draw(0, centerX - 18, titleY, "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
draw(0, centerX - 18, titleY + 1, "‚ïë                                    ‚ïë")
draw(0, centerX - 18, titleY + 2, "‚ïë      t|Stauri Desktop v0.1         ‚ïë", titleStyle)
draw(0, centerX - 18, titleY + 3, "‚ïë         Terminal Engine            ‚ïë", infoStyle)
draw(0, centerX - 18, titleY + 4, "‚ïë                                    ‚ïë")
draw(0, centerX - 18, titleY + 5, "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")

# Animated separator
var sepY = titleY + 7
var sepChar = "‚îÄ"
if pulse > 0.5:
  sepChar = "‚ïê"

var i = 0
var sepStr = ""
while i < 36:
  sepStr = sepStr & sepChar
  i = i + 1
draw(0, centerX - 18, sepY, sepStr, successStyle)

# Main instructions - drop files here
var instrY = sepY + 2
draw(0, centerX - 16, instrY, "DROP A t|Storie FILE TO BEGIN", successStyle)

var detailY = instrY + 2
draw(0, centerX - 18, detailY, "  üìÑ  .md files (t|Storie markdown)")
draw(0, centerX - 18, detailY + 1, "  üñºÔ∏è   .png files (embedded workflows)")
draw(0, centerX - 18, detailY + 2, "  üì¶  .t|Storie files (packaged stories)")

# Pulsing hint
var hintY = detailY + 4
var hintIntensity = int(blinkVal * 100)
if hintIntensity > 40:
  draw(0, centerX - 15, hintY, ">>> Drag & drop to get started <<<", successStyle)
else:
  draw(0, centerX - 15, hintY, "    Drag & drop to get started    ")

# Controls hint
var ctrlY = termHeight - 4
draw(0, 2, ctrlY, "Controls:", infoStyle)
draw(0, 4, ctrlY + 1, "[Q] or [ESC] Quit")

# Footer
var footerY = termHeight - 2
draw(0, 2, footerY, "t|Stauri Desktop | Powered by t|Storie Engine", infoStyle)
draw(0, termWidth - 25, footerY, "github.com/maddestlabs", infoStyle)
```

```nim on:input
# Handle keyboard input
if event.type == "text":
  var key = event.text
  
  if key == "q":
    return false

# Handle key events for ESC
if event.type == "key":
  if event.keyCode == KEY_ESCAPE:
    return false
  if event.keyCode == KEY_Q:
    return false

return true
```
---
title: "Minimal Test"
theme: "default"
---

```nim on:init
print "Init: Starting minimal test"
```

```nim on:render
# Clear and draw a simple message
clear()
draw(0, 5, 5, "Hello from exported tStorie!", defaultStyle())
draw(0, 5, 7, "Press Ctrl-C to exit", defaultStyle())
```
# Particles: Wandering Bugs
This is a preset for creating wandering bug particles that move randomly around the screen.

## Parameters
- `{name}` - Name of the particle system (default: "bugs")
- `{count}` - Number of particles (default: 100)
- `{speed}` - Movement speed multiplier (default: 3.0)
- `{changeInterval}` - Time between direction changes in seconds (default: 1.0)
- `{chars}` - Characters to use for particles (default: "üêõüêúüêù")
- `{size}` - Particle size (default: 10.0)

```nim on:init
# Initialize wandering bug particle system
var {name}_x = float(termWidth / 2)
var {name}_y = float(termHeight / 2)
var {name}_dir_x = rand(-1.0..1.0)
var {name}_dir_y = rand(-1.0..1.0)
var {name}_timer = 0.0

particleInit("{name}", {count})
particleConfigureSparkles("{name}", {size})
particleSetChars("{name}", "{chars}")
particleSetEmitterPos("{name}", {name}_x, {name}_y)
```

```nim on:update
# Update bug movement - wander randomly with periodic direction changes
{name}_timer += deltaTime

if {name}_timer > {changeInterval}:
  {name}_dir_x = rand(-1.0..1.0)
  {name}_dir_y = rand(-1.0..1.0)
  {name}_timer = 0.0

{name}_x += {name}_dir_x * {speed} * deltaTime
{name}_y += {name}_dir_y * {speed} * deltaTime

# Wrap around screen edges
if {name}_x < 0: {name}_x = float(termWidth)
if {name}_x > float(termWidth): {name}_x = 0
if {name}_y < 0: {name}_y = float(termHeight)
if {name}_y > float(termHeight): {name}_y = 0

particleSetEmitterPos("{name}", {name}_x, {name}_y)
particleUpdate("{name}", deltaTime)
```

```nim on:render
# Render the bug particles
particleRender("{name}", "default")
```
# Particles: Click Explosion
Creates an explosion of particles when you click the mouse.

## Parameters
- `{name}` - Name of the particle system
- `{count}` - Total particle capacity (default: 200)
- `{burst}` - Number of particles per click (default: 50)
- `{layer}` - Render layer (default: "default")
- `{chars}` - Particle characters (default: "*+¬∑")
- `{minLife}` - Minimum particle lifetime (default: 0.3)
- `{maxLife}` - Maximum particle lifetime (default: 1.0)

```nim on:init
# Initialize explosion particle system
particleInit("{name}", {count})
particleConfigureSparkles("{name}", 8.0)
particleSetChars("{name}", "{chars}")
particleSetEmitRate("{name}", 0.0)  # Don't auto-emit
particleSetLifeRange("{name}", {minLife}, {maxLife})
particleSetVelocityRange("{name}", -20.0, -20.0, 20.0, 20.0)
```

```nim on:input
# Emit explosion burst on mouse click
if event.type == "mouse" and event.action == "press":
  particleSetEmitterPos("{name}", float(event.x), float(event.y))
  particleEmit("{name}", {burst})
```

```nim on:update
# Update explosion particles
particleUpdate("{name}", deltaTime)
```

```nim on:render
# Render explosion particles
particleRender("{name}", "{layer}")
```
# Particles: Mouse Follower
Particles that smoothly follow the mouse cursor.

## Parameters
- `{name}` - Name of the particle system
- `{count}` - Number of particles (default: 50)
- `{smoothing}` - Follow smoothing factor 0-1 (default: 0.1)
- `{speed}` - Follow speed multiplier (default: 5.0)
- `{chars}` - Particle characters (default: "‚óè‚óã‚óâ")
- `{emitRate}` - Particles per second (default: 20.0)

```nim on:init
# Initialize mouse follower particle system
var {name}_x = float(termWidth / 2)
var {name}_y = float(termHeight / 2)

particleInit("{name}", {count})
particleConfigureSparkles("{name}", 8.0)
particleSetChars("{name}", "{chars}")
particleSetEmitRate("{name}", {emitRate})
particleSetEmitterPos("{name}", {name}_x, {name}_y)
particleSetLifeRange("{name}", 0.5, 1.5)
particleSetVelocityRange("{name}", -5.0, -5.0, 5.0, 5.0)
```

```nim on:update
# Smoothly follow mouse position
var mx = float(mouseX)
var my = float(mouseY)
var dx = mx - {name}_x
var dy = my - {name}_y

{name}_x += dx * {smoothing} * deltaTime * {speed}
{name}_y += dy * {smoothing} * deltaTime * {speed}

particleSetEmitterPos("{name}", {name}_x, {name}_y)
particleUpdate("{name}", deltaTime)
```

```nim on:render
# Render follower particles
particleRender("{name}", "default")
```
