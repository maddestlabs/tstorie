<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PNG Workflow Test</title>
    <style>
        body {
            font-family: monospace;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background: #001111;
            color: #00d98e;
        }
        
        h1 {
            color: #00d98e;
            border-bottom: 2px solid #00d98e;
            padding-bottom: 10px;
        }
        
        .section {
            margin: 30px 0;
            padding: 20px;
            background: rgba(0, 40, 40, 0.5);
            border: 1px solid #00d98e;
            border-radius: 8px;
        }
        
        button {
            background: #00d98e;
            color: #001111;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        button:hover {
            background: #00ffaa;
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        textarea {
            width: 100%;
            height: 150px;
            background: #001111;
            color: #00d98e;
            border: 1px solid #00d98e;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            resize: vertical;
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 20, 20, 0.8);
            border-left: 4px solid #00d98e;
            min-height: 20px;
        }
        
        .status.error {
            border-left-color: #ff4444;
            color: #ff4444;
        }
        
        .status.success {
            border-left-color: #00ff88;
            color: #00ff88;
        }
        
        canvas {
            border: 2px solid #00d98e;
            margin: 10px 0;
            background: #001111;
        }
        
        code {
            background: rgba(0, 217, 142, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <h1>üñºÔ∏è PNG Workflow Sharing Test</h1>
    
    <div class="section">
        <h2>Test Canvas (Terminal Simulation)</h2>
        <canvas id="terminal" width="400" height="200"></canvas>
        <p>This canvas simulates your tStorie terminal. The PNG will capture this.</p>
    </div>
    
    <div class="section">
        <h2>1. Export Test</h2>
        <textarea id="exportContent"># My Test Workflow
echo "Hello from PNG!"

This content will be embedded in the PNG file.
Try adding Unicode: üé® ‚ú® üöÄ

Or some code:
proc test() =
  for i in 0..10:
    echo i
</textarea>
        <button onclick="testExport()">Export to PNG</button>
        <button onclick="testExportLarge()">Export Large Content (100KB)</button>
        <div id="exportStatus" class="status">Click export to test...</div>
    </div>
    
    <div class="section">
        <h2>2. Import Test</h2>
        <button onclick="testImport()">Import from PNG</button>
        <button onclick="testRoundTrip()">Test Round-Trip</button>
        <div id="importStatus" class="status">Click import to test...</div>
        <textarea id="importContent" placeholder="Imported content will appear here..." readonly></textarea>
    </div>
    
    <div class="section">
        <h2>3. Chunk Manipulation Test</h2>
        <button onclick="testChunkCreation()">Test Chunk Creation</button>
        <button onclick="testCRC32()">Test CRC32</button>
        <div id="chunkStatus" class="status">Click test to verify...</div>
    </div>

    <script>
        // Draw something on the test canvas
        const canvas = document.getElementById('terminal');
        const ctx = canvas.getContext('2d');
        
        // Make it look like a terminal
        ctx.fillStyle = '#001111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#00d98e';
        ctx.font = '16px monospace';
        ctx.fillText('tStorie Terminal Simulator', 10, 30);
        ctx.fillText('$ echo "This will be captured in PNG"', 10, 60);
        ctx.fillText('This will be captured in PNG', 10, 90);
        ctx.fillText('$ ls -la', 10, 120);
        ctx.fillText('total 42', 10, 150);
        ctx.fillText('drwxr-xr-x  5 user  staff  160 Jan 13 12:34 .', 10, 180);
        
        // Expose terminal canvas globally (like the real implementation)
        window.terminalCanvas = canvas;
        
        // Status helper
        function setStatus(elementId, message, type = 'info') {
            const el = document.getElementById(elementId);
            el.textContent = message;
            el.className = 'status ' + type;
        }
        
        // ===== PNG CHUNK MANIPULATION CODE (from implementation) =====
        
        function calculateCRC32(data) {
            let crc = 0xFFFFFFFF;
            const crcTable = new Uint32Array(256);
            
            for (let n = 0; n < 256; n++) {
                let c = n;
                for (let k = 0; k < 8; k++) {
                    c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
                }
                crcTable[n] = c;
            }
            
            for (let i = 0; i < data.length; i++) {
                crc = crcTable[(crc ^ data[i]) & 0xFF] ^ (crc >>> 8);
            }
            
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }
        
        function createPNGTextChunk(keyword, text) {
            const keywordBytes = new TextEncoder().encode(keyword);
            const textBytes = new TextEncoder().encode(text);
            
            const dataLength = keywordBytes.length + 1 + textBytes.length;
            const chunk = new Uint8Array(12 + dataLength);
            const view = new DataView(chunk.buffer);
            
            view.setUint32(0, dataLength, false);
            
            chunk[4] = 116; chunk[5] = 69; chunk[6] = 88; chunk[7] = 116; // "tEXt"
            
            chunk.set(keywordBytes, 8);
            chunk[8 + keywordBytes.length] = 0;
            chunk.set(textBytes, 9 + keywordBytes.length);
            
            const crcData = chunk.subarray(4, 8 + dataLength);
            const crc = calculateCRC32(crcData);
            view.setUint32(8 + dataLength, crc, false);
            
            return chunk;
        }
        
        function injectChunkBeforeIEND(pngData, newChunk) {
            let iendPos = -1;
            for (let i = pngData.length - 12; i >= 8; i--) {
                if (pngData[i] === 73 && pngData[i+1] === 69 && 
                    pngData[i+2] === 78 && pngData[i+3] === 68) {
                    iendPos = i - 4;
                    break;
                }
            }
            
            if (iendPos === -1) {
                throw new Error('Invalid PNG: IEND chunk not found');
            }
            
            const result = new Uint8Array(pngData.length + newChunk.length);
            result.set(pngData.subarray(0, iendPos), 0);
            result.set(newChunk, iendPos);
            result.set(pngData.subarray(iendPos), iendPos + newChunk.length);
            
            return result;
        }
        
        function extractPNGTextChunks(pngData) {
            const chunks = {};
            let pos = 8;
            
            while (pos < pngData.length - 12) {
                const view = new DataView(pngData.buffer, pngData.byteOffset + pos);
                const length = view.getUint32(0, false);
                
                const type = String.fromCharCode(
                    pngData[pos + 4],
                    pngData[pos + 5],
                    pngData[pos + 6],
                    pngData[pos + 7]
                );
                
                if (type === 'tEXt') {
                    const dataStart = pos + 8;
                    const dataEnd = dataStart + length;
                    const chunkData = pngData.subarray(dataStart, dataEnd);
                    
                    let nullPos = 0;
                    while (nullPos < chunkData.length && chunkData[nullPos] !== 0) {
                        nullPos++;
                    }
                    
                    if (nullPos < chunkData.length) {
                        const keyword = new TextDecoder().decode(chunkData.subarray(0, nullPos));
                        const text = new TextDecoder().decode(chunkData.subarray(nullPos + 1));
                        chunks[keyword] = text;
                    }
                }
                
                if (type === 'IEND') break;
                
                pos += 12 + length;
            }
            
            return chunks;
        }
        
        async function compress(string) {
            const byteArray = new TextEncoder().encode(string);
            const stream = new CompressionStream('deflate-raw');
            const writer = stream.writable.getWriter();
            writer.write(byteArray);
            writer.close();
            const buffer = await new Response(stream.readable).arrayBuffer();
            return btoa(String.fromCharCode(...new Uint8Array(buffer)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        async function decompress(b64) {
            let base64 = b64.replace(/-/g, '+').replace(/_/g, '/');
            while (base64.length % 4) {
                base64 += '=';
            }
            
            const binaryString = atob(base64);
            const byteArray = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                byteArray[i] = binaryString.charCodeAt(i);
            }
            
            const stream = new DecompressionStream('deflate-raw');
            const writer = stream.writable.getWriter();
            writer.write(byteArray);
            writer.close();
            const buffer = await new Response(stream.readable).arrayBuffer();
            return new TextDecoder().decode(buffer);
        }
        
        async function captureTerminalToPNG(content) {
            const canvas = window.terminalCanvas;
            if (!canvas) {
                throw new Error('Terminal canvas not found');
            }
            
            const blob = await new Promise((resolve, reject) => {
                canvas.toBlob((b) => {
                    if (b) resolve(b);
                    else reject(new Error('Failed to capture canvas'));
                }, 'image/png');
            });
            
            const arrayBuffer = await blob.arrayBuffer();
            const pngData = new Uint8Array(arrayBuffer);
            
            const compressed = await compress(content);
            const workflowChunk = createPNGTextChunk('tStorie-workflow', compressed);
            const finalPNG = injectChunkBeforeIEND(pngData, workflowChunk);
            
            return new Blob([finalPNG], { type: 'image/png' });
        }
        
        async function extractWorkflowFromPNG(pngFile) {
            const arrayBuffer = await pngFile.arrayBuffer();
            const pngData = new Uint8Array(arrayBuffer);
            const chunks = extractPNGTextChunks(pngData);
            
            if (chunks['tStorie-workflow']) {
                return await decompress(chunks['tStorie-workflow']);
            }
            
            return null;
        }
        
        // ===== TEST FUNCTIONS =====
        
        async function testExport() {
            try {
                setStatus('exportStatus', 'Exporting...', 'info');
                
                const content = document.getElementById('exportContent').value;
                const blob = await captureTerminalToPNG(content);
                
                // Download the PNG
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'test-workflow.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                setStatus('exportStatus', 
                    `‚úì Success! PNG exported (${(blob.size / 1024).toFixed(2)} KB)`, 
                    'success');
            } catch (e) {
                setStatus('exportStatus', `‚úó Error: ${e.message}`, 'error');
            }
        }
        
        async function testExportLarge() {
            try {
                setStatus('exportStatus', 'Generating large content...', 'info');
                
                // Generate ~100KB of content
                let largeContent = '# Large Test Workflow\n\n';
                for (let i = 0; i < 1000; i++) {
                    largeContent += `proc test${i}() =\n  echo "Function ${i}"\n  # ${Math.random()}\n\n`;
                }
                
                setStatus('exportStatus', `Exporting ${(largeContent.length / 1024).toFixed(2)} KB...`, 'info');
                
                const blob = await captureTerminalToPNG(largeContent);
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'large-workflow.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                setStatus('exportStatus', 
                    `‚úì Large export success! ${(largeContent.length / 1024).toFixed(2)} KB ‚Üí ${(blob.size / 1024).toFixed(2)} KB PNG`, 
                    'success');
            } catch (e) {
                setStatus('exportStatus', `‚úó Error: ${e.message}`, 'error');
            }
        }
        
        async function testImport() {
            try {
                setStatus('importStatus', 'Select a PNG file...', 'info');
                
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/png';
                
                input.onchange = async (e) => {
                    try {
                        const file = e.target.files[0];
                        if (!file) return;
                        
                        setStatus('importStatus', 'Extracting workflow...', 'info');
                        
                        const content = await extractWorkflowFromPNG(file);
                        
                        if (content) {
                            document.getElementById('importContent').value = content;
                            setStatus('importStatus', 
                                `‚úì Success! Imported ${(content.length / 1024).toFixed(2)} KB`, 
                                'success');
                        } else {
                            setStatus('importStatus', '‚ö† No workflow found in PNG', 'error');
                        }
                    } catch (e) {
                        setStatus('importStatus', `‚úó Error: ${e.message}`, 'error');
                    }
                };
                
                input.click();
            } catch (e) {
                setStatus('importStatus', `‚úó Error: ${e.message}`, 'error');
            }
        }
        
        async function testRoundTrip() {
            try {
                setStatus('importStatus', 'Testing round-trip...', 'info');
                
                const original = document.getElementById('exportContent').value;
                
                // Export
                const blob = await captureTerminalToPNG(original);
                
                // Import
                const extracted = await extractWorkflowFromPNG(blob);
                
                if (extracted === original) {
                    document.getElementById('importContent').value = extracted;
                    setStatus('importStatus', 
                        `‚úì Round-trip success! ${original.length} bytes preserved perfectly`, 
                        'success');
                } else {
                    setStatus('importStatus', 
                        `‚úó Round-trip failed! Content mismatch (${original.length} ‚Üí ${extracted?.length || 0})`, 
                        'error');
                }
            } catch (e) {
                setStatus('importStatus', `‚úó Error: ${e.message}`, 'error');
            }
        }
        
        function testChunkCreation() {
            try {
                const chunk = createPNGTextChunk('test', 'data');
                
                // Verify structure
                const view = new DataView(chunk.buffer);
                const length = view.getUint32(0, false);
                const type = String.fromCharCode(chunk[4], chunk[5], chunk[6], chunk[7]);
                
                if (type === 'tEXt' && length === 9) { // "test" + null + "data"
                    setStatus('chunkStatus', 
                        `‚úì Chunk creation works! Length: ${length}, Type: ${type}, Total: ${chunk.length} bytes`, 
                        'success');
                } else {
                    setStatus('chunkStatus', 
                        `‚úó Chunk malformed! Type: ${type}, Length: ${length}`, 
                        'error');
                }
            } catch (e) {
                setStatus('chunkStatus', `‚úó Error: ${e.message}`, 'error');
            }
        }
        
        function testCRC32() {
            try {
                // Test known value: "tEXt" should give a specific CRC
                const testData = new Uint8Array([116, 69, 88, 116]); // "tEXt"
                const crc = calculateCRC32(testData);
                
                setStatus('chunkStatus', 
                    `‚úì CRC32 works! "tEXt" = 0x${crc.toString(16).toUpperCase()}`, 
                    'success');
            } catch (e) {
                setStatus('chunkStatus', `‚úó Error: ${e.message}`, 'error');
            }
        }
    </script>
</body>
</html>
