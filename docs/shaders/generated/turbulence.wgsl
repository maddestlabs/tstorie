// Generated by TStorie Noise Composer
// Configuration: Turbulent Fire

// Output buffer
@group(0) @binding(0) var<storage, read_write> output: array<u32>;

// Parameters uniform
@group(0) @binding(1) var<uniform> params: Params;

struct Params {
  width: u32,
  height: u32,
  offsetX: i32,
  offsetY: i32,
}

// Integer hash function (WGSL u32 version)
fn intHash(x: u32, seed: u32) -> u32 {
  var h = x ^ seed;
  h = h ^ (h >> 16u);
  h = h * 0x7feb352du;
  h = h ^ (h >> 15u);
  h = h * 0x846ca68bu;
  h = h ^ (h >> 16u);
  return h & 0xFFFFu;
}

fn intHash2D(x: u32, y: u32, seed: u32) -> u32 {
  return intHash(x + intHash(y, seed), seed);
}

fn intHash3D(x: u32, y: u32, z: u32, seed: u32) -> u32 {
  return intHash(x + intHash(y + intHash(z, seed), seed), seed);
}

// Integer lerp (t is 0..1000)
fn lerp(a: i32, b: i32, t: i32) -> i32 {
  return a + ((b - a) * t) / 1000;
}

// Perlin fade function
fn perlinFade(t: i32) -> i32 {
  let tc = clamp(t, 0, 1000);
  let t2 = (tc * tc) / 1000;
  let t3 = (t2 * tc) / 1000;
  let t4 = (t3 * tc) / 1000;
  let t5 = (t4 * tc) / 1000;
  return (6 * t5 - 15 * t4 + 10 * t3);
}

// Perlin gradient (simplified for WGSL)
fn perlinGrad2D(hash: u32, x: i32, y: i32) -> i32 {
  // Simplified gradient table (8 directions)
  let h = hash & 7u;
  let gx = select(-1000, 1000, (h & 4u) == 0u);
  let gy = select(-1000, 1000, (h & 2u) == 0u);
  return (gx * x + gy * y) / 1000;
}


// Generated noise function
fn perlinNoise2D(x: i32, y: i32) -> i32 {
  let scale = 40;
  let seed = 777u;
  
  let cellX = x / scale;
  let cellY = y / scale;
  let localX = ((x % scale) * 1000) / scale;
  let localY = ((y % scale) * 1000) / scale;
  
  // Get gradient hashes at four corners
  let aa = intHash(intHash(u32(cellX), seed) + u32(cellY), seed);
  let ab = intHash(intHash(u32(cellX), seed) + u32(cellY + 1), seed);
  let ba = intHash(intHash(u32(cellX + 1), seed) + u32(cellY), seed);
  let bb = intHash(intHash(u32(cellX + 1), seed) + u32(cellY + 1), seed);
  
  // Compute dot products
  let gx0 = perlinGrad2D(aa, localX, localY);
  let gx1 = perlinGrad2D(ba, localX - 1000, localY);
  let gy0 = perlinGrad2D(ab, localX, localY - 1000);
  let gy1 = perlinGrad2D(bb, localX - 1000, localY - 1000);
  
  // Interpolate
  let u = perlinFade(localX);
  let v = perlinFade(localY);
  let x1 = lerp(gx0, gx1, u);
  let x2 = lerp(gy0, gy1, u);
  let noise = lerp(x1, x2, v);
  
  // Map to [0..65535]
  return ((noise + 1000) * 65535) / 2000;
}
fn generatedNoise(x: i32, y: i32) -> i32 {
  var total = 0;
  var amplitude = 32768;
  var frequency = 40;
  var maxValue = 0;
  
  for (var i = 0; i < 3; i = i + 1) {
    var value = perlinNoise2D(x * 1000 / frequency, y * 1000 / frequency);
    value = abs(value - 32768);
    total = total + (value * amplitude) / 65535;
    maxValue = maxValue + amplitude;
    amplitude = (amplitude * 500) / 1000;
    frequency = (frequency * 2000) / 1000;
  }
  
  if (maxValue > 0) {
    return (total * 65535) / maxValue;
  }
  return 0;
}

// Main compute shader
@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let x = i32(global_id.x);
  let y = i32(global_id.y);
  
  if (x >= i32(params.width) || y >= i32(params.height)) {
    return;
  }
  
  // Sample noise at pixel coordinate (with optional offset for animation)
  let noise = generatedNoise(x + params.offsetX, y + params.offsetY);
  
  // Store as 16-bit value (0..65535)
  let idx = u32(y) * params.width + u32(x);
  output[idx] = u32(noise);
}
