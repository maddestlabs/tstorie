// Generated by TStorie Noise Composer
// Configuration: Billow Clouds

// Output buffer
@group(0) @binding(0) var<storage, read_write> output: array<u32>;

// Parameters uniform
@group(0) @binding(1) var<uniform> params: Params;

struct Params {
  width: u32,
  height: u32,
  offsetX: i32,
  offsetY: i32,
}

// Integer hash function (WGSL u32 version)
fn intHash(x: u32, seed: u32) -> u32 {
  var h = x ^ seed;
  h = h ^ (h >> 16u);
  h = h * 0x7feb352du;
  h = h ^ (h >> 15u);
  h = h * 0x846ca68bu;
  h = h ^ (h >> 16u);
  return h & 0xFFFFu;
}

fn intHash2D(x: u32, y: u32, seed: u32) -> u32 {
  return intHash(x + intHash(y, seed), seed);
}

fn intHash3D(x: u32, y: u32, z: u32, seed: u32) -> u32 {
  return intHash(x + intHash(y + intHash(z, seed), seed), seed);
}

// Integer lerp (t is 0..1000)
fn lerp(a: i32, b: i32, t: i32) -> i32 {
  return a + ((b - a) * t) / 1000;
}

// Perlin fade function
fn perlinFade(t: i32) -> i32 {
  let tc = clamp(t, 0, 1000);
  let t2 = (tc * tc) / 1000;
  let t3 = (t2 * tc) / 1000;
  let t4 = (t3 * tc) / 1000;
  let t5 = (t4 * tc) / 1000;
  return (6 * t5 - 15 * t4 + 10 * t3);
}

// Perlin gradient (simplified for WGSL)
fn perlinGrad2D(hash: u32, x: i32, y: i32) -> i32 {
  // Simplified gradient table (8 directions)
  let h = hash & 7u;
  let gx = select(-1000, 1000, (h & 4u) == 0u);
  let gy = select(-1000, 1000, (h & 2u) == 0u);
  return (gx * x + gy * y) / 1000;
}


// Generated noise function
fn simplexNoise2D(x: i32, y: i32) -> i32 {
  let scale = 50;
  let seed = 456u;
  
  // Skewing constants
  let F2 = 366;  // (sqrt(3)-1)/2 * 1000
  let G2 = 211;  // (3-sqrt(3))/6 * 1000
  
  let sx = x / scale;
  let sy = y / scale;
  let localX = ((x % scale) * 1000) / scale;
  let localY = ((y % scale) * 1000) / scale;
  
  let s = ((localX + localY) * F2) / 1000;
  let i = sx + ((localX + s) / 1000);
  let j = sy + ((localY + s) / 1000);
  
  let t = ((i + j) * G2) / 1000;
  let X0 = i - ((i + j) * G2) / 1000;
  let Y0 = j - t;
  let x0 = localX - (X0 * 1000);
  let y0 = localY - (Y0 * 1000);
  
  // Determine simplex
  var i1: i32;
  var j1: i32;
  if (x0 > y0) {
    i1 = 1;
    j1 = 0;
  } else {
    i1 = 0;
    j1 = 1;
  }
  
  let x1 = x0 - i1 * 1000 + G2;
  let y1 = y0 - j1 * 1000 + G2;
  let x2 = x0 - 1000 + 2 * G2;
  let y2 = y0 - 1000 + 2 * G2;
  
  let gi0 = intHash(u32(i) + intHash(u32(j), seed), seed);
  let gi1 = intHash(u32(i + i1) + intHash(u32(j + j1), seed), seed);
  let gi2 = intHash(u32(i + 1) + intHash(u32(j + 1), seed), seed);
  
  var n0 = 0;
  var n1 = 0;
  var n2 = 0;
  
  let t0 = 500 - ((x0 * x0) / 1000 + (y0 * y0) / 1000);
  if (t0 > 0) {
    let t0sq = (t0 * t0) / 1000;
    n0 = (t0sq * t0sq * perlinGrad2D(gi0, x0, y0)) / 1000000;
  }
  
  let t1 = 500 - ((x1 * x1) / 1000 + (y1 * y1) / 1000);
  if (t1 > 0) {
    let t1sq = (t1 * t1) / 1000;
    n1 = (t1sq * t1sq * perlinGrad2D(gi1, x1, y1)) / 1000000;
  }
  
  let t2 = 500 - ((x2 * x2) / 1000 + (y2 * y2) / 1000);
  if (t2 > 0) {
    let t2sq = (t2 * t2) / 1000;
    n2 = (t2sq * t2sq * perlinGrad2D(gi2, x2, y2)) / 1000000;
  }
  
  let noise = (n0 + n1 + n2) * 70;
  return ((noise + 1000) * 65535) / 2000;
}
fn generatedNoise(x: i32, y: i32) -> i32 {
  var total = 0;
  var amplitude = 32768;
  var frequency = 50;
  var maxValue = 0;
  
  for (var i = 0; i < 3; i = i + 1) {
    var value = simplexNoise2D(x * 1000 / frequency, y * 1000 / frequency);
    value = abs(value - 32768) * 2;
    total = total + (value * amplitude) / 65535;
    maxValue = maxValue + amplitude;
    amplitude = (amplitude * 500) / 1000;
    frequency = (frequency * 2000) / 1000;
  }
  
  if (maxValue > 0) {
    return (total * 65535) / maxValue;
  }
  return 0;
}

// Main compute shader
@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
  let x = i32(global_id.x);
  let y = i32(global_id.y);
  
  if (x >= i32(params.width) || y >= i32(params.height)) {
    return;
  }
  
  // Sample noise at pixel coordinate (with optional offset for animation)
  let noise = generatedNoise(x + params.offsetX, y + params.offsetY);
  
  // Store as 16-bit value (0..65535)
  let idx = u32(y) * params.width + u32(x);
  output[idx] = u32(noise);
}
