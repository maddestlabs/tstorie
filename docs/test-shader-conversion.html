<!DOCTYPE html>
<html>
<head>
    <title>GLSL vs WGSL Shader Validation</title>
    <style>
        body {
            font-family: monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: #4ec9b0;
        }
        .controls {
            background: #252526;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        select, button {
            background: #3c3c3c;
            color: #d4d4d4;
            border: 1px solid #555;
            padding: 8px 15px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 14px;
            cursor: pointer;
            margin-right: 10px;
        }
        select:hover, button:hover {
            background: #464646;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .panel {
            background: #252526;
            border-radius: 5px;
            overflow: hidden;
        }
        .panel-header {
            background: #333;
            padding: 10px 15px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .status {
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
        }
        .status.webgl { background: #569cd6; }
        .status.webgpu { background: #4ec9b0; }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .error {
            color: #f48771;
            padding: 15px;
            white-space: pre-wrap;
            font-size: 12px;
        }
        .stats {
            background: #1e1e1e;
            padding: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            font-size: 12px;
        }
        .stat {
            background: #252526;
            padding: 10px;
            border-radius: 3px;
        }
        .stat-label {
            color: #858585;
            margin-bottom: 5px;
        }
        .stat-value {
            color: #4ec9b0;
            font-size: 16px;
            font-weight: bold;
        }
        .shader-list {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        .shader-item {
            background: #3c3c3c;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            text-align: center;
            font-size: 11px;
        }
        .shader-item:hover {
            background: #464646;
        }
        .shader-item.active {
            background: #569cd6;
        }
        .shader-item.tested {
            background: #4ec9b0;
        }
        .shader-item.failed {
            background: #f48771;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”¬ GLSL vs WGSL Shader Validation</h1>
        
        <div class="controls">
            <label>Select Shader: </label>
            <select id="shaderSelect"></select>
            <button id="testBtn">Test Shader</button>
            <button id="testAllBtn">Test All Shaders</button>
            <button id="resetBtn">Reset Tests</button>
        </div>

        <div class="shader-list" id="shaderList"></div>
        
        <div class="comparison">
            <div class="panel">
                <div class="panel-header">
                    <span>GLSL (WebGL)</span>
                    <span class="status webgl">ORIGINAL</span>
                </div>
                <div class="canvas-container">
                    <canvas id="glslCanvas"></canvas>
                </div>
                <div id="glslError" class="error" style="display:none;"></div>
            </div>
            
            <div class="panel">
                <div class="panel-header">
                    <span>WGSL (WebGPU)</span>
                    <span class="status webgpu">CONVERTED</span>
                </div>
                <div class="canvas-container">
                    <canvas id="wgslCanvas"></canvas>
                </div>
                <div id="wgslError" class="error" style="display:none;"></div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Shaders Tested</div>
                <div class="stat-value" id="testedCount">0 / 38</div>
            </div>
            <div class="stat">
                <div class="stat-label">Success Rate</div>
                <div class="stat-value" id="successRate">0%</div>
            </div>
            <div class="stat">
                <div class="stat-label">WebGPU Support</div>
                <div class="stat-value" id="webgpuSupport">Checking...</div>
            </div>
        </div>
    </div>

    <script type="module">
        // Available shaders
        const shaders = [
            'apocalypcrt', 'bloom', 'bloompro', 'blur', 'blurgradual', 'border',
            'clouds', 'crt', 'crumpled', 'filmgrain', 'filmgrainpro', 'filmhairs',
            'filmlines', 'gradientblends', 'gradientviolet', 'grid', 'grid1x', 'grid2x',
            'grille', 'invert', 'lightnight', 'lightsway', 'lightvignette', 'linemovey',
            'outline', 'paper', 'paperdirt', 'paperlinen', 'pixelnoise', 'ruledlines',
            'sand', 'scanlines', 'sketched', 'soften', 'specks', 'twill', 'warpdaze', 'warpsea'
        ];

        // Test results tracking
        const testResults = {};
        let currentShader = null;
        let glslRenderer = null;
        let wgslRenderer = null;

        // Initialize
        async function init() {
            // Check WebGPU support
            const hasWebGPU = navigator.gpu !== undefined;
            document.getElementById('webgpuSupport').textContent = hasWebGPU ? 'YES' : 'NO';
            document.getElementById('webgpuSupport').style.color = hasWebGPU ? '#4ec9b0' : '#f48771';

            // Populate shader select
            const select = document.getElementById('shaderSelect');
            shaders.forEach(shader => {
                const option = document.createElement('option');
                option.value = shader;
                option.textContent = shader;
                select.appendChild(option);
            });

            // Populate shader list
            const shaderList = document.getElementById('shaderList');
            shaders.forEach(shader => {
                const item = document.createElement('div');
                item.className = 'shader-item';
                item.textContent = shader;
                item.dataset.shader = shader;
                item.onclick = () => selectShader(shader);
                shaderList.appendChild(item);
            });

            // Event listeners
            document.getElementById('testBtn').onclick = testCurrentShader;
            document.getElementById('testAllBtn').onclick = testAllShaders;
            document.getElementById('resetBtn').onclick = resetTests;
            document.getElementById('shaderSelect').onchange = (e) => selectShader(e.target.value);

            // Select first shader
            selectShader(shaders[0]);

            // Create test texture
            await createTestTexture();
        }

        function selectShader(shaderName) {
            currentShader = shaderName;
            document.getElementById('shaderSelect').value = shaderName;
            
            // Update shader list highlighting
            document.querySelectorAll('.shader-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.shader === shaderName) {
                    item.classList.add('active');
                }
            });

            // Clear previous renders
            clearCanvases();
        }

        function clearCanvases() {
            const glslCanvas = document.getElementById('glslCanvas');
            const wgslCanvas = document.getElementById('wgslCanvas');
            
            const glslCtx = glslCanvas.getContext('2d');
            const wgslCtx = wgslCanvas.getContext('2d');
            
            if (glslCtx) glslCtx.clearRect(0, 0, glslCanvas.width, glslCanvas.height);
            if (wgslCtx) wgslCtx.clearRect(0, 0, wgslCanvas.width, wgslCanvas.height);

            document.getElementById('glslError').style.display = 'none';
            document.getElementById('wgslError').style.display = 'none';
        }

        async function createTestTexture() {
            // Create a simple test texture with some content
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Draw test pattern
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, '#4ec9b0');
            gradient.addColorStop(0.5, '#569cd6');
            gradient.addColorStop(1, '#c586c0');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            
            // Add some text
            ctx.fillStyle = 'white';
            ctx.font = '48px monospace';
            ctx.fillText('TStorie', 150, 250);
            ctx.font = '24px monospace';
            ctx.fillText('Shader Test', 170, 290);
            
            return canvas;
        }

        async function testCurrentShader() {
            if (!currentShader) return;

            try {
                // Load shaders
                const glslModule = await import(`./shaders/${currentShader}.js`);
                
                // Try to load WGSL version
                let wgslModule = null;
                try {
                    wgslModule = await import(`./shaders/wgsl/${currentShader}.js`);
                } catch (e) {
                    showError('wgsl', `WGSL shader not found: ${currentShader}`);
                    testResults[currentShader] = { success: false, error: 'WGSL not found' };
                    updateStats();
                    return;
                }

                // Test GLSL rendering
                const glslSuccess = await testGLSL(glslModule.default);
                
                // Test WGSL rendering
                const wgslSuccess = await testWGSL(wgslModule.default);

                // Record results
                testResults[currentShader] = {
                    success: glslSuccess && wgslSuccess,
                    glsl: glslSuccess,
                    wgsl: wgslSuccess
                };

                updateStats();
                updateShaderListItem(currentShader);

            } catch (error) {
                console.error('Test error:', error);
                testResults[currentShader] = { success: false, error: error.message };
                updateStats();
            }
        }

        async function testGLSL(shader) {
            const canvas = document.getElementById('glslCanvas');
            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
            
            if (!gl) {
                showError('glsl', 'WebGL not supported');
                return false;
            }

            try {
                canvas.width = 800;
                canvas.height = 400;
                
                // Compile shader
                const program = createShaderProgram(gl, shader.vertexShader, shader.fragmentShader);
                if (!program) {
                    showError('glsl', 'Shader compilation failed');
                    return false;
                }

                // Set up rendering (simplified - just test compilation)
                gl.useProgram(program);
                gl.viewport(0, 0, canvas.width, canvas.height);
                gl.clearColor(0.2, 0.3, 0.4, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);

                document.getElementById('glslError').style.display = 'none';
                return true;

            } catch (error) {
                showError('glsl', error.message);
                return false;
            }
        }

        async function testWGSL(shader) {
            if (!navigator.gpu) {
                showError('wgsl', 'WebGPU not supported');
                return false;
            }

            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    showError('wgsl', 'No WebGPU adapter found');
                    return false;
                }

                const device = await adapter.requestDevice();
                const canvas = document.getElementById('wgslCanvas');
                canvas.width = 800;
                canvas.height = 400;

                const context = canvas.getContext('webgpu');
                if (!context) {
                    showError('wgsl', 'Failed to get WebGPU context');
                    return false;
                }

                // Configure context
                const format = navigator.gpu.getPreferredCanvasFormat();
                context.configure({
                    device,
                    format,
                    alphaMode: 'premultiplied',
                });

                // Try to create shader module (validates WGSL)
                const shaderModule = device.createShaderModule({
                    code: shader.vertexShader + '\n' + shader.fragmentShader
                });

                // Check for compilation errors
                const info = await shaderModule.getCompilationInfo();
                const errors = info.messages.filter(m => m.type === 'error');
                
                if (errors.length > 0) {
                    const errorMsg = errors.map(e => `Line ${e.lineNum}: ${e.message}`).join('\n');
                    showError('wgsl', `Compilation errors:\n${errorMsg}`);
                    return false;
                }

                // Clear canvas to show it loaded
                const commandEncoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();
                
                const renderPass = commandEncoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.2, g: 0.4, b: 0.3, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store',
                    }],
                });
                renderPass.end();
                
                device.queue.submit([commandEncoder.finish()]);

                document.getElementById('wgslError').style.display = 'none';
                return true;

            } catch (error) {
                showError('wgsl', error.message);
                return false;
            }
        }

        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
            
            if (!vertexShader || !fragmentShader) return null;

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program link error:', gl.getProgramInfoLog(program));
                return null;
            }

            return program;
        }

        function compileShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function showError(type, message) {
            const errorDiv = document.getElementById(`${type}Error`);
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function updateStats() {
            const tested = Object.keys(testResults).length;
            const successful = Object.values(testResults).filter(r => r.success).length;
            const successRate = tested > 0 ? Math.round((successful / tested) * 100) : 0;

            document.getElementById('testedCount').textContent = `${tested} / 38`;
            document.getElementById('successRate').textContent = `${successRate}%`;
        }

        function updateShaderListItem(shaderName) {
            const item = document.querySelector(`.shader-item[data-shader="${shaderName}"]`);
            if (!item) return;

            const result = testResults[shaderName];
            item.classList.remove('tested', 'failed');
            
            if (result) {
                if (result.success) {
                    item.classList.add('tested');
                } else {
                    item.classList.add('failed');
                }
            }
        }

        async function testAllShaders() {
            document.getElementById('testAllBtn').disabled = true;
            document.getElementById('testAllBtn').textContent = 'Testing...';

            for (const shader of shaders) {
                selectShader(shader);
                await testCurrentShader();
                await new Promise(resolve => setTimeout(resolve, 500)); // Small delay between tests
            }

            document.getElementById('testAllBtn').disabled = false;
            document.getElementById('testAllBtn').textContent = 'Test All Shaders';
            alert('All shaders tested! Check the results above.');
        }

        function resetTests() {
            for (const key in testResults) {
                delete testResults[key];
            }
            document.querySelectorAll('.shader-item').forEach(item => {
                item.classList.remove('tested', 'failed');
            });
            updateStats();
            clearCanvases();
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
