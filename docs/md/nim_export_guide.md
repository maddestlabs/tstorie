# Nim Export Feature - Implementation Guide

## Overview

The Nim export feature enables tStorie users to transition from rapid prototyping to production-ready native executables. It analyzes markdown code blocks and generates fully compilable, optimized Nim programs.

## What's Implemented (Phase 1)

### ✅ Import Detection & Analysis

The system automatically detects which libraries your code uses and generates appropriate import statements:

- **Standard Library Functions**: Automatically imports `math`, `strutils`, `random`, `times`, `os`, `tables`, `algorithm`, etc.
- **tStorie Libraries**: Detects usage of `canvas`, `layout`, `audio`, `figlet`, `events`, `animation`, etc.
- **AST-Based Analysis**: Uses nimini's parser to analyze code at the AST level (not regex-based)

### ✅ Code Organization by Lifecycle

Code blocks are organized into proper execution order:
- `on:init` → Program initialization
- `on:update` → Main loop update section
- `on:render` → Rendering logic
- `on:input` → Input handling (TODO: needs integration)
- `on:shutdown` → Cleanup code

### ✅ Basic Program Generation

Generates a complete, compilable Nim program with:
- Proper imports
- Main procedure
- Game loop structure (when update/render exists)
- Entry point (`when isMainModule`)

## Usage

### Basic API

```nim
import lib/storie_md
import lib/nim_export

# Parse your markdown
let doc = parseMarkdownDocument(markdownContent)

# Generate Nim code
let nimCode = exportToNim(doc, "myfile.md")

# Or export directly to file
exportToNimFile(doc, "output.nim", "myfile.md")

# Debug: see what imports are detected
printImportAnalysis(doc)
```

### Example

Given this markdown:

````markdown
---
title: My Game
---

# My Game

```nim on:init
var score = 0
randomize()
```

```nim on:update
score = score + 1
let angle = sin(float(score) * 0.1)
```

```nim on:render
write(10, 10, "Score: " & $score)
```
````

It generates:

```nim
# Generated by tStorie Nim Export
# Source: mygame.md

import math
import random
import lib/canvas

proc main() =
  # Initialization
  var score = 0
  randomize()
  
  # Main loop
  var running = true
  while running:
    # Update
    score = score + 1
    let angle = sin(float(score) * 0.1)
    
    # Render
    write(10, 10, "Score: " & $score)

when isMainModule:
  main()
```

## Architecture

### Detection System

The import detection works by:

1. **Parsing**: Code blocks are parsed using nimini into an AST
2. **Walking**: Recursively walks the AST looking for function calls
3. **Mapping**: Matches function names against two lookup tables:
   - `StdLibFunctionMap`: stdlib functions → module names
   - `StorieLibFunctionMap`: tStorie functions → lib module names
4. **Aggregation**: Collects all required imports across all code blocks

### Key Components

- `lib/nim_export.nim` - Main export module
- `ImportInfo` - Tracks stdlib, storie, and custom imports
- `ExportContext` - Full export state including organized code blocks
- `analyzeExpression`/`analyzeStatement` - AST walkers
- `generateNimProgram` - Template-based code generation

## What's Next (Future Phases)

### Phase 2: Variable Scope Analysis
**Goal**: Proper separation of global vs local variables

Currently, all code is placed inside `main()`. Need to:
- Detect which variables are used across lifecycle boundaries
- Promote shared variables to module-level globals
- Keep truly local variables inside functions
- Handle state properly (especially for games)

**Implementation approach**:
```nim
proc analyzeVariableScopes*(doc: MarkdownDocument): VariableScopes
```

### Phase 3: Function Extraction
**Goal**: Detect and extract user-defined procedures

Currently, user-defined procs are inline in init code. Need to:
- Detect `proc` statements in AST
- Extract them to module level
- Maintain proper call order
- Handle nested procedures

### Phase 4: tStorie API Wrapper
**Goal**: Bridge the gap between tStorie runtime and native Nim

The generated code currently assumes direct access to tStorie libs, but needs:
- Event loop management (currently `while running` is a placeholder)
- Input handling integration
- Layer management setup
- Terminal initialization/cleanup
- Proper lifecycle hooks

**Example wrapper**:
```nim
import lib/canvas, lib/layout
# ... other imports

# Generated global state
var score = 0

proc onInit() =
  randomize()
  score = 0

proc onUpdate(dt: float) =
  score += 1

proc onRender() =
  write(10, 10, "Score: " & $score)

# tStorie runtime wrapper
when isMainModule:
  initTStorieRuntime()
  registerCallbacks(onInit, onUpdate, onRender)
  runGameLoop()
```

### Phase 5: Optimization Passes
**Goal**: Generate more efficient code

- Dead code elimination
- Constant folding
- Loop optimizations
- String concatenation optimization
- Inline small procedures

### Phase 6: Platform-Specific Exports
**Goal**: Target different platforms efficiently

- Web: Continue using WASM
- Desktop: Native terminal
- Mobile: Consider termux or alternative UIs
- Embedded: Minimal runtime

### Phase 7: Type Inference & Annotations
**Goal**: Add proper type information

tStorie uses dynamic types via nimini. For native export:
- Infer types where possible
- Add type annotations to generated code
- Handle generic types properly
- Minimize runtime type checks

## Current Limitations

### What Works
✅ Basic import detection for common functions
✅ Lifecycle-based code organization
✅ Simple program structure generation

### What Needs Work
❌ No variable scope analysis (everything local to main)
❌ No function extraction
❌ No tStorie runtime integration
❌ No input event handling
❌ Placeholder game loop (no real event system)
❌ No optimization
❌ Missing many stdlib/library mappings
❌ No error handling/reporting in generated code
❌ No support for custom user imports

## Testing

Run the test program:

```bash
nim c -d:release test_export.nim
./test_export
```

Add your own tests by creating markdown documents and exporting them:

```nim
import lib/storie_md, lib/nim_export

let markdown = readFile("docs/demos/clock.md")
let doc = parseMarkdownDocument(markdown)
let nimCode = exportToNim(doc, "clock.md")
writeFile("clock_exported.nim", nimCode)
```

## Design Decisions

### Why AST-Based Detection?
Using AST analysis instead of regex gives us:
- Accurate understanding of actual code structure
- No false positives from comments/strings
- Easy to extend with more sophisticated analysis
- Foundation for future optimization passes

### Why Template-Based Generation?
Starting with templates is:
- Simple and maintainable
- Easy to understand the output
- Good for getting something working quickly
- Can evolve to AST-based generation later

### Why Separate Phases?
Breaking the work into phases allows:
- Incremental progress
- Early user feedback
- Testing each component independently
- Easier to maintain and debug

## Contributing

To extend the function maps:

```nim
# In lib/nim_export.nim

const StdLibFunctionMap = {
  # Add new mappings here
  "myFunc": "mymodule",
  # ...
}.toTable

const StorieLibFunctionMap = {
  # Add new tStorie library functions
  "myStorieFunc": "my_storie_lib",
  # ...
}.toTable
```

To improve code generation, modify `generateNimProgram()`.

## Questions to Consider

1. **Should exported code depend on tStorie libraries, or should they be standalone?**
   - Current: Depends on lib/ modules
   - Alternative: Generate fully standalone code (harder but more portable)

2. **How should we handle the transition from interpreted to compiled?**
   - Some nimini features may not map 1:1 to Nim
   - Need clear documentation on limitations

3. **What's the target audience for exported code?**
   - Prototypers wanting performance?
   - Game jam participants?
   - Production applications?

4. **Should we support partial exports?**
   - Export just one section?
   - Export as a library others can use?

## Summary

**Phase 1 is complete and functional!** ✨

You can now:
- Analyze code blocks for import requirements
- Generate basic compilable Nim programs
- See the foundation for future optimization

**Next recommended step**: Phase 2 (Variable Scope Analysis) - this will make generated code much more practical and closer to production-ready.

The architecture is extensible and ready for the remaining phases. Each phase builds on the previous one, creating a progressively more sophisticated export system.
