# Dungeon Generator Auto-Pointer Conversion

## Summary

Successfully converted the dungeon_gen module from manual bindings to the auto_pointer system.

## Results

- **Code Reduction**: 181 lines → 58 lines (68% reduction)
- **Functions Auto-Generated**: 9 functions
- **Manual Wrappers Remaining**: 1 (dungeonGetCellChar - for character conversion)

## Changes Made

### 1. lib/dungeon_gen.nim

Added auto_pointer support:
```nim
import ../nimini/auto_pointer

autoPointer(DungeonGenerator)
```

Added pragmas to exported functions:
- `{.autoExposePointer.}` on constructor: `newDungeonGenerator`
- `{.autoExposePointerMethod.}` on methods: `generate`, `update`

Created accessor methods for simple types:
- `getCellAt(gen: DungeonGenerator, x, y: int): int`
- `getWidth(gen: DungeonGenerator): int`
- `getHeight(gen: DungeonGenerator): int`
- `getStep(gen: DungeonGenerator): int`
- `isStillGenerating(gen: DungeonGenerator): bool`

### 2. lib/dungeon_bindings.nim

Complete rewrite from 181 lines to 58 lines:

**Before**: Manual wrappers for every function
```nim
proc dungeonUpdate(args: seq[Value]): Value {.nimini.} =
  let id = args[0].getInt
  let gen = getDungeonGenerator(id)
  gen.update()
  result = Value(kind: vkNil)
```

**After**: One-line registration
```nim
register_update(runtime)  # Auto-generated by macro
```

### 3. test_dungeon_pointer.nimini

Updated function names to match Nim names:
- `dungeonIsGenerating` → `isStillGenerating`
- `dungeonUpdate` → `update`
- `dungeonGetStep` → `getStep`
- `dungeonGetWidth` → `getWidth`
- `dungeonGetHeight` → `getHeight`

## Auto-Generated Functions

The auto_pointer macro automatically creates these functions:

1. `newDungeonGenerator(width: int, height: int, seed: int): int` - Returns pointer ID
2. `releaseDungeonGenerator(id: int)` - Cleans up memory
3. `generate(id: int)` - Generates complete dungeon
4. `update(id: int)` - Runs one generation step
5. `getCellAt(id: int, x: int, y: int): int` - Gets cell value
6. `getWidth(id: int): int` - Gets dungeon width
7. `getHeight(id: int): int` - Gets dungeon height
8. `getStep(id: int): int` - Gets current generation step
9. `isStillGenerating(id: int): bool` - Checks if still generating

## Manual Wrapper (Still Required)

Only one manual wrapper remains:
```nim
proc dungeonGetCellChar(args: seq[Value]): Value {.nimini.} =
  # Custom logic for character conversion
  let id = args[0].getInt
  let x = args[1].getInt
  let y = args[2].getInt
  let gen = getDungeonGenerator(id)
  let cell = gen.getCell(vec2(x.float32, y.float32))
  var c = ' '
  case cell.kind
  of ckWall: c = '#'
  of ckFloor: c = '.'
  of ckCorridor: c = '+'
  of ckDoor: c = 'D'
  of ckRoom: c = 'R'
  result = Value(kind: vkString, strVal: $c)
```

This wrapper is kept because it requires custom type conversion logic (Vec2) and custom character mapping.

## Benefits

1. **Less Code**: 68% reduction in binding code
2. **Maintainability**: Changes to dungeon_gen automatically reflect in bindings
3. **Type Safety**: Macro ensures type conversions are correct
4. **Consistency**: All pointer-based modules follow same pattern
5. **Auto GC**: Generated wrappers automatically call GC_ref/GC_unref

## Pattern Template

For other modules, the pattern is:

1. Add `import ../nimini/auto_pointer` to module
2. Add `autoPointer(YourType)` after type definition
3. Add `{.autoExposePointer.}` to constructor
4. Add `{.autoExposePointerMethod.}` to methods
5. Create wrapper methods for complex types (Vec2, etc)
6. In bindings file, call `register_*` functions
7. Keep manual wrappers only for special logic

## Compilation

```bash
nim c --hints:off lib/dungeon_bindings.nim  # Compiles successfully
./tstorie test_dungeon_pointer.nimini        # Runs successfully
```

## Next Steps

Apply this pattern to other /lib/ modules:
- ansi_parser
- ascii_art
- figlet
- particles
- style
- tui

Each should see similar code reduction and maintainability improvements.
