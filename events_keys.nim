# Generated by tStorie Nim Export (Standalone)
# Source: untitled.md

import times, os
import std/[strutils, tables]  # For join and getOrDefault
import src/types
import src/layers
import src/appstate
import src/input  # Input parsing and polling
import src/simple_event  # Simplified event API
when not defined(emscripten):
  import src/platform/terminal

# Global state
var gState: AppState
var gDefaultLayer: Layer  # Single default layer (layer 0)
var gRunning {.global.} = true
var gInputParser: TerminalInputParser  # For input event parsing
when not defined(emscripten):
  var gTerminalState: TerminalState

# Style helper function
proc getStyle(name: string): Style =
  if gState.styleSheet.hasKey(name):
    let sc = gState.styleSheet[name]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  elif gState.styleSheet.hasKey("default"):
    # Use theme's default style as fallback
    let sc = gState.styleSheet["default"]
    result = Style(
      fg: Color(r: sc.fg.r, g: sc.fg.g, b: sc.fg.b),
      bg: Color(r: sc.bg.r, g: sc.bg.g, b: sc.bg.b),
      bold: sc.bold, italic: sc.italic, underline: sc.underline, dim: sc.dim)
  else:
    result = defaultStyle()

# Style brightness adjustment
proc brightness(style: Style, factor: float): Style =
  ## Adjusts the brightness of a style's foreground color
  ## factor < 1.0 = darker, factor > 1.0 = brighter
  result = style
  result.fg.r = uint8(clamp(float(style.fg.r) * factor, 0.0, 255.0))
  result.fg.g = uint8(clamp(float(style.fg.g) * factor, 0.0, 255.0))
  result.fg.b = uint8(clamp(float(style.fg.b) * factor, 0.0, 255.0))

# Unified Drawing API - works with any layer
proc draw(layer: string, x, y: int, text: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc draw(layerId: int, x, y: int, text: string, style: Style = getStyle("default")) =
  # Integer layer ID overload (0 = default layer)
  let targetLayer = if layerId == 0: gDefaultLayer
                    elif layerId < gState.layers.len: gState.layers[layerId]
                    else: nil
  if targetLayer.isNil: return
  targetLayer.buffer.writeText(x, y, text, style)

proc clear(layer: string = "", transparent: bool = false) =
  # Clear specific layer, or all layers if no layer specified
  if layer == "":
    for l in gState.layers:
      if transparent: l.buffer.clearTransparent()
      else: l.buffer.clear(gState.themeBackground)
  else:
    let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
    if targetLayer.isNil: return
    if transparent: targetLayer.buffer.clearTransparent() else: targetLayer.buffer.clear(gState.themeBackground)

proc fillRect(layer: string, x, y, w, h: int, ch: string, style: Style = getStyle("default")) =
  let targetLayer = if layer == "default": gDefaultLayer else: getLayer(gState, layer)
  if targetLayer.isNil: return
  targetLayer.buffer.fillRect(x, y, w, h, ch, style)

# Runtime helper functions
proc print(args: varargs[string, `$`]) = echo args.join(" ")
template termWidth: int = gState.termWidth
template termHeight: int = gState.termHeight
proc str(x: int): string = $x
proc str(x: float): string = $x
proc str(x: bool): string = $x
proc str(x: string): string = x

# User global variables
var superPressed: bool
var altPressed: bool
var lastKey: string
var ctrlPressed: bool
var keyPressCount: int
var shiftPressed: bool
var lastKeyCode: int
var lastAction: string

proc main() =
  when not defined(emscripten):
    gTerminalState = setupRawMode()
    hideCursor()
    enableMouseReporting()
    enableKeyboardProtocol()
    
    # Setup signal handlers for graceful shutdown on CTRL-C
    setupSignalHandlers(proc(sig: cint) {.noconv.} = gRunning = false)
    
    let (w, h) = getTermSize()
    gState = newAppState(w, h)
    
    # Initialize default layer (layer 0)
    gDefaultLayer = addLayer(gState, "default", 0)
    
    # Initialization
    # Track keyboard state
    lastKey = "none"
    lastKeyCode = 0
    lastAction = "none"
    keyPressCount = 0
    shiftPressed = false
    ctrlPressed = false
    altPressed = false
    superPressed = false

    var lastTime = epochTime()
    
    try:
      # Main loop
      while gState.running and gRunning:
        let currentTime = epochTime()
        let deltaTime = currentTime - lastTime
        lastTime = currentTime
        
        # Update FPS counter
        gState.updateFpsCounter(deltaTime)
        
        # Poll for input events
        let events = pollInput(gInputParser)
        for nativeEvent in events:
          # Convert to simplified event API
          let event = toSimpleEvent(nativeEvent)
          # Process input event
          # Handle keyboard events through the normal input lifecycle
          if event.type == "key":
            lastKeyCode = event.keyCode
            lastAction = event.action
            
            # Update modifier states from event.mods array
            # mods is an array of strings: ["shift", "alt", "ctrl", "super"]
            shiftPressed = false
            altPressed = false
            ctrlPressed = false
            superPressed = false
            
            var i = 0
            while i < len(event.mods):
              if event.mods[i] == "shift":
                shiftPressed = true
              elif event.mods[i] == "alt":
                altPressed = true
              elif event.mods[i] == "ctrl":
                ctrlPressed = true
              elif event.mods[i] == "super":
                superPressed = true
              i = i + 1
            
            # Convert keyCode to readable name for common keys
            if lastKeyCode == 27:
              lastKey = "ESC"
            elif lastKeyCode == 13:
              lastKey = "ENTER"
            elif lastKeyCode == 32:
              lastKey = "SPACE"
            elif lastKeyCode == 9:
              lastKey = "TAB"
            elif lastKeyCode == 127:
              lastKey = "BACKSPACE"
            elif lastKeyCode == 1000:
              lastKey = "UP"
            elif lastKeyCode == 1001:
              lastKey = "DOWN"
            elif lastKeyCode == 1002:
              lastKey = "LEFT"
            elif lastKeyCode == 1003:
              lastKey = "RIGHT"
            elif lastKeyCode >= 32 and lastKeyCode < 127:
              # Printable ASCII character - show the keyCode
              lastKey = "'" & str(lastKeyCode) & "'"
            else:
              lastKey = "KEY_" & str(lastKeyCode)
          
            if event.action == "press":
              keyPressCount = keyPressCount + 1
            
          
          elif event.type == "text":
            # Handle text input (actual characters typed)
            # This is where you check for specific letters like "T"
            lastKey = "'" & event.text & "'"
            lastKeyCode = 0
            lastAction = "text"
            keyPressCount = keyPressCount + 1
            
            # Example: Check for specific character
            if event.text == "T":
              lastKey = "'T' (uppercase detected!)"
            elif event.text == "t":
              lastKey = "'t' (lowercase detected!)"

        # Check if mouse tracking should be re-enabled
        checkMouseTrackingReenabled(gInputParser)

        # Render
        # Clear screen
        clear()
        
        # Draw title  
        draw(0, 2, 2, "=== KEYBOARD EVENT TEST ===")
        
        # Draw instructions
        draw(0, 2, 4, "Press any key to test keyboard input")
        draw(0, 2, 5, "Press Q or ESC to quit")
        
        # Display keyboard state
        draw(0, 2, 7, "Last Key: " & lastKey)
        draw(0, 2, 8, "Key Code: " & str(lastKeyCode))
        draw(0, 2, 9, "Action: " & lastAction)
        draw(0, 2, 10, "Press Count: " & str(keyPressCount))
        
        # Display modifier states
        var modStr = "Modifiers: "
        if shiftPressed:
          modStr = modStr & "[SHIFT] "
        if ctrlPressed:
          modStr = modStr & "[CTRL] "
        if altPressed:
          modStr = modStr & "[ALT] "
        if superPressed:
          modStr = modStr & "[SUPER] "
        if not (shiftPressed or ctrlPressed or altPressed or superPressed):
          modStr = modStr & "(none)"
        draw(0, 2, 11, modStr)
        
        # Draw a visual keyboard hint
        draw(0, 2, 14, "Common Keys:")
        draw(0, 4, 16, "Arrows: UP/DOWN/LEFT/RIGHT")
        draw(0, 4, 17, "Special: ESC, ENTER, SPACE, TAB")
        draw(0, 4, 18, "Letters: a-z, A-Z")
        draw(0, 4, 19, "Numbers: 0-9")
        draw(0, 4, 20, "Try: Press 'T' or 'Shift+T' to see character detection!")
        
        # Show a press counter box
        draw(0, 50, 7, "+-------------------+")
        draw(0, 50, 8, "| Total Key Presses |")
        draw(0, 50, 9, "|                   |")
        var countStr = str(keyPressCount)
        var padding = 19 - countStr.len
        var leftPad = padding div 2
        var rightPad = padding - leftPad
        var i = 0
        var paddedCount = ""
        while i < leftPad:
          paddedCount = paddedCount & " "
          i = i + 1
        paddedCount = paddedCount & countStr
        i = 0
        while i < rightPad:
          paddedCount = paddedCount & " "
          i = i + 1
        draw(0, 50, 10, "| " & paddedCount & " |")
        draw(0, 50, 11, "+-------------------+")
        
        # Visual feedback for last action
        if lastAction == "press":
          draw(0, 2, 23, ">>> KEY PRESSED <<<")
        elif lastAction == "release":
          draw(0, 2, 23, ">>> KEY RELEASED <<<")
        elif lastAction == "repeat":
          draw(0, 2, 23, ">>> KEY REPEATING <<<")
        elif lastAction == "text":
          draw(0, 2, 23, ">>> TEXT INPUT <<<")

        # Composite layers and display to terminal
        gState.compositeLayers()
        gState.currentBuffer.display(gState.previousBuffer, gState.colorSupport)

        # Frame rate limiting
        if gState.targetFps > 0.0:
          let frameTime = epochTime() - currentTime
          let targetFrameTime = 1.0 / gState.targetFps
          let sleepTime = targetFrameTime - frameTime
          if sleepTime > 0:
            sleep(int(sleepTime * 1000))
    finally:
      # Cleanup terminal
      disableKeyboardProtocol()
      disableMouseReporting()
      showCursor()
      clearScreen()
      restoreTerminal(gTerminalState)
      stdout.write("\n")
      stdout.flushFile()
    # Cleanup
    # Cleanup

when isMainModule:
  main()
